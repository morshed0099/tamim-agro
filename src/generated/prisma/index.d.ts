
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Farmer
 * 
 */
export type Farmer = $Result.DefaultSelection<Prisma.$FarmerPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model BranchEmployeeHistory
 * 
 */
export type BranchEmployeeHistory = $Result.DefaultSelection<Prisma.$BranchEmployeeHistoryPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Flock
 * 
 */
export type Flock = $Result.DefaultSelection<Prisma.$FlockPayload>
/**
 * Model FlockReport
 * 
 */
export type FlockReport = $Result.DefaultSelection<Prisma.$FlockReportPayload>
/**
 * Model FeedNameCategory
 * 
 */
export type FeedNameCategory = $Result.DefaultSelection<Prisma.$FeedNameCategoryPayload>
/**
 * Model Feed
 * 
 */
export type Feed = $Result.DefaultSelection<Prisma.$FeedPayload>
/**
 * Model AllGenericMedicin
 * 
 */
export type AllGenericMedicin = $Result.DefaultSelection<Prisma.$AllGenericMedicinPayload>
/**
 * Model MedicineNameAdd
 * 
 */
export type MedicineNameAdd = $Result.DefaultSelection<Prisma.$MedicineNameAddPayload>
/**
 * Model MedicinePurchess
 * 
 */
export type MedicinePurchess = $Result.DefaultSelection<Prisma.$MedicinePurchessPayload>
/**
 * Model MedicineStock
 * 
 */
export type MedicineStock = $Result.DefaultSelection<Prisma.$MedicineStockPayload>
/**
 * Model SellMedicine
 * 
 */
export type SellMedicine = $Result.DefaultSelection<Prisma.$SellMedicinePayload>
/**
 * Model MedicineTransfer
 * 
 */
export type MedicineTransfer = $Result.DefaultSelection<Prisma.$MedicineTransferPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FlockStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  CLOSED: 'CLOSED'
};

export type FlockStatus = (typeof FlockStatus)[keyof typeof FlockStatus]


export const Custtype: {
  Broiler: 'Broiler',
  Color: 'Color'
};

export type Custtype = (typeof Custtype)[keyof typeof Custtype]


export const BranchType: {
  HeadOffice: 'HeadOffice',
  BranchOffice: 'BranchOffice',
  BoguraOffice: 'BoguraOffice'
};

export type BranchType = (typeof BranchType)[keyof typeof BranchType]


export const Stored: {
  FACTORY: 'FACTORY',
  DEPOT: 'DEPOT'
};

export type Stored = (typeof Stored)[keyof typeof Stored]


export const DeliveryStatus: {
  RETURN: 'RETURN',
  TRANSFER: 'TRANSFER',
  DELIVER: 'DELIVER'
};

export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]

}

export type FlockStatus = $Enums.FlockStatus

export const FlockStatus: typeof $Enums.FlockStatus

export type Custtype = $Enums.Custtype

export const Custtype: typeof $Enums.Custtype

export type BranchType = $Enums.BranchType

export const BranchType: typeof $Enums.BranchType

export type Stored = $Enums.Stored

export const Stored: typeof $Enums.Stored

export type DeliveryStatus = $Enums.DeliveryStatus

export const DeliveryStatus: typeof $Enums.DeliveryStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.farmer`: Exposes CRUD operations for the **Farmer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Farmers
    * const farmers = await prisma.farmer.findMany()
    * ```
    */
  get farmer(): Prisma.FarmerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branchEmployeeHistory`: Exposes CRUD operations for the **BranchEmployeeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchEmployeeHistories
    * const branchEmployeeHistories = await prisma.branchEmployeeHistory.findMany()
    * ```
    */
  get branchEmployeeHistory(): Prisma.BranchEmployeeHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flock`: Exposes CRUD operations for the **Flock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flocks
    * const flocks = await prisma.flock.findMany()
    * ```
    */
  get flock(): Prisma.FlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flockReport`: Exposes CRUD operations for the **FlockReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlockReports
    * const flockReports = await prisma.flockReport.findMany()
    * ```
    */
  get flockReport(): Prisma.FlockReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedNameCategory`: Exposes CRUD operations for the **FeedNameCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedNameCategories
    * const feedNameCategories = await prisma.feedNameCategory.findMany()
    * ```
    */
  get feedNameCategory(): Prisma.FeedNameCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feed`: Exposes CRUD operations for the **Feed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feeds
    * const feeds = await prisma.feed.findMany()
    * ```
    */
  get feed(): Prisma.FeedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allGenericMedicin`: Exposes CRUD operations for the **AllGenericMedicin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AllGenericMedicins
    * const allGenericMedicins = await prisma.allGenericMedicin.findMany()
    * ```
    */
  get allGenericMedicin(): Prisma.AllGenericMedicinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineNameAdd`: Exposes CRUD operations for the **MedicineNameAdd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineNameAdds
    * const medicineNameAdds = await prisma.medicineNameAdd.findMany()
    * ```
    */
  get medicineNameAdd(): Prisma.MedicineNameAddDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicinePurchess`: Exposes CRUD operations for the **MedicinePurchess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicinePurchesses
    * const medicinePurchesses = await prisma.medicinePurchess.findMany()
    * ```
    */
  get medicinePurchess(): Prisma.MedicinePurchessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineStock`: Exposes CRUD operations for the **MedicineStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineStocks
    * const medicineStocks = await prisma.medicineStock.findMany()
    * ```
    */
  get medicineStock(): Prisma.MedicineStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellMedicine`: Exposes CRUD operations for the **SellMedicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellMedicines
    * const sellMedicines = await prisma.sellMedicine.findMany()
    * ```
    */
  get sellMedicine(): Prisma.SellMedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineTransfer`: Exposes CRUD operations for the **MedicineTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineTransfers
    * const medicineTransfers = await prisma.medicineTransfer.findMany()
    * ```
    */
  get medicineTransfer(): Prisma.MedicineTransferDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    Farmer: 'Farmer',
    Address: 'Address',
    BranchEmployeeHistory: 'BranchEmployeeHistory',
    Employee: 'Employee',
    Flock: 'Flock',
    FlockReport: 'FlockReport',
    FeedNameCategory: 'FeedNameCategory',
    Feed: 'Feed',
    AllGenericMedicin: 'AllGenericMedicin',
    MedicineNameAdd: 'MedicineNameAdd',
    MedicinePurchess: 'MedicinePurchess',
    MedicineStock: 'MedicineStock',
    SellMedicine: 'SellMedicine',
    MedicineTransfer: 'MedicineTransfer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "branch" | "farmer" | "address" | "branchEmployeeHistory" | "employee" | "flock" | "flockReport" | "feedNameCategory" | "feed" | "allGenericMedicin" | "medicineNameAdd" | "medicinePurchess" | "medicineStock" | "sellMedicine" | "medicineTransfer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Farmer: {
        payload: Prisma.$FarmerPayload<ExtArgs>
        fields: Prisma.FarmerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FarmerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FarmerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          findFirst: {
            args: Prisma.FarmerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FarmerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          findMany: {
            args: Prisma.FarmerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>[]
          }
          create: {
            args: Prisma.FarmerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          createMany: {
            args: Prisma.FarmerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FarmerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>[]
          }
          delete: {
            args: Prisma.FarmerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          update: {
            args: Prisma.FarmerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          deleteMany: {
            args: Prisma.FarmerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FarmerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FarmerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>[]
          }
          upsert: {
            args: Prisma.FarmerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FarmerPayload>
          }
          aggregate: {
            args: Prisma.FarmerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFarmer>
          }
          groupBy: {
            args: Prisma.FarmerGroupByArgs<ExtArgs>
            result: $Utils.Optional<FarmerGroupByOutputType>[]
          }
          count: {
            args: Prisma.FarmerCountArgs<ExtArgs>
            result: $Utils.Optional<FarmerCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      BranchEmployeeHistory: {
        payload: Prisma.$BranchEmployeeHistoryPayload<ExtArgs>
        fields: Prisma.BranchEmployeeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchEmployeeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchEmployeeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          findFirst: {
            args: Prisma.BranchEmployeeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchEmployeeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          findMany: {
            args: Prisma.BranchEmployeeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>[]
          }
          create: {
            args: Prisma.BranchEmployeeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          createMany: {
            args: Prisma.BranchEmployeeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchEmployeeHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>[]
          }
          delete: {
            args: Prisma.BranchEmployeeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          update: {
            args: Prisma.BranchEmployeeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BranchEmployeeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchEmployeeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchEmployeeHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>[]
          }
          upsert: {
            args: Prisma.BranchEmployeeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchEmployeeHistoryPayload>
          }
          aggregate: {
            args: Prisma.BranchEmployeeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchEmployeeHistory>
          }
          groupBy: {
            args: Prisma.BranchEmployeeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchEmployeeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchEmployeeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<BranchEmployeeHistoryCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Flock: {
        payload: Prisma.$FlockPayload<ExtArgs>
        fields: Prisma.FlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          findFirst: {
            args: Prisma.FlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          findMany: {
            args: Prisma.FlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>[]
          }
          create: {
            args: Prisma.FlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          createMany: {
            args: Prisma.FlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>[]
          }
          delete: {
            args: Prisma.FlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          update: {
            args: Prisma.FlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          deleteMany: {
            args: Prisma.FlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>[]
          }
          upsert: {
            args: Prisma.FlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockPayload>
          }
          aggregate: {
            args: Prisma.FlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlock>
          }
          groupBy: {
            args: Prisma.FlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlockCountArgs<ExtArgs>
            result: $Utils.Optional<FlockCountAggregateOutputType> | number
          }
        }
      }
      FlockReport: {
        payload: Prisma.$FlockReportPayload<ExtArgs>
        fields: Prisma.FlockReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlockReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlockReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          findFirst: {
            args: Prisma.FlockReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlockReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          findMany: {
            args: Prisma.FlockReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>[]
          }
          create: {
            args: Prisma.FlockReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          createMany: {
            args: Prisma.FlockReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlockReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>[]
          }
          delete: {
            args: Prisma.FlockReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          update: {
            args: Prisma.FlockReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          deleteMany: {
            args: Prisma.FlockReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlockReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlockReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>[]
          }
          upsert: {
            args: Prisma.FlockReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlockReportPayload>
          }
          aggregate: {
            args: Prisma.FlockReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlockReport>
          }
          groupBy: {
            args: Prisma.FlockReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlockReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlockReportCountArgs<ExtArgs>
            result: $Utils.Optional<FlockReportCountAggregateOutputType> | number
          }
        }
      }
      FeedNameCategory: {
        payload: Prisma.$FeedNameCategoryPayload<ExtArgs>
        fields: Prisma.FeedNameCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedNameCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedNameCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          findFirst: {
            args: Prisma.FeedNameCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedNameCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          findMany: {
            args: Prisma.FeedNameCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>[]
          }
          create: {
            args: Prisma.FeedNameCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          createMany: {
            args: Prisma.FeedNameCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedNameCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>[]
          }
          delete: {
            args: Prisma.FeedNameCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          update: {
            args: Prisma.FeedNameCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FeedNameCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedNameCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedNameCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>[]
          }
          upsert: {
            args: Prisma.FeedNameCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedNameCategoryPayload>
          }
          aggregate: {
            args: Prisma.FeedNameCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedNameCategory>
          }
          groupBy: {
            args: Prisma.FeedNameCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedNameCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedNameCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FeedNameCategoryCountAggregateOutputType> | number
          }
        }
      }
      Feed: {
        payload: Prisma.$FeedPayload<ExtArgs>
        fields: Prisma.FeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          findFirst: {
            args: Prisma.FeedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          findMany: {
            args: Prisma.FeedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>[]
          }
          create: {
            args: Prisma.FeedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          createMany: {
            args: Prisma.FeedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>[]
          }
          delete: {
            args: Prisma.FeedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          update: {
            args: Prisma.FeedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          deleteMany: {
            args: Prisma.FeedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>[]
          }
          upsert: {
            args: Prisma.FeedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPayload>
          }
          aggregate: {
            args: Prisma.FeedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeed>
          }
          groupBy: {
            args: Prisma.FeedGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedCountArgs<ExtArgs>
            result: $Utils.Optional<FeedCountAggregateOutputType> | number
          }
        }
      }
      AllGenericMedicin: {
        payload: Prisma.$AllGenericMedicinPayload<ExtArgs>
        fields: Prisma.AllGenericMedicinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllGenericMedicinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllGenericMedicinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          findFirst: {
            args: Prisma.AllGenericMedicinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllGenericMedicinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          findMany: {
            args: Prisma.AllGenericMedicinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>[]
          }
          create: {
            args: Prisma.AllGenericMedicinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          createMany: {
            args: Prisma.AllGenericMedicinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllGenericMedicinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>[]
          }
          delete: {
            args: Prisma.AllGenericMedicinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          update: {
            args: Prisma.AllGenericMedicinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          deleteMany: {
            args: Prisma.AllGenericMedicinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllGenericMedicinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllGenericMedicinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>[]
          }
          upsert: {
            args: Prisma.AllGenericMedicinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllGenericMedicinPayload>
          }
          aggregate: {
            args: Prisma.AllGenericMedicinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllGenericMedicin>
          }
          groupBy: {
            args: Prisma.AllGenericMedicinGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllGenericMedicinGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllGenericMedicinCountArgs<ExtArgs>
            result: $Utils.Optional<AllGenericMedicinCountAggregateOutputType> | number
          }
        }
      }
      MedicineNameAdd: {
        payload: Prisma.$MedicineNameAddPayload<ExtArgs>
        fields: Prisma.MedicineNameAddFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineNameAddFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineNameAddFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          findFirst: {
            args: Prisma.MedicineNameAddFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineNameAddFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          findMany: {
            args: Prisma.MedicineNameAddFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>[]
          }
          create: {
            args: Prisma.MedicineNameAddCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          createMany: {
            args: Prisma.MedicineNameAddCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineNameAddCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>[]
          }
          delete: {
            args: Prisma.MedicineNameAddDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          update: {
            args: Prisma.MedicineNameAddUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          deleteMany: {
            args: Prisma.MedicineNameAddDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineNameAddUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineNameAddUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>[]
          }
          upsert: {
            args: Prisma.MedicineNameAddUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineNameAddPayload>
          }
          aggregate: {
            args: Prisma.MedicineNameAddAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineNameAdd>
          }
          groupBy: {
            args: Prisma.MedicineNameAddGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineNameAddGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineNameAddCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineNameAddCountAggregateOutputType> | number
          }
        }
      }
      MedicinePurchess: {
        payload: Prisma.$MedicinePurchessPayload<ExtArgs>
        fields: Prisma.MedicinePurchessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicinePurchessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicinePurchessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          findFirst: {
            args: Prisma.MedicinePurchessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicinePurchessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          findMany: {
            args: Prisma.MedicinePurchessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>[]
          }
          create: {
            args: Prisma.MedicinePurchessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          createMany: {
            args: Prisma.MedicinePurchessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicinePurchessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>[]
          }
          delete: {
            args: Prisma.MedicinePurchessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          update: {
            args: Prisma.MedicinePurchessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          deleteMany: {
            args: Prisma.MedicinePurchessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicinePurchessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicinePurchessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>[]
          }
          upsert: {
            args: Prisma.MedicinePurchessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePurchessPayload>
          }
          aggregate: {
            args: Prisma.MedicinePurchessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicinePurchess>
          }
          groupBy: {
            args: Prisma.MedicinePurchessGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicinePurchessGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicinePurchessCountArgs<ExtArgs>
            result: $Utils.Optional<MedicinePurchessCountAggregateOutputType> | number
          }
        }
      }
      MedicineStock: {
        payload: Prisma.$MedicineStockPayload<ExtArgs>
        fields: Prisma.MedicineStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          findFirst: {
            args: Prisma.MedicineStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          findMany: {
            args: Prisma.MedicineStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>[]
          }
          create: {
            args: Prisma.MedicineStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          createMany: {
            args: Prisma.MedicineStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>[]
          }
          delete: {
            args: Prisma.MedicineStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          update: {
            args: Prisma.MedicineStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          deleteMany: {
            args: Prisma.MedicineStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>[]
          }
          upsert: {
            args: Prisma.MedicineStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineStockPayload>
          }
          aggregate: {
            args: Prisma.MedicineStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineStock>
          }
          groupBy: {
            args: Prisma.MedicineStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineStockCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineStockCountAggregateOutputType> | number
          }
        }
      }
      SellMedicine: {
        payload: Prisma.$SellMedicinePayload<ExtArgs>
        fields: Prisma.SellMedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellMedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellMedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          findFirst: {
            args: Prisma.SellMedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellMedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          findMany: {
            args: Prisma.SellMedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>[]
          }
          create: {
            args: Prisma.SellMedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          createMany: {
            args: Prisma.SellMedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellMedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>[]
          }
          delete: {
            args: Prisma.SellMedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          update: {
            args: Prisma.SellMedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          deleteMany: {
            args: Prisma.SellMedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellMedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellMedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>[]
          }
          upsert: {
            args: Prisma.SellMedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellMedicinePayload>
          }
          aggregate: {
            args: Prisma.SellMedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellMedicine>
          }
          groupBy: {
            args: Prisma.SellMedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellMedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellMedicineCountArgs<ExtArgs>
            result: $Utils.Optional<SellMedicineCountAggregateOutputType> | number
          }
        }
      }
      MedicineTransfer: {
        payload: Prisma.$MedicineTransferPayload<ExtArgs>
        fields: Prisma.MedicineTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          findFirst: {
            args: Prisma.MedicineTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          findMany: {
            args: Prisma.MedicineTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>[]
          }
          create: {
            args: Prisma.MedicineTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          createMany: {
            args: Prisma.MedicineTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>[]
          }
          delete: {
            args: Prisma.MedicineTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          update: {
            args: Prisma.MedicineTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          deleteMany: {
            args: Prisma.MedicineTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>[]
          }
          upsert: {
            args: Prisma.MedicineTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineTransferPayload>
          }
          aggregate: {
            args: Prisma.MedicineTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineTransfer>
          }
          groupBy: {
            args: Prisma.MedicineTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineTransferCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineTransferCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    branch?: BranchOmit
    farmer?: FarmerOmit
    address?: AddressOmit
    branchEmployeeHistory?: BranchEmployeeHistoryOmit
    employee?: EmployeeOmit
    flock?: FlockOmit
    flockReport?: FlockReportOmit
    feedNameCategory?: FeedNameCategoryOmit
    feed?: FeedOmit
    allGenericMedicin?: AllGenericMedicinOmit
    medicineNameAdd?: MedicineNameAddOmit
    medicinePurchess?: MedicinePurchessOmit
    medicineStock?: MedicineStockOmit
    sellMedicine?: SellMedicineOmit
    medicineTransfer?: MedicineTransferOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    farmer: number
    flocks: number
    feed: number
    medicineStock: number
    medicinePurchess: number
    sellMedicine: number
    medicineTransfer: number
    flockReport: number
    branchEmployeeHistory: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | BranchCountOutputTypeCountFarmerArgs
    flocks?: boolean | BranchCountOutputTypeCountFlocksArgs
    feed?: boolean | BranchCountOutputTypeCountFeedArgs
    medicineStock?: boolean | BranchCountOutputTypeCountMedicineStockArgs
    medicinePurchess?: boolean | BranchCountOutputTypeCountMedicinePurchessArgs
    sellMedicine?: boolean | BranchCountOutputTypeCountSellMedicineArgs
    medicineTransfer?: boolean | BranchCountOutputTypeCountMedicineTransferArgs
    flockReport?: boolean | BranchCountOutputTypeCountFlockReportArgs
    branchEmployeeHistory?: boolean | BranchCountOutputTypeCountBranchEmployeeHistoryArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFarmerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmerWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFeedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMedicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineStockWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMedicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicinePurchessWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellMedicineWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMedicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineTransferWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFlockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockReportWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBranchEmployeeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchEmployeeHistoryWhereInput
  }


  /**
   * Count Type FarmerCountOutputType
   */

  export type FarmerCountOutputType = {
    flocks: number
    sellMedicine: number
    flockReport: number
  }

  export type FarmerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flocks?: boolean | FarmerCountOutputTypeCountFlocksArgs
    sellMedicine?: boolean | FarmerCountOutputTypeCountSellMedicineArgs
    flockReport?: boolean | FarmerCountOutputTypeCountFlockReportArgs
  }

  // Custom InputTypes
  /**
   * FarmerCountOutputType without action
   */
  export type FarmerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FarmerCountOutputType
     */
    select?: FarmerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FarmerCountOutputType without action
   */
  export type FarmerCountOutputTypeCountFlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockWhereInput
  }

  /**
   * FarmerCountOutputType without action
   */
  export type FarmerCountOutputTypeCountSellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellMedicineWhereInput
  }

  /**
   * FarmerCountOutputType without action
   */
  export type FarmerCountOutputTypeCountFlockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockReportWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    flocks: number
    branchEmployeeHistory: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flocks?: boolean | EmployeeCountOutputTypeCountFlocksArgs
    branchEmployeeHistory?: boolean | EmployeeCountOutputTypeCountBranchEmployeeHistoryArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountFlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountBranchEmployeeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchEmployeeHistoryWhereInput
  }


  /**
   * Count Type FlockCountOutputType
   */

  export type FlockCountOutputType = {
    sellMedicine: number
    medicineTransfer: number
    flockReport: number
  }

  export type FlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellMedicine?: boolean | FlockCountOutputTypeCountSellMedicineArgs
    medicineTransfer?: boolean | FlockCountOutputTypeCountMedicineTransferArgs
    flockReport?: boolean | FlockCountOutputTypeCountFlockReportArgs
  }

  // Custom InputTypes
  /**
   * FlockCountOutputType without action
   */
  export type FlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockCountOutputType
     */
    select?: FlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlockCountOutputType without action
   */
  export type FlockCountOutputTypeCountSellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellMedicineWhereInput
  }

  /**
   * FlockCountOutputType without action
   */
  export type FlockCountOutputTypeCountMedicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineTransferWhereInput
  }

  /**
   * FlockCountOutputType without action
   */
  export type FlockCountOutputTypeCountFlockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockReportWhereInput
  }


  /**
   * Count Type FeedNameCategoryCountOutputType
   */

  export type FeedNameCategoryCountOutputType = {
    feeds: number
  }

  export type FeedNameCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeds?: boolean | FeedNameCategoryCountOutputTypeCountFeedsArgs
  }

  // Custom InputTypes
  /**
   * FeedNameCategoryCountOutputType without action
   */
  export type FeedNameCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategoryCountOutputType
     */
    select?: FeedNameCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeedNameCategoryCountOutputType without action
   */
  export type FeedNameCategoryCountOutputTypeCountFeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedWhereInput
  }


  /**
   * Count Type AllGenericMedicinCountOutputType
   */

  export type AllGenericMedicinCountOutputType = {
    medicineNameAdd: number
    medicineStock: number
    medicinePurchess: number
  }

  export type AllGenericMedicinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineNameAdd?: boolean | AllGenericMedicinCountOutputTypeCountMedicineNameAddArgs
    medicineStock?: boolean | AllGenericMedicinCountOutputTypeCountMedicineStockArgs
    medicinePurchess?: boolean | AllGenericMedicinCountOutputTypeCountMedicinePurchessArgs
  }

  // Custom InputTypes
  /**
   * AllGenericMedicinCountOutputType without action
   */
  export type AllGenericMedicinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicinCountOutputType
     */
    select?: AllGenericMedicinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AllGenericMedicinCountOutputType without action
   */
  export type AllGenericMedicinCountOutputTypeCountMedicineNameAddArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineNameAddWhereInput
  }

  /**
   * AllGenericMedicinCountOutputType without action
   */
  export type AllGenericMedicinCountOutputTypeCountMedicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineStockWhereInput
  }

  /**
   * AllGenericMedicinCountOutputType without action
   */
  export type AllGenericMedicinCountOutputTypeCountMedicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicinePurchessWhereInput
  }


  /**
   * Count Type MedicineNameAddCountOutputType
   */

  export type MedicineNameAddCountOutputType = {
    medicineStock: number
    medicinePurchess: number
  }

  export type MedicineNameAddCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineStock?: boolean | MedicineNameAddCountOutputTypeCountMedicineStockArgs
    medicinePurchess?: boolean | MedicineNameAddCountOutputTypeCountMedicinePurchessArgs
  }

  // Custom InputTypes
  /**
   * MedicineNameAddCountOutputType without action
   */
  export type MedicineNameAddCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAddCountOutputType
     */
    select?: MedicineNameAddCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineNameAddCountOutputType without action
   */
  export type MedicineNameAddCountOutputTypeCountMedicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineStockWhereInput
  }

  /**
   * MedicineNameAddCountOutputType without action
   */
  export type MedicineNameAddCountOutputTypeCountMedicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicinePurchessWhereInput
  }


  /**
   * Count Type SellMedicineCountOutputType
   */

  export type SellMedicineCountOutputType = {
    MedicineTransfer: number
  }

  export type SellMedicineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MedicineTransfer?: boolean | SellMedicineCountOutputTypeCountMedicineTransferArgs
  }

  // Custom InputTypes
  /**
   * SellMedicineCountOutputType without action
   */
  export type SellMedicineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicineCountOutputType
     */
    select?: SellMedicineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellMedicineCountOutputType without action
   */
  export type SellMedicineCountOutputTypeCountMedicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineTransferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    locationName: string | null
    type: $Enums.BranchType | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    locationName: string | null
    type: $Enums.BranchType | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    locationName: number
    type: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    locationName?: true
    type?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    locationName?: true
    type?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    locationName?: true
    type?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    type?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | Branch$farmerArgs<ExtArgs>
    flocks?: boolean | Branch$flocksArgs<ExtArgs>
    feed?: boolean | Branch$feedArgs<ExtArgs>
    medicineStock?: boolean | Branch$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | Branch$medicinePurchessArgs<ExtArgs>
    sellMedicine?: boolean | Branch$sellMedicineArgs<ExtArgs>
    medicineTransfer?: boolean | Branch$medicineTransferArgs<ExtArgs>
    flockReport?: boolean | Branch$flockReportArgs<ExtArgs>
    branchEmployeeHistory?: boolean | Branch$branchEmployeeHistoryArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    type?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    type?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    locationName?: boolean
    type?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationName" | "type" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | Branch$farmerArgs<ExtArgs>
    flocks?: boolean | Branch$flocksArgs<ExtArgs>
    feed?: boolean | Branch$feedArgs<ExtArgs>
    medicineStock?: boolean | Branch$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | Branch$medicinePurchessArgs<ExtArgs>
    sellMedicine?: boolean | Branch$sellMedicineArgs<ExtArgs>
    medicineTransfer?: boolean | Branch$medicineTransferArgs<ExtArgs>
    flockReport?: boolean | Branch$flockReportArgs<ExtArgs>
    branchEmployeeHistory?: boolean | Branch$branchEmployeeHistoryArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      farmer: Prisma.$FarmerPayload<ExtArgs>[]
      flocks: Prisma.$FlockPayload<ExtArgs>[]
      feed: Prisma.$FeedPayload<ExtArgs>[]
      medicineStock: Prisma.$MedicineStockPayload<ExtArgs>[]
      medicinePurchess: Prisma.$MedicinePurchessPayload<ExtArgs>[]
      sellMedicine: Prisma.$SellMedicinePayload<ExtArgs>[]
      medicineTransfer: Prisma.$MedicineTransferPayload<ExtArgs>[]
      flockReport: Prisma.$FlockReportPayload<ExtArgs>[]
      branchEmployeeHistory: Prisma.$BranchEmployeeHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationName: string
      type: $Enums.BranchType
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmer<T extends Branch$farmerArgs<ExtArgs> = {}>(args?: Subset<T, Branch$farmerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flocks<T extends Branch$flocksArgs<ExtArgs> = {}>(args?: Subset<T, Branch$flocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feed<T extends Branch$feedArgs<ExtArgs> = {}>(args?: Subset<T, Branch$feedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicineStock<T extends Branch$medicineStockArgs<ExtArgs> = {}>(args?: Subset<T, Branch$medicineStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicinePurchess<T extends Branch$medicinePurchessArgs<ExtArgs> = {}>(args?: Subset<T, Branch$medicinePurchessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellMedicine<T extends Branch$sellMedicineArgs<ExtArgs> = {}>(args?: Subset<T, Branch$sellMedicineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicineTransfer<T extends Branch$medicineTransferArgs<ExtArgs> = {}>(args?: Subset<T, Branch$medicineTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flockReport<T extends Branch$flockReportArgs<ExtArgs> = {}>(args?: Subset<T, Branch$flockReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branchEmployeeHistory<T extends Branch$branchEmployeeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Branch$branchEmployeeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly locationName: FieldRef<"Branch", 'String'>
    readonly type: FieldRef<"Branch", 'BranchType'>
    readonly branchCode: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.farmer
   */
  export type Branch$farmerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    where?: FarmerWhereInput
    orderBy?: FarmerOrderByWithRelationInput | FarmerOrderByWithRelationInput[]
    cursor?: FarmerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FarmerScalarFieldEnum | FarmerScalarFieldEnum[]
  }

  /**
   * Branch.flocks
   */
  export type Branch$flocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    where?: FlockWhereInput
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    cursor?: FlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Branch.feed
   */
  export type Branch$feedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    where?: FeedWhereInput
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    cursor?: FeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedScalarFieldEnum | FeedScalarFieldEnum[]
  }

  /**
   * Branch.medicineStock
   */
  export type Branch$medicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    where?: MedicineStockWhereInput
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    cursor?: MedicineStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * Branch.medicinePurchess
   */
  export type Branch$medicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    where?: MedicinePurchessWhereInput
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    cursor?: MedicinePurchessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * Branch.sellMedicine
   */
  export type Branch$sellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    where?: SellMedicineWhereInput
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    cursor?: SellMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * Branch.medicineTransfer
   */
  export type Branch$medicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    where?: MedicineTransferWhereInput
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    cursor?: MedicineTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * Branch.flockReport
   */
  export type Branch$flockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    where?: FlockReportWhereInput
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    cursor?: FlockReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * Branch.branchEmployeeHistory
   */
  export type Branch$branchEmployeeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    where?: BranchEmployeeHistoryWhereInput
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchEmployeeHistoryScalarFieldEnum | BranchEmployeeHistoryScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Farmer
   */

  export type AggregateFarmer = {
    _count: FarmerCountAggregateOutputType | null
    _avg: FarmerAvgAggregateOutputType | null
    _sum: FarmerSumAggregateOutputType | null
    _min: FarmerMinAggregateOutputType | null
    _max: FarmerMaxAggregateOutputType | null
  }

  export type FarmerAvgAggregateOutputType = {
    farmCode: number | null
    totalShed: number | null
    totalSquare: number | null
    capacity: number | null
  }

  export type FarmerSumAggregateOutputType = {
    farmCode: number | null
    totalShed: number | null
    totalSquare: number | null
    capacity: number | null
  }

  export type FarmerMinAggregateOutputType = {
    id: string | null
    branchCode: string | null
    farmCode: number | null
    name: string | null
    farmType: $Enums.Custtype | null
    totalShed: number | null
    totalSquare: number | null
    phoneNumber: string | null
    capacity: number | null
    addressId: string | null
    nid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmerMaxAggregateOutputType = {
    id: string | null
    branchCode: string | null
    farmCode: number | null
    name: string | null
    farmType: $Enums.Custtype | null
    totalShed: number | null
    totalSquare: number | null
    phoneNumber: string | null
    capacity: number | null
    addressId: string | null
    nid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FarmerCountAggregateOutputType = {
    id: number
    branchCode: number
    farmCode: number
    name: number
    farmType: number
    totalShed: number
    totalSquare: number
    phoneNumber: number
    capacity: number
    addressId: number
    nid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FarmerAvgAggregateInputType = {
    farmCode?: true
    totalShed?: true
    totalSquare?: true
    capacity?: true
  }

  export type FarmerSumAggregateInputType = {
    farmCode?: true
    totalShed?: true
    totalSquare?: true
    capacity?: true
  }

  export type FarmerMinAggregateInputType = {
    id?: true
    branchCode?: true
    farmCode?: true
    name?: true
    farmType?: true
    totalShed?: true
    totalSquare?: true
    phoneNumber?: true
    capacity?: true
    addressId?: true
    nid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmerMaxAggregateInputType = {
    id?: true
    branchCode?: true
    farmCode?: true
    name?: true
    farmType?: true
    totalShed?: true
    totalSquare?: true
    phoneNumber?: true
    capacity?: true
    addressId?: true
    nid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FarmerCountAggregateInputType = {
    id?: true
    branchCode?: true
    farmCode?: true
    name?: true
    farmType?: true
    totalShed?: true
    totalSquare?: true
    phoneNumber?: true
    capacity?: true
    addressId?: true
    nid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FarmerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Farmer to aggregate.
     */
    where?: FarmerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmers to fetch.
     */
    orderBy?: FarmerOrderByWithRelationInput | FarmerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FarmerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Farmers
    **/
    _count?: true | FarmerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FarmerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FarmerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FarmerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FarmerMaxAggregateInputType
  }

  export type GetFarmerAggregateType<T extends FarmerAggregateArgs> = {
        [P in keyof T & keyof AggregateFarmer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFarmer[P]>
      : GetScalarType<T[P], AggregateFarmer[P]>
  }




  export type FarmerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FarmerWhereInput
    orderBy?: FarmerOrderByWithAggregationInput | FarmerOrderByWithAggregationInput[]
    by: FarmerScalarFieldEnum[] | FarmerScalarFieldEnum
    having?: FarmerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FarmerCountAggregateInputType | true
    _avg?: FarmerAvgAggregateInputType
    _sum?: FarmerSumAggregateInputType
    _min?: FarmerMinAggregateInputType
    _max?: FarmerMaxAggregateInputType
  }

  export type FarmerGroupByOutputType = {
    id: string
    branchCode: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId: string | null
    nid: string
    createdAt: Date
    updatedAt: Date
    _count: FarmerCountAggregateOutputType | null
    _avg: FarmerAvgAggregateOutputType | null
    _sum: FarmerSumAggregateOutputType | null
    _min: FarmerMinAggregateOutputType | null
    _max: FarmerMaxAggregateOutputType | null
  }

  type GetFarmerGroupByPayload<T extends FarmerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FarmerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FarmerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FarmerGroupByOutputType[P]>
            : GetScalarType<T[P], FarmerGroupByOutputType[P]>
        }
      >
    >


  export type FarmerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    farmCode?: boolean
    name?: boolean
    farmType?: boolean
    totalShed?: boolean
    totalSquare?: boolean
    phoneNumber?: boolean
    capacity?: boolean
    addressId?: boolean
    nid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
    flocks?: boolean | Farmer$flocksArgs<ExtArgs>
    sellMedicine?: boolean | Farmer$sellMedicineArgs<ExtArgs>
    flockReport?: boolean | Farmer$flockReportArgs<ExtArgs>
    _count?: boolean | FarmerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["farmer"]>

  export type FarmerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    farmCode?: boolean
    name?: boolean
    farmType?: boolean
    totalShed?: boolean
    totalSquare?: boolean
    phoneNumber?: boolean
    capacity?: boolean
    addressId?: boolean
    nid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
  }, ExtArgs["result"]["farmer"]>

  export type FarmerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    farmCode?: boolean
    name?: boolean
    farmType?: boolean
    totalShed?: boolean
    totalSquare?: boolean
    phoneNumber?: boolean
    capacity?: boolean
    addressId?: boolean
    nid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
  }, ExtArgs["result"]["farmer"]>

  export type FarmerSelectScalar = {
    id?: boolean
    branchCode?: boolean
    farmCode?: boolean
    name?: boolean
    farmType?: boolean
    totalShed?: boolean
    totalSquare?: boolean
    phoneNumber?: boolean
    capacity?: boolean
    addressId?: boolean
    nid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FarmerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branchCode" | "farmCode" | "name" | "farmType" | "totalShed" | "totalSquare" | "phoneNumber" | "capacity" | "addressId" | "nid" | "createdAt" | "updatedAt", ExtArgs["result"]["farmer"]>
  export type FarmerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
    flocks?: boolean | Farmer$flocksArgs<ExtArgs>
    sellMedicine?: boolean | Farmer$sellMedicineArgs<ExtArgs>
    flockReport?: boolean | Farmer$flockReportArgs<ExtArgs>
    _count?: boolean | FarmerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FarmerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
  }
  export type FarmerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Farmer$branchArgs<ExtArgs>
    address?: boolean | Farmer$addressArgs<ExtArgs>
  }

  export type $FarmerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Farmer"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      address: Prisma.$AddressPayload<ExtArgs> | null
      flocks: Prisma.$FlockPayload<ExtArgs>[]
      sellMedicine: Prisma.$SellMedicinePayload<ExtArgs>[]
      flockReport: Prisma.$FlockReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchCode: string | null
      farmCode: number
      name: string
      farmType: $Enums.Custtype
      totalShed: number
      totalSquare: number
      phoneNumber: string
      capacity: number
      addressId: string | null
      nid: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["farmer"]>
    composites: {}
  }

  type FarmerGetPayload<S extends boolean | null | undefined | FarmerDefaultArgs> = $Result.GetResult<Prisma.$FarmerPayload, S>

  type FarmerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FarmerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FarmerCountAggregateInputType | true
    }

  export interface FarmerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Farmer'], meta: { name: 'Farmer' } }
    /**
     * Find zero or one Farmer that matches the filter.
     * @param {FarmerFindUniqueArgs} args - Arguments to find a Farmer
     * @example
     * // Get one Farmer
     * const farmer = await prisma.farmer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FarmerFindUniqueArgs>(args: SelectSubset<T, FarmerFindUniqueArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Farmer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FarmerFindUniqueOrThrowArgs} args - Arguments to find a Farmer
     * @example
     * // Get one Farmer
     * const farmer = await prisma.farmer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FarmerFindUniqueOrThrowArgs>(args: SelectSubset<T, FarmerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Farmer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerFindFirstArgs} args - Arguments to find a Farmer
     * @example
     * // Get one Farmer
     * const farmer = await prisma.farmer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FarmerFindFirstArgs>(args?: SelectSubset<T, FarmerFindFirstArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Farmer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerFindFirstOrThrowArgs} args - Arguments to find a Farmer
     * @example
     * // Get one Farmer
     * const farmer = await prisma.farmer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FarmerFindFirstOrThrowArgs>(args?: SelectSubset<T, FarmerFindFirstOrThrowArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Farmers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Farmers
     * const farmers = await prisma.farmer.findMany()
     * 
     * // Get first 10 Farmers
     * const farmers = await prisma.farmer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const farmerWithIdOnly = await prisma.farmer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FarmerFindManyArgs>(args?: SelectSubset<T, FarmerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Farmer.
     * @param {FarmerCreateArgs} args - Arguments to create a Farmer.
     * @example
     * // Create one Farmer
     * const Farmer = await prisma.farmer.create({
     *   data: {
     *     // ... data to create a Farmer
     *   }
     * })
     * 
     */
    create<T extends FarmerCreateArgs>(args: SelectSubset<T, FarmerCreateArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Farmers.
     * @param {FarmerCreateManyArgs} args - Arguments to create many Farmers.
     * @example
     * // Create many Farmers
     * const farmer = await prisma.farmer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FarmerCreateManyArgs>(args?: SelectSubset<T, FarmerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Farmers and returns the data saved in the database.
     * @param {FarmerCreateManyAndReturnArgs} args - Arguments to create many Farmers.
     * @example
     * // Create many Farmers
     * const farmer = await prisma.farmer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Farmers and only return the `id`
     * const farmerWithIdOnly = await prisma.farmer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FarmerCreateManyAndReturnArgs>(args?: SelectSubset<T, FarmerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Farmer.
     * @param {FarmerDeleteArgs} args - Arguments to delete one Farmer.
     * @example
     * // Delete one Farmer
     * const Farmer = await prisma.farmer.delete({
     *   where: {
     *     // ... filter to delete one Farmer
     *   }
     * })
     * 
     */
    delete<T extends FarmerDeleteArgs>(args: SelectSubset<T, FarmerDeleteArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Farmer.
     * @param {FarmerUpdateArgs} args - Arguments to update one Farmer.
     * @example
     * // Update one Farmer
     * const farmer = await prisma.farmer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FarmerUpdateArgs>(args: SelectSubset<T, FarmerUpdateArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Farmers.
     * @param {FarmerDeleteManyArgs} args - Arguments to filter Farmers to delete.
     * @example
     * // Delete a few Farmers
     * const { count } = await prisma.farmer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FarmerDeleteManyArgs>(args?: SelectSubset<T, FarmerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Farmers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Farmers
     * const farmer = await prisma.farmer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FarmerUpdateManyArgs>(args: SelectSubset<T, FarmerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Farmers and returns the data updated in the database.
     * @param {FarmerUpdateManyAndReturnArgs} args - Arguments to update many Farmers.
     * @example
     * // Update many Farmers
     * const farmer = await prisma.farmer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Farmers and only return the `id`
     * const farmerWithIdOnly = await prisma.farmer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FarmerUpdateManyAndReturnArgs>(args: SelectSubset<T, FarmerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Farmer.
     * @param {FarmerUpsertArgs} args - Arguments to update or create a Farmer.
     * @example
     * // Update or create a Farmer
     * const farmer = await prisma.farmer.upsert({
     *   create: {
     *     // ... data to create a Farmer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Farmer we want to update
     *   }
     * })
     */
    upsert<T extends FarmerUpsertArgs>(args: SelectSubset<T, FarmerUpsertArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Farmers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerCountArgs} args - Arguments to filter Farmers to count.
     * @example
     * // Count the number of Farmers
     * const count = await prisma.farmer.count({
     *   where: {
     *     // ... the filter for the Farmers we want to count
     *   }
     * })
    **/
    count<T extends FarmerCountArgs>(
      args?: Subset<T, FarmerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FarmerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Farmer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FarmerAggregateArgs>(args: Subset<T, FarmerAggregateArgs>): Prisma.PrismaPromise<GetFarmerAggregateType<T>>

    /**
     * Group by Farmer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FarmerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FarmerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FarmerGroupByArgs['orderBy'] }
        : { orderBy?: FarmerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FarmerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFarmerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Farmer model
   */
  readonly fields: FarmerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Farmer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FarmerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Farmer$branchArgs<ExtArgs> = {}>(args?: Subset<T, Farmer$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    address<T extends Farmer$addressArgs<ExtArgs> = {}>(args?: Subset<T, Farmer$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flocks<T extends Farmer$flocksArgs<ExtArgs> = {}>(args?: Subset<T, Farmer$flocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellMedicine<T extends Farmer$sellMedicineArgs<ExtArgs> = {}>(args?: Subset<T, Farmer$sellMedicineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flockReport<T extends Farmer$flockReportArgs<ExtArgs> = {}>(args?: Subset<T, Farmer$flockReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Farmer model
   */
  interface FarmerFieldRefs {
    readonly id: FieldRef<"Farmer", 'String'>
    readonly branchCode: FieldRef<"Farmer", 'String'>
    readonly farmCode: FieldRef<"Farmer", 'Int'>
    readonly name: FieldRef<"Farmer", 'String'>
    readonly farmType: FieldRef<"Farmer", 'Custtype'>
    readonly totalShed: FieldRef<"Farmer", 'Int'>
    readonly totalSquare: FieldRef<"Farmer", 'Int'>
    readonly phoneNumber: FieldRef<"Farmer", 'String'>
    readonly capacity: FieldRef<"Farmer", 'Int'>
    readonly addressId: FieldRef<"Farmer", 'String'>
    readonly nid: FieldRef<"Farmer", 'String'>
    readonly createdAt: FieldRef<"Farmer", 'DateTime'>
    readonly updatedAt: FieldRef<"Farmer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Farmer findUnique
   */
  export type FarmerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter, which Farmer to fetch.
     */
    where: FarmerWhereUniqueInput
  }

  /**
   * Farmer findUniqueOrThrow
   */
  export type FarmerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter, which Farmer to fetch.
     */
    where: FarmerWhereUniqueInput
  }

  /**
   * Farmer findFirst
   */
  export type FarmerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter, which Farmer to fetch.
     */
    where?: FarmerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmers to fetch.
     */
    orderBy?: FarmerOrderByWithRelationInput | FarmerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Farmers.
     */
    cursor?: FarmerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Farmers.
     */
    distinct?: FarmerScalarFieldEnum | FarmerScalarFieldEnum[]
  }

  /**
   * Farmer findFirstOrThrow
   */
  export type FarmerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter, which Farmer to fetch.
     */
    where?: FarmerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmers to fetch.
     */
    orderBy?: FarmerOrderByWithRelationInput | FarmerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Farmers.
     */
    cursor?: FarmerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Farmers.
     */
    distinct?: FarmerScalarFieldEnum | FarmerScalarFieldEnum[]
  }

  /**
   * Farmer findMany
   */
  export type FarmerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter, which Farmers to fetch.
     */
    where?: FarmerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Farmers to fetch.
     */
    orderBy?: FarmerOrderByWithRelationInput | FarmerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Farmers.
     */
    cursor?: FarmerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Farmers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Farmers.
     */
    skip?: number
    distinct?: FarmerScalarFieldEnum | FarmerScalarFieldEnum[]
  }

  /**
   * Farmer create
   */
  export type FarmerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * The data needed to create a Farmer.
     */
    data: XOR<FarmerCreateInput, FarmerUncheckedCreateInput>
  }

  /**
   * Farmer createMany
   */
  export type FarmerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Farmers.
     */
    data: FarmerCreateManyInput | FarmerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Farmer createManyAndReturn
   */
  export type FarmerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * The data used to create many Farmers.
     */
    data: FarmerCreateManyInput | FarmerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Farmer update
   */
  export type FarmerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * The data needed to update a Farmer.
     */
    data: XOR<FarmerUpdateInput, FarmerUncheckedUpdateInput>
    /**
     * Choose, which Farmer to update.
     */
    where: FarmerWhereUniqueInput
  }

  /**
   * Farmer updateMany
   */
  export type FarmerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Farmers.
     */
    data: XOR<FarmerUpdateManyMutationInput, FarmerUncheckedUpdateManyInput>
    /**
     * Filter which Farmers to update
     */
    where?: FarmerWhereInput
    /**
     * Limit how many Farmers to update.
     */
    limit?: number
  }

  /**
   * Farmer updateManyAndReturn
   */
  export type FarmerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * The data used to update Farmers.
     */
    data: XOR<FarmerUpdateManyMutationInput, FarmerUncheckedUpdateManyInput>
    /**
     * Filter which Farmers to update
     */
    where?: FarmerWhereInput
    /**
     * Limit how many Farmers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Farmer upsert
   */
  export type FarmerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * The filter to search for the Farmer to update in case it exists.
     */
    where: FarmerWhereUniqueInput
    /**
     * In case the Farmer found by the `where` argument doesn't exist, create a new Farmer with this data.
     */
    create: XOR<FarmerCreateInput, FarmerUncheckedCreateInput>
    /**
     * In case the Farmer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FarmerUpdateInput, FarmerUncheckedUpdateInput>
  }

  /**
   * Farmer delete
   */
  export type FarmerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    /**
     * Filter which Farmer to delete.
     */
    where: FarmerWhereUniqueInput
  }

  /**
   * Farmer deleteMany
   */
  export type FarmerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Farmers to delete
     */
    where?: FarmerWhereInput
    /**
     * Limit how many Farmers to delete.
     */
    limit?: number
  }

  /**
   * Farmer.branch
   */
  export type Farmer$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Farmer.address
   */
  export type Farmer$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Farmer.flocks
   */
  export type Farmer$flocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    where?: FlockWhereInput
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    cursor?: FlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Farmer.sellMedicine
   */
  export type Farmer$sellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    where?: SellMedicineWhereInput
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    cursor?: SellMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * Farmer.flockReport
   */
  export type Farmer$flockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    where?: FlockReportWhereInput
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    cursor?: FlockReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * Farmer without action
   */
  export type FarmerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    village: string | null
    post: string | null
    union: string | null
    thana: string | null
    upazila: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    village: string | null
    post: string | null
    union: string | null
    thana: string | null
    upazila: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    village: number
    post: number
    union: number
    thana: number
    upazila: number
    city: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    village?: true
    post?: true
    union?: true
    thana?: true
    upazila?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    village?: true
    post?: true
    union?: true
    thana?: true
    upazila?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    village?: true
    post?: true
    union?: true
    thana?: true
    upazila?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    village: string
    post: string
    union: string | null
    thana: string | null
    upazila: string
    city: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    village?: boolean
    post?: boolean
    union?: boolean
    thana?: boolean
    upazila?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Farmer?: boolean | Address$FarmerArgs<ExtArgs>
    Employee?: boolean | Address$EmployeeArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    village?: boolean
    post?: boolean
    union?: boolean
    thana?: boolean
    upazila?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    village?: boolean
    post?: boolean
    union?: boolean
    thana?: boolean
    upazila?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    village?: boolean
    post?: boolean
    union?: boolean
    thana?: boolean
    upazila?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "village" | "post" | "union" | "thana" | "upazila" | "city" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Farmer?: boolean | Address$FarmerArgs<ExtArgs>
    Employee?: boolean | Address$EmployeeArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      Farmer: Prisma.$FarmerPayload<ExtArgs> | null
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      village: string
      post: string
      union: string | null
      thana: string | null
      upazila: string
      city: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Farmer<T extends Address$FarmerArgs<ExtArgs> = {}>(args?: Subset<T, Address$FarmerArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Employee<T extends Address$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Address$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly village: FieldRef<"Address", 'String'>
    readonly post: FieldRef<"Address", 'String'>
    readonly union: FieldRef<"Address", 'String'>
    readonly thana: FieldRef<"Address", 'String'>
    readonly upazila: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.Farmer
   */
  export type Address$FarmerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Farmer
     */
    select?: FarmerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Farmer
     */
    omit?: FarmerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FarmerInclude<ExtArgs> | null
    where?: FarmerWhereInput
  }

  /**
   * Address.Employee
   */
  export type Address$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model BranchEmployeeHistory
   */

  export type AggregateBranchEmployeeHistory = {
    _count: BranchEmployeeHistoryCountAggregateOutputType | null
    _min: BranchEmployeeHistoryMinAggregateOutputType | null
    _max: BranchEmployeeHistoryMaxAggregateOutputType | null
  }

  export type BranchEmployeeHistoryMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchEmployeeHistoryMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchEmployeeHistoryCountAggregateOutputType = {
    id: number
    employeeId: number
    startDate: number
    endDate: number
    isActive: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchEmployeeHistoryMinAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchEmployeeHistoryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchEmployeeHistoryCountAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchEmployeeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchEmployeeHistory to aggregate.
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchEmployeeHistories to fetch.
     */
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchEmployeeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchEmployeeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchEmployeeHistories
    **/
    _count?: true | BranchEmployeeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchEmployeeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchEmployeeHistoryMaxAggregateInputType
  }

  export type GetBranchEmployeeHistoryAggregateType<T extends BranchEmployeeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchEmployeeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchEmployeeHistory[P]>
      : GetScalarType<T[P], AggregateBranchEmployeeHistory[P]>
  }




  export type BranchEmployeeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchEmployeeHistoryWhereInput
    orderBy?: BranchEmployeeHistoryOrderByWithAggregationInput | BranchEmployeeHistoryOrderByWithAggregationInput[]
    by: BranchEmployeeHistoryScalarFieldEnum[] | BranchEmployeeHistoryScalarFieldEnum
    having?: BranchEmployeeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchEmployeeHistoryCountAggregateInputType | true
    _min?: BranchEmployeeHistoryMinAggregateInputType
    _max?: BranchEmployeeHistoryMaxAggregateInputType
  }

  export type BranchEmployeeHistoryGroupByOutputType = {
    id: string
    employeeId: string
    startDate: Date
    endDate: Date | null
    isActive: boolean
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: BranchEmployeeHistoryCountAggregateOutputType | null
    _min: BranchEmployeeHistoryMinAggregateOutputType | null
    _max: BranchEmployeeHistoryMaxAggregateOutputType | null
  }

  type GetBranchEmployeeHistoryGroupByPayload<T extends BranchEmployeeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchEmployeeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchEmployeeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchEmployeeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BranchEmployeeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BranchEmployeeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchEmployeeHistory"]>

  export type BranchEmployeeHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchEmployeeHistory"]>

  export type BranchEmployeeHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchEmployeeHistory"]>

  export type BranchEmployeeHistorySelectScalar = {
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchEmployeeHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "startDate" | "endDate" | "isActive" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["branchEmployeeHistory"]>
  export type BranchEmployeeHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type BranchEmployeeHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type BranchEmployeeHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $BranchEmployeeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchEmployeeHistory"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      startDate: Date
      endDate: Date | null
      isActive: boolean
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branchEmployeeHistory"]>
    composites: {}
  }

  type BranchEmployeeHistoryGetPayload<S extends boolean | null | undefined | BranchEmployeeHistoryDefaultArgs> = $Result.GetResult<Prisma.$BranchEmployeeHistoryPayload, S>

  type BranchEmployeeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchEmployeeHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchEmployeeHistoryCountAggregateInputType | true
    }

  export interface BranchEmployeeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchEmployeeHistory'], meta: { name: 'BranchEmployeeHistory' } }
    /**
     * Find zero or one BranchEmployeeHistory that matches the filter.
     * @param {BranchEmployeeHistoryFindUniqueArgs} args - Arguments to find a BranchEmployeeHistory
     * @example
     * // Get one BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchEmployeeHistoryFindUniqueArgs>(args: SelectSubset<T, BranchEmployeeHistoryFindUniqueArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BranchEmployeeHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchEmployeeHistoryFindUniqueOrThrowArgs} args - Arguments to find a BranchEmployeeHistory
     * @example
     * // Get one BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchEmployeeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchEmployeeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BranchEmployeeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryFindFirstArgs} args - Arguments to find a BranchEmployeeHistory
     * @example
     * // Get one BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchEmployeeHistoryFindFirstArgs>(args?: SelectSubset<T, BranchEmployeeHistoryFindFirstArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BranchEmployeeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryFindFirstOrThrowArgs} args - Arguments to find a BranchEmployeeHistory
     * @example
     * // Get one BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchEmployeeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchEmployeeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BranchEmployeeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchEmployeeHistories
     * const branchEmployeeHistories = await prisma.branchEmployeeHistory.findMany()
     * 
     * // Get first 10 BranchEmployeeHistories
     * const branchEmployeeHistories = await prisma.branchEmployeeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchEmployeeHistoryWithIdOnly = await prisma.branchEmployeeHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchEmployeeHistoryFindManyArgs>(args?: SelectSubset<T, BranchEmployeeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BranchEmployeeHistory.
     * @param {BranchEmployeeHistoryCreateArgs} args - Arguments to create a BranchEmployeeHistory.
     * @example
     * // Create one BranchEmployeeHistory
     * const BranchEmployeeHistory = await prisma.branchEmployeeHistory.create({
     *   data: {
     *     // ... data to create a BranchEmployeeHistory
     *   }
     * })
     * 
     */
    create<T extends BranchEmployeeHistoryCreateArgs>(args: SelectSubset<T, BranchEmployeeHistoryCreateArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BranchEmployeeHistories.
     * @param {BranchEmployeeHistoryCreateManyArgs} args - Arguments to create many BranchEmployeeHistories.
     * @example
     * // Create many BranchEmployeeHistories
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchEmployeeHistoryCreateManyArgs>(args?: SelectSubset<T, BranchEmployeeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchEmployeeHistories and returns the data saved in the database.
     * @param {BranchEmployeeHistoryCreateManyAndReturnArgs} args - Arguments to create many BranchEmployeeHistories.
     * @example
     * // Create many BranchEmployeeHistories
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchEmployeeHistories and only return the `id`
     * const branchEmployeeHistoryWithIdOnly = await prisma.branchEmployeeHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchEmployeeHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchEmployeeHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BranchEmployeeHistory.
     * @param {BranchEmployeeHistoryDeleteArgs} args - Arguments to delete one BranchEmployeeHistory.
     * @example
     * // Delete one BranchEmployeeHistory
     * const BranchEmployeeHistory = await prisma.branchEmployeeHistory.delete({
     *   where: {
     *     // ... filter to delete one BranchEmployeeHistory
     *   }
     * })
     * 
     */
    delete<T extends BranchEmployeeHistoryDeleteArgs>(args: SelectSubset<T, BranchEmployeeHistoryDeleteArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BranchEmployeeHistory.
     * @param {BranchEmployeeHistoryUpdateArgs} args - Arguments to update one BranchEmployeeHistory.
     * @example
     * // Update one BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchEmployeeHistoryUpdateArgs>(args: SelectSubset<T, BranchEmployeeHistoryUpdateArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BranchEmployeeHistories.
     * @param {BranchEmployeeHistoryDeleteManyArgs} args - Arguments to filter BranchEmployeeHistories to delete.
     * @example
     * // Delete a few BranchEmployeeHistories
     * const { count } = await prisma.branchEmployeeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchEmployeeHistoryDeleteManyArgs>(args?: SelectSubset<T, BranchEmployeeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchEmployeeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchEmployeeHistories
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchEmployeeHistoryUpdateManyArgs>(args: SelectSubset<T, BranchEmployeeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchEmployeeHistories and returns the data updated in the database.
     * @param {BranchEmployeeHistoryUpdateManyAndReturnArgs} args - Arguments to update many BranchEmployeeHistories.
     * @example
     * // Update many BranchEmployeeHistories
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BranchEmployeeHistories and only return the `id`
     * const branchEmployeeHistoryWithIdOnly = await prisma.branchEmployeeHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchEmployeeHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchEmployeeHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BranchEmployeeHistory.
     * @param {BranchEmployeeHistoryUpsertArgs} args - Arguments to update or create a BranchEmployeeHistory.
     * @example
     * // Update or create a BranchEmployeeHistory
     * const branchEmployeeHistory = await prisma.branchEmployeeHistory.upsert({
     *   create: {
     *     // ... data to create a BranchEmployeeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchEmployeeHistory we want to update
     *   }
     * })
     */
    upsert<T extends BranchEmployeeHistoryUpsertArgs>(args: SelectSubset<T, BranchEmployeeHistoryUpsertArgs<ExtArgs>>): Prisma__BranchEmployeeHistoryClient<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BranchEmployeeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryCountArgs} args - Arguments to filter BranchEmployeeHistories to count.
     * @example
     * // Count the number of BranchEmployeeHistories
     * const count = await prisma.branchEmployeeHistory.count({
     *   where: {
     *     // ... the filter for the BranchEmployeeHistories we want to count
     *   }
     * })
    **/
    count<T extends BranchEmployeeHistoryCountArgs>(
      args?: Subset<T, BranchEmployeeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchEmployeeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchEmployeeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchEmployeeHistoryAggregateArgs>(args: Subset<T, BranchEmployeeHistoryAggregateArgs>): Prisma.PrismaPromise<GetBranchEmployeeHistoryAggregateType<T>>

    /**
     * Group by BranchEmployeeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchEmployeeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchEmployeeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchEmployeeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BranchEmployeeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchEmployeeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchEmployeeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchEmployeeHistory model
   */
  readonly fields: BranchEmployeeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchEmployeeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchEmployeeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchEmployeeHistory model
   */
  interface BranchEmployeeHistoryFieldRefs {
    readonly id: FieldRef<"BranchEmployeeHistory", 'String'>
    readonly employeeId: FieldRef<"BranchEmployeeHistory", 'String'>
    readonly startDate: FieldRef<"BranchEmployeeHistory", 'DateTime'>
    readonly endDate: FieldRef<"BranchEmployeeHistory", 'DateTime'>
    readonly isActive: FieldRef<"BranchEmployeeHistory", 'Boolean'>
    readonly branchCode: FieldRef<"BranchEmployeeHistory", 'String'>
    readonly createdAt: FieldRef<"BranchEmployeeHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"BranchEmployeeHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BranchEmployeeHistory findUnique
   */
  export type BranchEmployeeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchEmployeeHistory to fetch.
     */
    where: BranchEmployeeHistoryWhereUniqueInput
  }

  /**
   * BranchEmployeeHistory findUniqueOrThrow
   */
  export type BranchEmployeeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchEmployeeHistory to fetch.
     */
    where: BranchEmployeeHistoryWhereUniqueInput
  }

  /**
   * BranchEmployeeHistory findFirst
   */
  export type BranchEmployeeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchEmployeeHistory to fetch.
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchEmployeeHistories to fetch.
     */
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchEmployeeHistories.
     */
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchEmployeeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchEmployeeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchEmployeeHistories.
     */
    distinct?: BranchEmployeeHistoryScalarFieldEnum | BranchEmployeeHistoryScalarFieldEnum[]
  }

  /**
   * BranchEmployeeHistory findFirstOrThrow
   */
  export type BranchEmployeeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchEmployeeHistory to fetch.
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchEmployeeHistories to fetch.
     */
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchEmployeeHistories.
     */
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchEmployeeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchEmployeeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchEmployeeHistories.
     */
    distinct?: BranchEmployeeHistoryScalarFieldEnum | BranchEmployeeHistoryScalarFieldEnum[]
  }

  /**
   * BranchEmployeeHistory findMany
   */
  export type BranchEmployeeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchEmployeeHistories to fetch.
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchEmployeeHistories to fetch.
     */
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchEmployeeHistories.
     */
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchEmployeeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchEmployeeHistories.
     */
    skip?: number
    distinct?: BranchEmployeeHistoryScalarFieldEnum | BranchEmployeeHistoryScalarFieldEnum[]
  }

  /**
   * BranchEmployeeHistory create
   */
  export type BranchEmployeeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchEmployeeHistory.
     */
    data: XOR<BranchEmployeeHistoryCreateInput, BranchEmployeeHistoryUncheckedCreateInput>
  }

  /**
   * BranchEmployeeHistory createMany
   */
  export type BranchEmployeeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchEmployeeHistories.
     */
    data: BranchEmployeeHistoryCreateManyInput | BranchEmployeeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BranchEmployeeHistory createManyAndReturn
   */
  export type BranchEmployeeHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many BranchEmployeeHistories.
     */
    data: BranchEmployeeHistoryCreateManyInput | BranchEmployeeHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchEmployeeHistory update
   */
  export type BranchEmployeeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchEmployeeHistory.
     */
    data: XOR<BranchEmployeeHistoryUpdateInput, BranchEmployeeHistoryUncheckedUpdateInput>
    /**
     * Choose, which BranchEmployeeHistory to update.
     */
    where: BranchEmployeeHistoryWhereUniqueInput
  }

  /**
   * BranchEmployeeHistory updateMany
   */
  export type BranchEmployeeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchEmployeeHistories.
     */
    data: XOR<BranchEmployeeHistoryUpdateManyMutationInput, BranchEmployeeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BranchEmployeeHistories to update
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * Limit how many BranchEmployeeHistories to update.
     */
    limit?: number
  }

  /**
   * BranchEmployeeHistory updateManyAndReturn
   */
  export type BranchEmployeeHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * The data used to update BranchEmployeeHistories.
     */
    data: XOR<BranchEmployeeHistoryUpdateManyMutationInput, BranchEmployeeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BranchEmployeeHistories to update
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * Limit how many BranchEmployeeHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchEmployeeHistory upsert
   */
  export type BranchEmployeeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchEmployeeHistory to update in case it exists.
     */
    where: BranchEmployeeHistoryWhereUniqueInput
    /**
     * In case the BranchEmployeeHistory found by the `where` argument doesn't exist, create a new BranchEmployeeHistory with this data.
     */
    create: XOR<BranchEmployeeHistoryCreateInput, BranchEmployeeHistoryUncheckedCreateInput>
    /**
     * In case the BranchEmployeeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchEmployeeHistoryUpdateInput, BranchEmployeeHistoryUncheckedUpdateInput>
  }

  /**
   * BranchEmployeeHistory delete
   */
  export type BranchEmployeeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    /**
     * Filter which BranchEmployeeHistory to delete.
     */
    where: BranchEmployeeHistoryWhereUniqueInput
  }

  /**
   * BranchEmployeeHistory deleteMany
   */
  export type BranchEmployeeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchEmployeeHistories to delete
     */
    where?: BranchEmployeeHistoryWhereInput
    /**
     * Limit how many BranchEmployeeHistories to delete.
     */
    limit?: number
  }

  /**
   * BranchEmployeeHistory without action
   */
  export type BranchEmployeeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    name: string | null
    workingLocation: string | null
    designation: string | null
    phoneNumber: string | null
    addressId: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    name: string | null
    workingLocation: string | null
    designation: string | null
    phoneNumber: string | null
    addressId: string | null
    branchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeId: number
    name: number
    workingLocation: number
    designation: number
    phoneNumber: number
    addressId: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    workingLocation?: true
    designation?: true
    phoneNumber?: true
    addressId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    workingLocation?: true
    designation?: true
    phoneNumber?: true
    addressId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeId?: true
    name?: true
    workingLocation?: true
    designation?: true
    phoneNumber?: true
    addressId?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    addressId: string | null
    branchId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    name?: boolean
    workingLocation?: boolean
    designation?: boolean
    phoneNumber?: boolean
    addressId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | Employee$addressArgs<ExtArgs>
    flocks?: boolean | Employee$flocksArgs<ExtArgs>
    branchEmployeeHistory?: boolean | Employee$branchEmployeeHistoryArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    name?: boolean
    workingLocation?: boolean
    designation?: boolean
    phoneNumber?: boolean
    addressId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | Employee$addressArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    name?: boolean
    workingLocation?: boolean
    designation?: boolean
    phoneNumber?: boolean
    addressId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | Employee$addressArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeId?: boolean
    name?: boolean
    workingLocation?: boolean
    designation?: boolean
    phoneNumber?: boolean
    addressId?: boolean
    branchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "name" | "workingLocation" | "designation" | "phoneNumber" | "addressId" | "branchId" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Employee$addressArgs<ExtArgs>
    flocks?: boolean | Employee$flocksArgs<ExtArgs>
    branchEmployeeHistory?: boolean | Employee$branchEmployeeHistoryArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Employee$addressArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Employee$addressArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      flocks: Prisma.$FlockPayload<ExtArgs>[]
      branchEmployeeHistory: Prisma.$BranchEmployeeHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      name: string
      workingLocation: string
      designation: string
      phoneNumber: string
      addressId: string | null
      branchId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends Employee$addressArgs<ExtArgs> = {}>(args?: Subset<T, Employee$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flocks<T extends Employee$flocksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$flocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branchEmployeeHistory<T extends Employee$branchEmployeeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Employee$branchEmployeeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchEmployeeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employeeId: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly workingLocation: FieldRef<"Employee", 'String'>
    readonly designation: FieldRef<"Employee", 'String'>
    readonly phoneNumber: FieldRef<"Employee", 'String'>
    readonly addressId: FieldRef<"Employee", 'String'>
    readonly branchId: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.address
   */
  export type Employee$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Employee.flocks
   */
  export type Employee$flocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    where?: FlockWhereInput
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    cursor?: FlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Employee.branchEmployeeHistory
   */
  export type Employee$branchEmployeeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchEmployeeHistory
     */
    select?: BranchEmployeeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BranchEmployeeHistory
     */
    omit?: BranchEmployeeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchEmployeeHistoryInclude<ExtArgs> | null
    where?: BranchEmployeeHistoryWhereInput
    orderBy?: BranchEmployeeHistoryOrderByWithRelationInput | BranchEmployeeHistoryOrderByWithRelationInput[]
    cursor?: BranchEmployeeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchEmployeeHistoryScalarFieldEnum | BranchEmployeeHistoryScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Flock
   */

  export type AggregateFlock = {
    _count: FlockCountAggregateOutputType | null
    _avg: FlockAvgAggregateOutputType | null
    _sum: FlockSumAggregateOutputType | null
    _min: FlockMinAggregateOutputType | null
    _max: FlockMaxAggregateOutputType | null
  }

  export type FlockAvgAggregateOutputType = {
    flockNumber: number | null
    docQuantity: number | null
    totalFeedKg: number | null
    totalMedicine: number | null
    fcr: number | null
    totalSellBirds: number | null
    mortality: number | null
  }

  export type FlockSumAggregateOutputType = {
    flockNumber: number | null
    docQuantity: number | null
    totalFeedKg: number | null
    totalMedicine: number | null
    fcr: number | null
    totalSellBirds: number | null
    mortality: number | null
  }

  export type FlockMinAggregateOutputType = {
    id: string | null
    flockNumber: number | null
    flockStatus: $Enums.FlockStatus | null
    startDate: Date | null
    endDate: Date | null
    executiveId: string | null
    farmId: string | null
    docName: string | null
    docQuantity: number | null
    approvedBy: string | null
    branchCode: string | null
    totalFeedKg: number | null
    totalMedicine: number | null
    fcr: number | null
    totalSellBirds: number | null
    mortality: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlockMaxAggregateOutputType = {
    id: string | null
    flockNumber: number | null
    flockStatus: $Enums.FlockStatus | null
    startDate: Date | null
    endDate: Date | null
    executiveId: string | null
    farmId: string | null
    docName: string | null
    docQuantity: number | null
    approvedBy: string | null
    branchCode: string | null
    totalFeedKg: number | null
    totalMedicine: number | null
    fcr: number | null
    totalSellBirds: number | null
    mortality: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlockCountAggregateOutputType = {
    id: number
    flockNumber: number
    flockStatus: number
    startDate: number
    endDate: number
    executiveId: number
    farmId: number
    docName: number
    docQuantity: number
    approvedBy: number
    branchCode: number
    totalFeedKg: number
    totalMedicine: number
    fcr: number
    totalSellBirds: number
    mortality: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlockAvgAggregateInputType = {
    flockNumber?: true
    docQuantity?: true
    totalFeedKg?: true
    totalMedicine?: true
    fcr?: true
    totalSellBirds?: true
    mortality?: true
  }

  export type FlockSumAggregateInputType = {
    flockNumber?: true
    docQuantity?: true
    totalFeedKg?: true
    totalMedicine?: true
    fcr?: true
    totalSellBirds?: true
    mortality?: true
  }

  export type FlockMinAggregateInputType = {
    id?: true
    flockNumber?: true
    flockStatus?: true
    startDate?: true
    endDate?: true
    executiveId?: true
    farmId?: true
    docName?: true
    docQuantity?: true
    approvedBy?: true
    branchCode?: true
    totalFeedKg?: true
    totalMedicine?: true
    fcr?: true
    totalSellBirds?: true
    mortality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlockMaxAggregateInputType = {
    id?: true
    flockNumber?: true
    flockStatus?: true
    startDate?: true
    endDate?: true
    executiveId?: true
    farmId?: true
    docName?: true
    docQuantity?: true
    approvedBy?: true
    branchCode?: true
    totalFeedKg?: true
    totalMedicine?: true
    fcr?: true
    totalSellBirds?: true
    mortality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlockCountAggregateInputType = {
    id?: true
    flockNumber?: true
    flockStatus?: true
    startDate?: true
    endDate?: true
    executiveId?: true
    farmId?: true
    docName?: true
    docQuantity?: true
    approvedBy?: true
    branchCode?: true
    totalFeedKg?: true
    totalMedicine?: true
    fcr?: true
    totalSellBirds?: true
    mortality?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flock to aggregate.
     */
    where?: FlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flocks to fetch.
     */
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flocks
    **/
    _count?: true | FlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlockMaxAggregateInputType
  }

  export type GetFlockAggregateType<T extends FlockAggregateArgs> = {
        [P in keyof T & keyof AggregateFlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlock[P]>
      : GetScalarType<T[P], AggregateFlock[P]>
  }




  export type FlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockWhereInput
    orderBy?: FlockOrderByWithAggregationInput | FlockOrderByWithAggregationInput[]
    by: FlockScalarFieldEnum[] | FlockScalarFieldEnum
    having?: FlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlockCountAggregateInputType | true
    _avg?: FlockAvgAggregateInputType
    _sum?: FlockSumAggregateInputType
    _min?: FlockMinAggregateInputType
    _max?: FlockMaxAggregateInputType
  }

  export type FlockGroupByOutputType = {
    id: string
    flockNumber: number
    flockStatus: $Enums.FlockStatus
    startDate: Date
    endDate: Date | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity: number
    approvedBy: string | null
    branchCode: string
    totalFeedKg: number
    totalMedicine: number
    fcr: number
    totalSellBirds: number
    mortality: number
    createdAt: Date
    updatedAt: Date
    _count: FlockCountAggregateOutputType | null
    _avg: FlockAvgAggregateOutputType | null
    _sum: FlockSumAggregateOutputType | null
    _min: FlockMinAggregateOutputType | null
    _max: FlockMaxAggregateOutputType | null
  }

  type GetFlockGroupByPayload<T extends FlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlockGroupByOutputType[P]>
            : GetScalarType<T[P], FlockGroupByOutputType[P]>
        }
      >
    >


  export type FlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flockNumber?: boolean
    flockStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    executiveId?: boolean
    farmId?: boolean
    docName?: boolean
    docQuantity?: boolean
    approvedBy?: boolean
    branchCode?: boolean
    totalFeedKg?: boolean
    totalMedicine?: boolean
    fcr?: boolean
    totalSellBirds?: boolean
    mortality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    sellMedicine?: boolean | Flock$sellMedicineArgs<ExtArgs>
    medicineTransfer?: boolean | Flock$medicineTransferArgs<ExtArgs>
    flockReport?: boolean | Flock$flockReportArgs<ExtArgs>
    _count?: boolean | FlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flock"]>

  export type FlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flockNumber?: boolean
    flockStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    executiveId?: boolean
    farmId?: boolean
    docName?: boolean
    docQuantity?: boolean
    approvedBy?: boolean
    branchCode?: boolean
    totalFeedKg?: boolean
    totalMedicine?: boolean
    fcr?: boolean
    totalSellBirds?: boolean
    mortality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flock"]>

  export type FlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flockNumber?: boolean
    flockStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    executiveId?: boolean
    farmId?: boolean
    docName?: boolean
    docQuantity?: boolean
    approvedBy?: boolean
    branchCode?: boolean
    totalFeedKg?: boolean
    totalMedicine?: boolean
    fcr?: boolean
    totalSellBirds?: boolean
    mortality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flock"]>

  export type FlockSelectScalar = {
    id?: boolean
    flockNumber?: boolean
    flockStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    executiveId?: boolean
    farmId?: boolean
    docName?: boolean
    docQuantity?: boolean
    approvedBy?: boolean
    branchCode?: boolean
    totalFeedKg?: boolean
    totalMedicine?: boolean
    fcr?: boolean
    totalSellBirds?: boolean
    mortality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flockNumber" | "flockStatus" | "startDate" | "endDate" | "executiveId" | "farmId" | "docName" | "docQuantity" | "approvedBy" | "branchCode" | "totalFeedKg" | "totalMedicine" | "fcr" | "totalSellBirds" | "mortality" | "createdAt" | "updatedAt", ExtArgs["result"]["flock"]>
  export type FlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    sellMedicine?: boolean | Flock$sellMedicineArgs<ExtArgs>
    medicineTransfer?: boolean | Flock$medicineTransferArgs<ExtArgs>
    flockReport?: boolean | Flock$flockReportArgs<ExtArgs>
    _count?: boolean | FlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type FlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $FlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flock"
    objects: {
      farmer: Prisma.$FarmerPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      sellMedicine: Prisma.$SellMedicinePayload<ExtArgs>[]
      medicineTransfer: Prisma.$MedicineTransferPayload<ExtArgs>[]
      flockReport: Prisma.$FlockReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flockNumber: number
      flockStatus: $Enums.FlockStatus
      startDate: Date
      endDate: Date | null
      executiveId: string
      farmId: string
      docName: string
      docQuantity: number
      approvedBy: string | null
      branchCode: string
      totalFeedKg: number
      totalMedicine: number
      fcr: number
      totalSellBirds: number
      mortality: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flock"]>
    composites: {}
  }

  type FlockGetPayload<S extends boolean | null | undefined | FlockDefaultArgs> = $Result.GetResult<Prisma.$FlockPayload, S>

  type FlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlockCountAggregateInputType | true
    }

  export interface FlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flock'], meta: { name: 'Flock' } }
    /**
     * Find zero or one Flock that matches the filter.
     * @param {FlockFindUniqueArgs} args - Arguments to find a Flock
     * @example
     * // Get one Flock
     * const flock = await prisma.flock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlockFindUniqueArgs>(args: SelectSubset<T, FlockFindUniqueArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlockFindUniqueOrThrowArgs} args - Arguments to find a Flock
     * @example
     * // Get one Flock
     * const flock = await prisma.flock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlockFindUniqueOrThrowArgs>(args: SelectSubset<T, FlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockFindFirstArgs} args - Arguments to find a Flock
     * @example
     * // Get one Flock
     * const flock = await prisma.flock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlockFindFirstArgs>(args?: SelectSubset<T, FlockFindFirstArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockFindFirstOrThrowArgs} args - Arguments to find a Flock
     * @example
     * // Get one Flock
     * const flock = await prisma.flock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlockFindFirstOrThrowArgs>(args?: SelectSubset<T, FlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flocks
     * const flocks = await prisma.flock.findMany()
     * 
     * // Get first 10 Flocks
     * const flocks = await prisma.flock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flockWithIdOnly = await prisma.flock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlockFindManyArgs>(args?: SelectSubset<T, FlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flock.
     * @param {FlockCreateArgs} args - Arguments to create a Flock.
     * @example
     * // Create one Flock
     * const Flock = await prisma.flock.create({
     *   data: {
     *     // ... data to create a Flock
     *   }
     * })
     * 
     */
    create<T extends FlockCreateArgs>(args: SelectSubset<T, FlockCreateArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flocks.
     * @param {FlockCreateManyArgs} args - Arguments to create many Flocks.
     * @example
     * // Create many Flocks
     * const flock = await prisma.flock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlockCreateManyArgs>(args?: SelectSubset<T, FlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flocks and returns the data saved in the database.
     * @param {FlockCreateManyAndReturnArgs} args - Arguments to create many Flocks.
     * @example
     * // Create many Flocks
     * const flock = await prisma.flock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flocks and only return the `id`
     * const flockWithIdOnly = await prisma.flock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlockCreateManyAndReturnArgs>(args?: SelectSubset<T, FlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flock.
     * @param {FlockDeleteArgs} args - Arguments to delete one Flock.
     * @example
     * // Delete one Flock
     * const Flock = await prisma.flock.delete({
     *   where: {
     *     // ... filter to delete one Flock
     *   }
     * })
     * 
     */
    delete<T extends FlockDeleteArgs>(args: SelectSubset<T, FlockDeleteArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flock.
     * @param {FlockUpdateArgs} args - Arguments to update one Flock.
     * @example
     * // Update one Flock
     * const flock = await prisma.flock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlockUpdateArgs>(args: SelectSubset<T, FlockUpdateArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flocks.
     * @param {FlockDeleteManyArgs} args - Arguments to filter Flocks to delete.
     * @example
     * // Delete a few Flocks
     * const { count } = await prisma.flock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlockDeleteManyArgs>(args?: SelectSubset<T, FlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flocks
     * const flock = await prisma.flock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlockUpdateManyArgs>(args: SelectSubset<T, FlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flocks and returns the data updated in the database.
     * @param {FlockUpdateManyAndReturnArgs} args - Arguments to update many Flocks.
     * @example
     * // Update many Flocks
     * const flock = await prisma.flock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flocks and only return the `id`
     * const flockWithIdOnly = await prisma.flock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlockUpdateManyAndReturnArgs>(args: SelectSubset<T, FlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flock.
     * @param {FlockUpsertArgs} args - Arguments to update or create a Flock.
     * @example
     * // Update or create a Flock
     * const flock = await prisma.flock.upsert({
     *   create: {
     *     // ... data to create a Flock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flock we want to update
     *   }
     * })
     */
    upsert<T extends FlockUpsertArgs>(args: SelectSubset<T, FlockUpsertArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockCountArgs} args - Arguments to filter Flocks to count.
     * @example
     * // Count the number of Flocks
     * const count = await prisma.flock.count({
     *   where: {
     *     // ... the filter for the Flocks we want to count
     *   }
     * })
    **/
    count<T extends FlockCountArgs>(
      args?: Subset<T, FlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlockAggregateArgs>(args: Subset<T, FlockAggregateArgs>): Prisma.PrismaPromise<GetFlockAggregateType<T>>

    /**
     * Group by Flock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlockGroupByArgs['orderBy'] }
        : { orderBy?: FlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flock model
   */
  readonly fields: FlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmer<T extends FarmerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmerDefaultArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sellMedicine<T extends Flock$sellMedicineArgs<ExtArgs> = {}>(args?: Subset<T, Flock$sellMedicineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicineTransfer<T extends Flock$medicineTransferArgs<ExtArgs> = {}>(args?: Subset<T, Flock$medicineTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flockReport<T extends Flock$flockReportArgs<ExtArgs> = {}>(args?: Subset<T, Flock$flockReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flock model
   */
  interface FlockFieldRefs {
    readonly id: FieldRef<"Flock", 'String'>
    readonly flockNumber: FieldRef<"Flock", 'Int'>
    readonly flockStatus: FieldRef<"Flock", 'FlockStatus'>
    readonly startDate: FieldRef<"Flock", 'DateTime'>
    readonly endDate: FieldRef<"Flock", 'DateTime'>
    readonly executiveId: FieldRef<"Flock", 'String'>
    readonly farmId: FieldRef<"Flock", 'String'>
    readonly docName: FieldRef<"Flock", 'String'>
    readonly docQuantity: FieldRef<"Flock", 'Int'>
    readonly approvedBy: FieldRef<"Flock", 'String'>
    readonly branchCode: FieldRef<"Flock", 'String'>
    readonly totalFeedKg: FieldRef<"Flock", 'Int'>
    readonly totalMedicine: FieldRef<"Flock", 'Int'>
    readonly fcr: FieldRef<"Flock", 'Float'>
    readonly totalSellBirds: FieldRef<"Flock", 'Int'>
    readonly mortality: FieldRef<"Flock", 'Int'>
    readonly createdAt: FieldRef<"Flock", 'DateTime'>
    readonly updatedAt: FieldRef<"Flock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flock findUnique
   */
  export type FlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter, which Flock to fetch.
     */
    where: FlockWhereUniqueInput
  }

  /**
   * Flock findUniqueOrThrow
   */
  export type FlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter, which Flock to fetch.
     */
    where: FlockWhereUniqueInput
  }

  /**
   * Flock findFirst
   */
  export type FlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter, which Flock to fetch.
     */
    where?: FlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flocks to fetch.
     */
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flocks.
     */
    cursor?: FlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flocks.
     */
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Flock findFirstOrThrow
   */
  export type FlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter, which Flock to fetch.
     */
    where?: FlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flocks to fetch.
     */
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flocks.
     */
    cursor?: FlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flocks.
     */
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Flock findMany
   */
  export type FlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter, which Flocks to fetch.
     */
    where?: FlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flocks to fetch.
     */
    orderBy?: FlockOrderByWithRelationInput | FlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flocks.
     */
    cursor?: FlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flocks.
     */
    skip?: number
    distinct?: FlockScalarFieldEnum | FlockScalarFieldEnum[]
  }

  /**
   * Flock create
   */
  export type FlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Flock.
     */
    data: XOR<FlockCreateInput, FlockUncheckedCreateInput>
  }

  /**
   * Flock createMany
   */
  export type FlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flocks.
     */
    data: FlockCreateManyInput | FlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flock createManyAndReturn
   */
  export type FlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * The data used to create many Flocks.
     */
    data: FlockCreateManyInput | FlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flock update
   */
  export type FlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Flock.
     */
    data: XOR<FlockUpdateInput, FlockUncheckedUpdateInput>
    /**
     * Choose, which Flock to update.
     */
    where: FlockWhereUniqueInput
  }

  /**
   * Flock updateMany
   */
  export type FlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flocks.
     */
    data: XOR<FlockUpdateManyMutationInput, FlockUncheckedUpdateManyInput>
    /**
     * Filter which Flocks to update
     */
    where?: FlockWhereInput
    /**
     * Limit how many Flocks to update.
     */
    limit?: number
  }

  /**
   * Flock updateManyAndReturn
   */
  export type FlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * The data used to update Flocks.
     */
    data: XOR<FlockUpdateManyMutationInput, FlockUncheckedUpdateManyInput>
    /**
     * Filter which Flocks to update
     */
    where?: FlockWhereInput
    /**
     * Limit how many Flocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flock upsert
   */
  export type FlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Flock to update in case it exists.
     */
    where: FlockWhereUniqueInput
    /**
     * In case the Flock found by the `where` argument doesn't exist, create a new Flock with this data.
     */
    create: XOR<FlockCreateInput, FlockUncheckedCreateInput>
    /**
     * In case the Flock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlockUpdateInput, FlockUncheckedUpdateInput>
  }

  /**
   * Flock delete
   */
  export type FlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
    /**
     * Filter which Flock to delete.
     */
    where: FlockWhereUniqueInput
  }

  /**
   * Flock deleteMany
   */
  export type FlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flocks to delete
     */
    where?: FlockWhereInput
    /**
     * Limit how many Flocks to delete.
     */
    limit?: number
  }

  /**
   * Flock.sellMedicine
   */
  export type Flock$sellMedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    where?: SellMedicineWhereInput
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    cursor?: SellMedicineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * Flock.medicineTransfer
   */
  export type Flock$medicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    where?: MedicineTransferWhereInput
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    cursor?: MedicineTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * Flock.flockReport
   */
  export type Flock$flockReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    where?: FlockReportWhereInput
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    cursor?: FlockReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * Flock without action
   */
  export type FlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flock
     */
    select?: FlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flock
     */
    omit?: FlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockInclude<ExtArgs> | null
  }


  /**
   * Model FlockReport
   */

  export type AggregateFlockReport = {
    _count: FlockReportCountAggregateOutputType | null
    _avg: FlockReportAvgAggregateOutputType | null
    _sum: FlockReportSumAggregateOutputType | null
    _min: FlockReportMinAggregateOutputType | null
    _max: FlockReportMaxAggregateOutputType | null
  }

  export type FlockReportAvgAggregateOutputType = {
    housedBirds: number | null
    fcr: number | null
    totalMortality: number | null
    todayMortality: number | null
    todayMortalityPercent: number | null
    totalMortalityPercentage: number | null
    bodyWeight: number | null
    todayWeightGain: number | null
    todayFeedEting: number | null
    averageBodyWight: number | null
    totalFeedEting: number | null
    feedStock: number | null
    birdsStock: number | null
    age: number | null
  }

  export type FlockReportSumAggregateOutputType = {
    housedBirds: number | null
    fcr: number | null
    totalMortality: number | null
    todayMortality: number | null
    todayMortalityPercent: number | null
    totalMortalityPercentage: number | null
    bodyWeight: number | null
    todayWeightGain: number | null
    todayFeedEting: number | null
    averageBodyWight: number | null
    totalFeedEting: number | null
    feedStock: number | null
    birdsStock: number | null
    age: number | null
  }

  export type FlockReportMinAggregateOutputType = {
    id: string | null
    housedBirds: number | null
    fcr: number | null
    executiveId: string | null
    totalMortality: number | null
    todayMortality: number | null
    todayMortalityPercent: number | null
    totalMortalityPercentage: number | null
    bodyWeight: number | null
    todayWeightGain: number | null
    todayFeedEting: number | null
    suggestTosell: boolean | null
    averageBodyWight: number | null
    totalFeedEting: number | null
    feedStock: number | null
    diseases: string | null
    birdsStock: number | null
    condition: string | null
    description: string | null
    executiveName: string | null
    flockNumber: string | null
    age: number | null
    imagesOne: string | null
    imageTwo: string | null
    imageThree: string | null
    visitedDate: Date | null
    locationLink: string | null
    farmId: string | null
    flockId: string | null
    birdsSalesStart: boolean | null
    birdsSalesEnd: boolean | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlockReportMaxAggregateOutputType = {
    id: string | null
    housedBirds: number | null
    fcr: number | null
    executiveId: string | null
    totalMortality: number | null
    todayMortality: number | null
    todayMortalityPercent: number | null
    totalMortalityPercentage: number | null
    bodyWeight: number | null
    todayWeightGain: number | null
    todayFeedEting: number | null
    suggestTosell: boolean | null
    averageBodyWight: number | null
    totalFeedEting: number | null
    feedStock: number | null
    diseases: string | null
    birdsStock: number | null
    condition: string | null
    description: string | null
    executiveName: string | null
    flockNumber: string | null
    age: number | null
    imagesOne: string | null
    imageTwo: string | null
    imageThree: string | null
    visitedDate: Date | null
    locationLink: string | null
    farmId: string | null
    flockId: string | null
    birdsSalesStart: boolean | null
    birdsSalesEnd: boolean | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlockReportCountAggregateOutputType = {
    id: number
    housedBirds: number
    fcr: number
    executiveId: number
    totalMortality: number
    todayMortality: number
    todayMortalityPercent: number
    totalMortalityPercentage: number
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell: number
    averageBodyWight: number
    totalFeedEting: number
    feedStock: number
    diseases: number
    birdsStock: number
    condition: number
    description: number
    executiveName: number
    flockNumber: number
    age: number
    imagesOne: number
    imageTwo: number
    imageThree: number
    visitedDate: number
    locationLink: number
    farmId: number
    flockId: number
    birdsSalesStart: number
    birdsSalesEnd: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlockReportAvgAggregateInputType = {
    housedBirds?: true
    fcr?: true
    totalMortality?: true
    todayMortality?: true
    todayMortalityPercent?: true
    totalMortalityPercentage?: true
    bodyWeight?: true
    todayWeightGain?: true
    todayFeedEting?: true
    averageBodyWight?: true
    totalFeedEting?: true
    feedStock?: true
    birdsStock?: true
    age?: true
  }

  export type FlockReportSumAggregateInputType = {
    housedBirds?: true
    fcr?: true
    totalMortality?: true
    todayMortality?: true
    todayMortalityPercent?: true
    totalMortalityPercentage?: true
    bodyWeight?: true
    todayWeightGain?: true
    todayFeedEting?: true
    averageBodyWight?: true
    totalFeedEting?: true
    feedStock?: true
    birdsStock?: true
    age?: true
  }

  export type FlockReportMinAggregateInputType = {
    id?: true
    housedBirds?: true
    fcr?: true
    executiveId?: true
    totalMortality?: true
    todayMortality?: true
    todayMortalityPercent?: true
    totalMortalityPercentage?: true
    bodyWeight?: true
    todayWeightGain?: true
    todayFeedEting?: true
    suggestTosell?: true
    averageBodyWight?: true
    totalFeedEting?: true
    feedStock?: true
    diseases?: true
    birdsStock?: true
    condition?: true
    description?: true
    executiveName?: true
    flockNumber?: true
    age?: true
    imagesOne?: true
    imageTwo?: true
    imageThree?: true
    visitedDate?: true
    locationLink?: true
    farmId?: true
    flockId?: true
    birdsSalesStart?: true
    birdsSalesEnd?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlockReportMaxAggregateInputType = {
    id?: true
    housedBirds?: true
    fcr?: true
    executiveId?: true
    totalMortality?: true
    todayMortality?: true
    todayMortalityPercent?: true
    totalMortalityPercentage?: true
    bodyWeight?: true
    todayWeightGain?: true
    todayFeedEting?: true
    suggestTosell?: true
    averageBodyWight?: true
    totalFeedEting?: true
    feedStock?: true
    diseases?: true
    birdsStock?: true
    condition?: true
    description?: true
    executiveName?: true
    flockNumber?: true
    age?: true
    imagesOne?: true
    imageTwo?: true
    imageThree?: true
    visitedDate?: true
    locationLink?: true
    farmId?: true
    flockId?: true
    birdsSalesStart?: true
    birdsSalesEnd?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlockReportCountAggregateInputType = {
    id?: true
    housedBirds?: true
    fcr?: true
    executiveId?: true
    totalMortality?: true
    todayMortality?: true
    todayMortalityPercent?: true
    totalMortalityPercentage?: true
    bodyWeight?: true
    todayWeightGain?: true
    todayFeedEting?: true
    suggestTosell?: true
    averageBodyWight?: true
    totalFeedEting?: true
    feedStock?: true
    diseases?: true
    birdsStock?: true
    condition?: true
    description?: true
    executiveName?: true
    flockNumber?: true
    age?: true
    imagesOne?: true
    imageTwo?: true
    imageThree?: true
    visitedDate?: true
    locationLink?: true
    farmId?: true
    flockId?: true
    birdsSalesStart?: true
    birdsSalesEnd?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlockReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlockReport to aggregate.
     */
    where?: FlockReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlockReports to fetch.
     */
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlockReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlockReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlockReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlockReports
    **/
    _count?: true | FlockReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlockReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlockReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlockReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlockReportMaxAggregateInputType
  }

  export type GetFlockReportAggregateType<T extends FlockReportAggregateArgs> = {
        [P in keyof T & keyof AggregateFlockReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlockReport[P]>
      : GetScalarType<T[P], AggregateFlockReport[P]>
  }




  export type FlockReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlockReportWhereInput
    orderBy?: FlockReportOrderByWithAggregationInput | FlockReportOrderByWithAggregationInput[]
    by: FlockReportScalarFieldEnum[] | FlockReportScalarFieldEnum
    having?: FlockReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlockReportCountAggregateInputType | true
    _avg?: FlockReportAvgAggregateInputType
    _sum?: FlockReportSumAggregateInputType
    _min?: FlockReportMinAggregateInputType
    _max?: FlockReportMaxAggregateInputType
  }

  export type FlockReportGroupByOutputType = {
    id: string
    housedBirds: number
    fcr: number | null
    executiveId: string
    totalMortality: number | null
    todayMortality: number
    todayMortalityPercent: number | null
    totalMortalityPercentage: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell: boolean
    averageBodyWight: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age: number | null
    imagesOne: string | null
    imageTwo: string | null
    imageThree: string | null
    visitedDate: Date
    locationLink: string
    farmId: string
    flockId: string
    birdsSalesStart: boolean
    birdsSalesEnd: boolean
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: FlockReportCountAggregateOutputType | null
    _avg: FlockReportAvgAggregateOutputType | null
    _sum: FlockReportSumAggregateOutputType | null
    _min: FlockReportMinAggregateOutputType | null
    _max: FlockReportMaxAggregateOutputType | null
  }

  type GetFlockReportGroupByPayload<T extends FlockReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlockReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlockReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlockReportGroupByOutputType[P]>
            : GetScalarType<T[P], FlockReportGroupByOutputType[P]>
        }
      >
    >


  export type FlockReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    housedBirds?: boolean
    fcr?: boolean
    executiveId?: boolean
    totalMortality?: boolean
    todayMortality?: boolean
    todayMortalityPercent?: boolean
    totalMortalityPercentage?: boolean
    bodyWeight?: boolean
    todayWeightGain?: boolean
    todayFeedEting?: boolean
    suggestTosell?: boolean
    averageBodyWight?: boolean
    totalFeedEting?: boolean
    feedStock?: boolean
    diseases?: boolean
    birdsStock?: boolean
    condition?: boolean
    description?: boolean
    executiveName?: boolean
    flockNumber?: boolean
    age?: boolean
    imagesOne?: boolean
    imageTwo?: boolean
    imageThree?: boolean
    visitedDate?: boolean
    locationLink?: boolean
    farmId?: boolean
    flockId?: boolean
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flockReport"]>

  export type FlockReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    housedBirds?: boolean
    fcr?: boolean
    executiveId?: boolean
    totalMortality?: boolean
    todayMortality?: boolean
    todayMortalityPercent?: boolean
    totalMortalityPercentage?: boolean
    bodyWeight?: boolean
    todayWeightGain?: boolean
    todayFeedEting?: boolean
    suggestTosell?: boolean
    averageBodyWight?: boolean
    totalFeedEting?: boolean
    feedStock?: boolean
    diseases?: boolean
    birdsStock?: boolean
    condition?: boolean
    description?: boolean
    executiveName?: boolean
    flockNumber?: boolean
    age?: boolean
    imagesOne?: boolean
    imageTwo?: boolean
    imageThree?: boolean
    visitedDate?: boolean
    locationLink?: boolean
    farmId?: boolean
    flockId?: boolean
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flockReport"]>

  export type FlockReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    housedBirds?: boolean
    fcr?: boolean
    executiveId?: boolean
    totalMortality?: boolean
    todayMortality?: boolean
    todayMortalityPercent?: boolean
    totalMortalityPercentage?: boolean
    bodyWeight?: boolean
    todayWeightGain?: boolean
    todayFeedEting?: boolean
    suggestTosell?: boolean
    averageBodyWight?: boolean
    totalFeedEting?: boolean
    feedStock?: boolean
    diseases?: boolean
    birdsStock?: boolean
    condition?: boolean
    description?: boolean
    executiveName?: boolean
    flockNumber?: boolean
    age?: boolean
    imagesOne?: boolean
    imageTwo?: boolean
    imageThree?: boolean
    visitedDate?: boolean
    locationLink?: boolean
    farmId?: boolean
    flockId?: boolean
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flockReport"]>

  export type FlockReportSelectScalar = {
    id?: boolean
    housedBirds?: boolean
    fcr?: boolean
    executiveId?: boolean
    totalMortality?: boolean
    todayMortality?: boolean
    todayMortalityPercent?: boolean
    totalMortalityPercentage?: boolean
    bodyWeight?: boolean
    todayWeightGain?: boolean
    todayFeedEting?: boolean
    suggestTosell?: boolean
    averageBodyWight?: boolean
    totalFeedEting?: boolean
    feedStock?: boolean
    diseases?: boolean
    birdsStock?: boolean
    condition?: boolean
    description?: boolean
    executiveName?: boolean
    flockNumber?: boolean
    age?: boolean
    imagesOne?: boolean
    imageTwo?: boolean
    imageThree?: boolean
    visitedDate?: boolean
    locationLink?: boolean
    farmId?: boolean
    flockId?: boolean
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlockReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "housedBirds" | "fcr" | "executiveId" | "totalMortality" | "todayMortality" | "todayMortalityPercent" | "totalMortalityPercentage" | "bodyWeight" | "todayWeightGain" | "todayFeedEting" | "suggestTosell" | "averageBodyWight" | "totalFeedEting" | "feedStock" | "diseases" | "birdsStock" | "condition" | "description" | "executiveName" | "flockNumber" | "age" | "imagesOne" | "imageTwo" | "imageThree" | "visitedDate" | "locationLink" | "farmId" | "flockId" | "birdsSalesStart" | "birdsSalesEnd" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["flockReport"]>
  export type FlockReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }
  export type FlockReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }
  export type FlockReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }

  export type $FlockReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlockReport"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      flock: Prisma.$FlockPayload<ExtArgs>
      farmer: Prisma.$FarmerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      housedBirds: number
      fcr: number | null
      executiveId: string
      totalMortality: number | null
      todayMortality: number
      todayMortalityPercent: number | null
      totalMortalityPercentage: number | null
      bodyWeight: number
      todayWeightGain: number
      todayFeedEting: number
      suggestTosell: boolean
      averageBodyWight: number | null
      totalFeedEting: number
      feedStock: number
      diseases: string
      birdsStock: number
      condition: string
      description: string
      executiveName: string
      flockNumber: string
      age: number | null
      imagesOne: string | null
      imageTwo: string | null
      imageThree: string | null
      visitedDate: Date
      locationLink: string
      farmId: string
      flockId: string
      birdsSalesStart: boolean
      birdsSalesEnd: boolean
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flockReport"]>
    composites: {}
  }

  type FlockReportGetPayload<S extends boolean | null | undefined | FlockReportDefaultArgs> = $Result.GetResult<Prisma.$FlockReportPayload, S>

  type FlockReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlockReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlockReportCountAggregateInputType | true
    }

  export interface FlockReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlockReport'], meta: { name: 'FlockReport' } }
    /**
     * Find zero or one FlockReport that matches the filter.
     * @param {FlockReportFindUniqueArgs} args - Arguments to find a FlockReport
     * @example
     * // Get one FlockReport
     * const flockReport = await prisma.flockReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlockReportFindUniqueArgs>(args: SelectSubset<T, FlockReportFindUniqueArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlockReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlockReportFindUniqueOrThrowArgs} args - Arguments to find a FlockReport
     * @example
     * // Get one FlockReport
     * const flockReport = await prisma.flockReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlockReportFindUniqueOrThrowArgs>(args: SelectSubset<T, FlockReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlockReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportFindFirstArgs} args - Arguments to find a FlockReport
     * @example
     * // Get one FlockReport
     * const flockReport = await prisma.flockReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlockReportFindFirstArgs>(args?: SelectSubset<T, FlockReportFindFirstArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlockReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportFindFirstOrThrowArgs} args - Arguments to find a FlockReport
     * @example
     * // Get one FlockReport
     * const flockReport = await prisma.flockReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlockReportFindFirstOrThrowArgs>(args?: SelectSubset<T, FlockReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlockReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlockReports
     * const flockReports = await prisma.flockReport.findMany()
     * 
     * // Get first 10 FlockReports
     * const flockReports = await prisma.flockReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flockReportWithIdOnly = await prisma.flockReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlockReportFindManyArgs>(args?: SelectSubset<T, FlockReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlockReport.
     * @param {FlockReportCreateArgs} args - Arguments to create a FlockReport.
     * @example
     * // Create one FlockReport
     * const FlockReport = await prisma.flockReport.create({
     *   data: {
     *     // ... data to create a FlockReport
     *   }
     * })
     * 
     */
    create<T extends FlockReportCreateArgs>(args: SelectSubset<T, FlockReportCreateArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlockReports.
     * @param {FlockReportCreateManyArgs} args - Arguments to create many FlockReports.
     * @example
     * // Create many FlockReports
     * const flockReport = await prisma.flockReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlockReportCreateManyArgs>(args?: SelectSubset<T, FlockReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlockReports and returns the data saved in the database.
     * @param {FlockReportCreateManyAndReturnArgs} args - Arguments to create many FlockReports.
     * @example
     * // Create many FlockReports
     * const flockReport = await prisma.flockReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlockReports and only return the `id`
     * const flockReportWithIdOnly = await prisma.flockReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlockReportCreateManyAndReturnArgs>(args?: SelectSubset<T, FlockReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlockReport.
     * @param {FlockReportDeleteArgs} args - Arguments to delete one FlockReport.
     * @example
     * // Delete one FlockReport
     * const FlockReport = await prisma.flockReport.delete({
     *   where: {
     *     // ... filter to delete one FlockReport
     *   }
     * })
     * 
     */
    delete<T extends FlockReportDeleteArgs>(args: SelectSubset<T, FlockReportDeleteArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlockReport.
     * @param {FlockReportUpdateArgs} args - Arguments to update one FlockReport.
     * @example
     * // Update one FlockReport
     * const flockReport = await prisma.flockReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlockReportUpdateArgs>(args: SelectSubset<T, FlockReportUpdateArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlockReports.
     * @param {FlockReportDeleteManyArgs} args - Arguments to filter FlockReports to delete.
     * @example
     * // Delete a few FlockReports
     * const { count } = await prisma.flockReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlockReportDeleteManyArgs>(args?: SelectSubset<T, FlockReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlockReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlockReports
     * const flockReport = await prisma.flockReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlockReportUpdateManyArgs>(args: SelectSubset<T, FlockReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlockReports and returns the data updated in the database.
     * @param {FlockReportUpdateManyAndReturnArgs} args - Arguments to update many FlockReports.
     * @example
     * // Update many FlockReports
     * const flockReport = await prisma.flockReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlockReports and only return the `id`
     * const flockReportWithIdOnly = await prisma.flockReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlockReportUpdateManyAndReturnArgs>(args: SelectSubset<T, FlockReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlockReport.
     * @param {FlockReportUpsertArgs} args - Arguments to update or create a FlockReport.
     * @example
     * // Update or create a FlockReport
     * const flockReport = await prisma.flockReport.upsert({
     *   create: {
     *     // ... data to create a FlockReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlockReport we want to update
     *   }
     * })
     */
    upsert<T extends FlockReportUpsertArgs>(args: SelectSubset<T, FlockReportUpsertArgs<ExtArgs>>): Prisma__FlockReportClient<$Result.GetResult<Prisma.$FlockReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlockReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportCountArgs} args - Arguments to filter FlockReports to count.
     * @example
     * // Count the number of FlockReports
     * const count = await prisma.flockReport.count({
     *   where: {
     *     // ... the filter for the FlockReports we want to count
     *   }
     * })
    **/
    count<T extends FlockReportCountArgs>(
      args?: Subset<T, FlockReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlockReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlockReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlockReportAggregateArgs>(args: Subset<T, FlockReportAggregateArgs>): Prisma.PrismaPromise<GetFlockReportAggregateType<T>>

    /**
     * Group by FlockReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlockReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlockReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlockReportGroupByArgs['orderBy'] }
        : { orderBy?: FlockReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlockReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlockReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlockReport model
   */
  readonly fields: FlockReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlockReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlockReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flock<T extends FlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlockDefaultArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    farmer<T extends FarmerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmerDefaultArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlockReport model
   */
  interface FlockReportFieldRefs {
    readonly id: FieldRef<"FlockReport", 'String'>
    readonly housedBirds: FieldRef<"FlockReport", 'Int'>
    readonly fcr: FieldRef<"FlockReport", 'Float'>
    readonly executiveId: FieldRef<"FlockReport", 'String'>
    readonly totalMortality: FieldRef<"FlockReport", 'Int'>
    readonly todayMortality: FieldRef<"FlockReport", 'Int'>
    readonly todayMortalityPercent: FieldRef<"FlockReport", 'Float'>
    readonly totalMortalityPercentage: FieldRef<"FlockReport", 'Float'>
    readonly bodyWeight: FieldRef<"FlockReport", 'Float'>
    readonly todayWeightGain: FieldRef<"FlockReport", 'Int'>
    readonly todayFeedEting: FieldRef<"FlockReport", 'Int'>
    readonly suggestTosell: FieldRef<"FlockReport", 'Boolean'>
    readonly averageBodyWight: FieldRef<"FlockReport", 'Float'>
    readonly totalFeedEting: FieldRef<"FlockReport", 'Int'>
    readonly feedStock: FieldRef<"FlockReport", 'Int'>
    readonly diseases: FieldRef<"FlockReport", 'String'>
    readonly birdsStock: FieldRef<"FlockReport", 'Int'>
    readonly condition: FieldRef<"FlockReport", 'String'>
    readonly description: FieldRef<"FlockReport", 'String'>
    readonly executiveName: FieldRef<"FlockReport", 'String'>
    readonly flockNumber: FieldRef<"FlockReport", 'String'>
    readonly age: FieldRef<"FlockReport", 'Int'>
    readonly imagesOne: FieldRef<"FlockReport", 'String'>
    readonly imageTwo: FieldRef<"FlockReport", 'String'>
    readonly imageThree: FieldRef<"FlockReport", 'String'>
    readonly visitedDate: FieldRef<"FlockReport", 'DateTime'>
    readonly locationLink: FieldRef<"FlockReport", 'String'>
    readonly farmId: FieldRef<"FlockReport", 'String'>
    readonly flockId: FieldRef<"FlockReport", 'String'>
    readonly birdsSalesStart: FieldRef<"FlockReport", 'Boolean'>
    readonly birdsSalesEnd: FieldRef<"FlockReport", 'Boolean'>
    readonly branchCode: FieldRef<"FlockReport", 'String'>
    readonly createdAt: FieldRef<"FlockReport", 'DateTime'>
    readonly updatedAt: FieldRef<"FlockReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlockReport findUnique
   */
  export type FlockReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter, which FlockReport to fetch.
     */
    where: FlockReportWhereUniqueInput
  }

  /**
   * FlockReport findUniqueOrThrow
   */
  export type FlockReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter, which FlockReport to fetch.
     */
    where: FlockReportWhereUniqueInput
  }

  /**
   * FlockReport findFirst
   */
  export type FlockReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter, which FlockReport to fetch.
     */
    where?: FlockReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlockReports to fetch.
     */
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlockReports.
     */
    cursor?: FlockReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlockReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlockReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlockReports.
     */
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * FlockReport findFirstOrThrow
   */
  export type FlockReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter, which FlockReport to fetch.
     */
    where?: FlockReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlockReports to fetch.
     */
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlockReports.
     */
    cursor?: FlockReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlockReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlockReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlockReports.
     */
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * FlockReport findMany
   */
  export type FlockReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter, which FlockReports to fetch.
     */
    where?: FlockReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlockReports to fetch.
     */
    orderBy?: FlockReportOrderByWithRelationInput | FlockReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlockReports.
     */
    cursor?: FlockReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlockReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlockReports.
     */
    skip?: number
    distinct?: FlockReportScalarFieldEnum | FlockReportScalarFieldEnum[]
  }

  /**
   * FlockReport create
   */
  export type FlockReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * The data needed to create a FlockReport.
     */
    data: XOR<FlockReportCreateInput, FlockReportUncheckedCreateInput>
  }

  /**
   * FlockReport createMany
   */
  export type FlockReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlockReports.
     */
    data: FlockReportCreateManyInput | FlockReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlockReport createManyAndReturn
   */
  export type FlockReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * The data used to create many FlockReports.
     */
    data: FlockReportCreateManyInput | FlockReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlockReport update
   */
  export type FlockReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * The data needed to update a FlockReport.
     */
    data: XOR<FlockReportUpdateInput, FlockReportUncheckedUpdateInput>
    /**
     * Choose, which FlockReport to update.
     */
    where: FlockReportWhereUniqueInput
  }

  /**
   * FlockReport updateMany
   */
  export type FlockReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlockReports.
     */
    data: XOR<FlockReportUpdateManyMutationInput, FlockReportUncheckedUpdateManyInput>
    /**
     * Filter which FlockReports to update
     */
    where?: FlockReportWhereInput
    /**
     * Limit how many FlockReports to update.
     */
    limit?: number
  }

  /**
   * FlockReport updateManyAndReturn
   */
  export type FlockReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * The data used to update FlockReports.
     */
    data: XOR<FlockReportUpdateManyMutationInput, FlockReportUncheckedUpdateManyInput>
    /**
     * Filter which FlockReports to update
     */
    where?: FlockReportWhereInput
    /**
     * Limit how many FlockReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlockReport upsert
   */
  export type FlockReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * The filter to search for the FlockReport to update in case it exists.
     */
    where: FlockReportWhereUniqueInput
    /**
     * In case the FlockReport found by the `where` argument doesn't exist, create a new FlockReport with this data.
     */
    create: XOR<FlockReportCreateInput, FlockReportUncheckedCreateInput>
    /**
     * In case the FlockReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlockReportUpdateInput, FlockReportUncheckedUpdateInput>
  }

  /**
   * FlockReport delete
   */
  export type FlockReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
    /**
     * Filter which FlockReport to delete.
     */
    where: FlockReportWhereUniqueInput
  }

  /**
   * FlockReport deleteMany
   */
  export type FlockReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlockReports to delete
     */
    where?: FlockReportWhereInput
    /**
     * Limit how many FlockReports to delete.
     */
    limit?: number
  }

  /**
   * FlockReport without action
   */
  export type FlockReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlockReport
     */
    select?: FlockReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlockReport
     */
    omit?: FlockReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlockReportInclude<ExtArgs> | null
  }


  /**
   * Model FeedNameCategory
   */

  export type AggregateFeedNameCategory = {
    _count: FeedNameCategoryCountAggregateOutputType | null
    _avg: FeedNameCategoryAvgAggregateOutputType | null
    _sum: FeedNameCategorySumAggregateOutputType | null
    _min: FeedNameCategoryMinAggregateOutputType | null
    _max: FeedNameCategoryMaxAggregateOutputType | null
  }

  export type FeedNameCategoryAvgAggregateOutputType = {
    feedCodeNumber: number | null
  }

  export type FeedNameCategorySumAggregateOutputType = {
    feedCodeNumber: number | null
  }

  export type FeedNameCategoryMinAggregateOutputType = {
    id: string | null
    feedName: string | null
    feedCodeNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedNameCategoryMaxAggregateOutputType = {
    id: string | null
    feedName: string | null
    feedCodeNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedNameCategoryCountAggregateOutputType = {
    id: number
    feedName: number
    feedCodeNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedNameCategoryAvgAggregateInputType = {
    feedCodeNumber?: true
  }

  export type FeedNameCategorySumAggregateInputType = {
    feedCodeNumber?: true
  }

  export type FeedNameCategoryMinAggregateInputType = {
    id?: true
    feedName?: true
    feedCodeNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedNameCategoryMaxAggregateInputType = {
    id?: true
    feedName?: true
    feedCodeNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedNameCategoryCountAggregateInputType = {
    id?: true
    feedName?: true
    feedCodeNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedNameCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedNameCategory to aggregate.
     */
    where?: FeedNameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedNameCategories to fetch.
     */
    orderBy?: FeedNameCategoryOrderByWithRelationInput | FeedNameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedNameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedNameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedNameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedNameCategories
    **/
    _count?: true | FeedNameCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedNameCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedNameCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedNameCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedNameCategoryMaxAggregateInputType
  }

  export type GetFeedNameCategoryAggregateType<T extends FeedNameCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedNameCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedNameCategory[P]>
      : GetScalarType<T[P], AggregateFeedNameCategory[P]>
  }




  export type FeedNameCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedNameCategoryWhereInput
    orderBy?: FeedNameCategoryOrderByWithAggregationInput | FeedNameCategoryOrderByWithAggregationInput[]
    by: FeedNameCategoryScalarFieldEnum[] | FeedNameCategoryScalarFieldEnum
    having?: FeedNameCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedNameCategoryCountAggregateInputType | true
    _avg?: FeedNameCategoryAvgAggregateInputType
    _sum?: FeedNameCategorySumAggregateInputType
    _min?: FeedNameCategoryMinAggregateInputType
    _max?: FeedNameCategoryMaxAggregateInputType
  }

  export type FeedNameCategoryGroupByOutputType = {
    id: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date
    updatedAt: Date
    _count: FeedNameCategoryCountAggregateOutputType | null
    _avg: FeedNameCategoryAvgAggregateOutputType | null
    _sum: FeedNameCategorySumAggregateOutputType | null
    _min: FeedNameCategoryMinAggregateOutputType | null
    _max: FeedNameCategoryMaxAggregateOutputType | null
  }

  type GetFeedNameCategoryGroupByPayload<T extends FeedNameCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedNameCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedNameCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedNameCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FeedNameCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FeedNameCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    feedCodeNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feeds?: boolean | FeedNameCategory$feedsArgs<ExtArgs>
    _count?: boolean | FeedNameCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedNameCategory"]>

  export type FeedNameCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    feedCodeNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feedNameCategory"]>

  export type FeedNameCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    feedCodeNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feedNameCategory"]>

  export type FeedNameCategorySelectScalar = {
    id?: boolean
    feedName?: boolean
    feedCodeNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedNameCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feedName" | "feedCodeNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["feedNameCategory"]>
  export type FeedNameCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeds?: boolean | FeedNameCategory$feedsArgs<ExtArgs>
    _count?: boolean | FeedNameCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeedNameCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeedNameCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeedNameCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedNameCategory"
    objects: {
      feeds: Prisma.$FeedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feedName: string
      feedCodeNumber: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedNameCategory"]>
    composites: {}
  }

  type FeedNameCategoryGetPayload<S extends boolean | null | undefined | FeedNameCategoryDefaultArgs> = $Result.GetResult<Prisma.$FeedNameCategoryPayload, S>

  type FeedNameCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedNameCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedNameCategoryCountAggregateInputType | true
    }

  export interface FeedNameCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedNameCategory'], meta: { name: 'FeedNameCategory' } }
    /**
     * Find zero or one FeedNameCategory that matches the filter.
     * @param {FeedNameCategoryFindUniqueArgs} args - Arguments to find a FeedNameCategory
     * @example
     * // Get one FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedNameCategoryFindUniqueArgs>(args: SelectSubset<T, FeedNameCategoryFindUniqueArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedNameCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedNameCategoryFindUniqueOrThrowArgs} args - Arguments to find a FeedNameCategory
     * @example
     * // Get one FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedNameCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedNameCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedNameCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryFindFirstArgs} args - Arguments to find a FeedNameCategory
     * @example
     * // Get one FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedNameCategoryFindFirstArgs>(args?: SelectSubset<T, FeedNameCategoryFindFirstArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedNameCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryFindFirstOrThrowArgs} args - Arguments to find a FeedNameCategory
     * @example
     * // Get one FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedNameCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedNameCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedNameCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedNameCategories
     * const feedNameCategories = await prisma.feedNameCategory.findMany()
     * 
     * // Get first 10 FeedNameCategories
     * const feedNameCategories = await prisma.feedNameCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedNameCategoryWithIdOnly = await prisma.feedNameCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedNameCategoryFindManyArgs>(args?: SelectSubset<T, FeedNameCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedNameCategory.
     * @param {FeedNameCategoryCreateArgs} args - Arguments to create a FeedNameCategory.
     * @example
     * // Create one FeedNameCategory
     * const FeedNameCategory = await prisma.feedNameCategory.create({
     *   data: {
     *     // ... data to create a FeedNameCategory
     *   }
     * })
     * 
     */
    create<T extends FeedNameCategoryCreateArgs>(args: SelectSubset<T, FeedNameCategoryCreateArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedNameCategories.
     * @param {FeedNameCategoryCreateManyArgs} args - Arguments to create many FeedNameCategories.
     * @example
     * // Create many FeedNameCategories
     * const feedNameCategory = await prisma.feedNameCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedNameCategoryCreateManyArgs>(args?: SelectSubset<T, FeedNameCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedNameCategories and returns the data saved in the database.
     * @param {FeedNameCategoryCreateManyAndReturnArgs} args - Arguments to create many FeedNameCategories.
     * @example
     * // Create many FeedNameCategories
     * const feedNameCategory = await prisma.feedNameCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedNameCategories and only return the `id`
     * const feedNameCategoryWithIdOnly = await prisma.feedNameCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedNameCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedNameCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedNameCategory.
     * @param {FeedNameCategoryDeleteArgs} args - Arguments to delete one FeedNameCategory.
     * @example
     * // Delete one FeedNameCategory
     * const FeedNameCategory = await prisma.feedNameCategory.delete({
     *   where: {
     *     // ... filter to delete one FeedNameCategory
     *   }
     * })
     * 
     */
    delete<T extends FeedNameCategoryDeleteArgs>(args: SelectSubset<T, FeedNameCategoryDeleteArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedNameCategory.
     * @param {FeedNameCategoryUpdateArgs} args - Arguments to update one FeedNameCategory.
     * @example
     * // Update one FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedNameCategoryUpdateArgs>(args: SelectSubset<T, FeedNameCategoryUpdateArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedNameCategories.
     * @param {FeedNameCategoryDeleteManyArgs} args - Arguments to filter FeedNameCategories to delete.
     * @example
     * // Delete a few FeedNameCategories
     * const { count } = await prisma.feedNameCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedNameCategoryDeleteManyArgs>(args?: SelectSubset<T, FeedNameCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedNameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedNameCategories
     * const feedNameCategory = await prisma.feedNameCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedNameCategoryUpdateManyArgs>(args: SelectSubset<T, FeedNameCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedNameCategories and returns the data updated in the database.
     * @param {FeedNameCategoryUpdateManyAndReturnArgs} args - Arguments to update many FeedNameCategories.
     * @example
     * // Update many FeedNameCategories
     * const feedNameCategory = await prisma.feedNameCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedNameCategories and only return the `id`
     * const feedNameCategoryWithIdOnly = await prisma.feedNameCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedNameCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedNameCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedNameCategory.
     * @param {FeedNameCategoryUpsertArgs} args - Arguments to update or create a FeedNameCategory.
     * @example
     * // Update or create a FeedNameCategory
     * const feedNameCategory = await prisma.feedNameCategory.upsert({
     *   create: {
     *     // ... data to create a FeedNameCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedNameCategory we want to update
     *   }
     * })
     */
    upsert<T extends FeedNameCategoryUpsertArgs>(args: SelectSubset<T, FeedNameCategoryUpsertArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedNameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryCountArgs} args - Arguments to filter FeedNameCategories to count.
     * @example
     * // Count the number of FeedNameCategories
     * const count = await prisma.feedNameCategory.count({
     *   where: {
     *     // ... the filter for the FeedNameCategories we want to count
     *   }
     * })
    **/
    count<T extends FeedNameCategoryCountArgs>(
      args?: Subset<T, FeedNameCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedNameCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedNameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedNameCategoryAggregateArgs>(args: Subset<T, FeedNameCategoryAggregateArgs>): Prisma.PrismaPromise<GetFeedNameCategoryAggregateType<T>>

    /**
     * Group by FeedNameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedNameCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedNameCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedNameCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FeedNameCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedNameCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedNameCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedNameCategory model
   */
  readonly fields: FeedNameCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedNameCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedNameCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeds<T extends FeedNameCategory$feedsArgs<ExtArgs> = {}>(args?: Subset<T, FeedNameCategory$feedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedNameCategory model
   */
  interface FeedNameCategoryFieldRefs {
    readonly id: FieldRef<"FeedNameCategory", 'String'>
    readonly feedName: FieldRef<"FeedNameCategory", 'String'>
    readonly feedCodeNumber: FieldRef<"FeedNameCategory", 'Int'>
    readonly createdAt: FieldRef<"FeedNameCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedNameCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedNameCategory findUnique
   */
  export type FeedNameCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeedNameCategory to fetch.
     */
    where: FeedNameCategoryWhereUniqueInput
  }

  /**
   * FeedNameCategory findUniqueOrThrow
   */
  export type FeedNameCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeedNameCategory to fetch.
     */
    where: FeedNameCategoryWhereUniqueInput
  }

  /**
   * FeedNameCategory findFirst
   */
  export type FeedNameCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeedNameCategory to fetch.
     */
    where?: FeedNameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedNameCategories to fetch.
     */
    orderBy?: FeedNameCategoryOrderByWithRelationInput | FeedNameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedNameCategories.
     */
    cursor?: FeedNameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedNameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedNameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedNameCategories.
     */
    distinct?: FeedNameCategoryScalarFieldEnum | FeedNameCategoryScalarFieldEnum[]
  }

  /**
   * FeedNameCategory findFirstOrThrow
   */
  export type FeedNameCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeedNameCategory to fetch.
     */
    where?: FeedNameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedNameCategories to fetch.
     */
    orderBy?: FeedNameCategoryOrderByWithRelationInput | FeedNameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedNameCategories.
     */
    cursor?: FeedNameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedNameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedNameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedNameCategories.
     */
    distinct?: FeedNameCategoryScalarFieldEnum | FeedNameCategoryScalarFieldEnum[]
  }

  /**
   * FeedNameCategory findMany
   */
  export type FeedNameCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeedNameCategories to fetch.
     */
    where?: FeedNameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedNameCategories to fetch.
     */
    orderBy?: FeedNameCategoryOrderByWithRelationInput | FeedNameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedNameCategories.
     */
    cursor?: FeedNameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedNameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedNameCategories.
     */
    skip?: number
    distinct?: FeedNameCategoryScalarFieldEnum | FeedNameCategoryScalarFieldEnum[]
  }

  /**
   * FeedNameCategory create
   */
  export type FeedNameCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedNameCategory.
     */
    data: XOR<FeedNameCategoryCreateInput, FeedNameCategoryUncheckedCreateInput>
  }

  /**
   * FeedNameCategory createMany
   */
  export type FeedNameCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedNameCategories.
     */
    data: FeedNameCategoryCreateManyInput | FeedNameCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedNameCategory createManyAndReturn
   */
  export type FeedNameCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many FeedNameCategories.
     */
    data: FeedNameCategoryCreateManyInput | FeedNameCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedNameCategory update
   */
  export type FeedNameCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedNameCategory.
     */
    data: XOR<FeedNameCategoryUpdateInput, FeedNameCategoryUncheckedUpdateInput>
    /**
     * Choose, which FeedNameCategory to update.
     */
    where: FeedNameCategoryWhereUniqueInput
  }

  /**
   * FeedNameCategory updateMany
   */
  export type FeedNameCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedNameCategories.
     */
    data: XOR<FeedNameCategoryUpdateManyMutationInput, FeedNameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FeedNameCategories to update
     */
    where?: FeedNameCategoryWhereInput
    /**
     * Limit how many FeedNameCategories to update.
     */
    limit?: number
  }

  /**
   * FeedNameCategory updateManyAndReturn
   */
  export type FeedNameCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * The data used to update FeedNameCategories.
     */
    data: XOR<FeedNameCategoryUpdateManyMutationInput, FeedNameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FeedNameCategories to update
     */
    where?: FeedNameCategoryWhereInput
    /**
     * Limit how many FeedNameCategories to update.
     */
    limit?: number
  }

  /**
   * FeedNameCategory upsert
   */
  export type FeedNameCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedNameCategory to update in case it exists.
     */
    where: FeedNameCategoryWhereUniqueInput
    /**
     * In case the FeedNameCategory found by the `where` argument doesn't exist, create a new FeedNameCategory with this data.
     */
    create: XOR<FeedNameCategoryCreateInput, FeedNameCategoryUncheckedCreateInput>
    /**
     * In case the FeedNameCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedNameCategoryUpdateInput, FeedNameCategoryUncheckedUpdateInput>
  }

  /**
   * FeedNameCategory delete
   */
  export type FeedNameCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
    /**
     * Filter which FeedNameCategory to delete.
     */
    where: FeedNameCategoryWhereUniqueInput
  }

  /**
   * FeedNameCategory deleteMany
   */
  export type FeedNameCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedNameCategories to delete
     */
    where?: FeedNameCategoryWhereInput
    /**
     * Limit how many FeedNameCategories to delete.
     */
    limit?: number
  }

  /**
   * FeedNameCategory.feeds
   */
  export type FeedNameCategory$feedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    where?: FeedWhereInput
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    cursor?: FeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedScalarFieldEnum | FeedScalarFieldEnum[]
  }

  /**
   * FeedNameCategory without action
   */
  export type FeedNameCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedNameCategory
     */
    select?: FeedNameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedNameCategory
     */
    omit?: FeedNameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedNameCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Feed
   */

  export type AggregateFeed = {
    _count: FeedCountAggregateOutputType | null
    _avg: FeedAvgAggregateOutputType | null
    _sum: FeedSumAggregateOutputType | null
    _min: FeedMinAggregateOutputType | null
    _max: FeedMaxAggregateOutputType | null
  }

  export type FeedAvgAggregateOutputType = {
    stock: number | null
  }

  export type FeedSumAggregateOutputType = {
    stock: number | null
  }

  export type FeedMinAggregateOutputType = {
    id: string | null
    feedName: string | null
    stock: number | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedMaxAggregateOutputType = {
    id: string | null
    feedName: string | null
    stock: number | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedCountAggregateOutputType = {
    id: number
    feedName: number
    stock: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedAvgAggregateInputType = {
    stock?: true
  }

  export type FeedSumAggregateInputType = {
    stock?: true
  }

  export type FeedMinAggregateInputType = {
    id?: true
    feedName?: true
    stock?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedMaxAggregateInputType = {
    id?: true
    feedName?: true
    stock?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedCountAggregateInputType = {
    id?: true
    feedName?: true
    stock?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feed to aggregate.
     */
    where?: FeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeds to fetch.
     */
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feeds
    **/
    _count?: true | FeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedMaxAggregateInputType
  }

  export type GetFeedAggregateType<T extends FeedAggregateArgs> = {
        [P in keyof T & keyof AggregateFeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeed[P]>
      : GetScalarType<T[P], AggregateFeed[P]>
  }




  export type FeedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedWhereInput
    orderBy?: FeedOrderByWithAggregationInput | FeedOrderByWithAggregationInput[]
    by: FeedScalarFieldEnum[] | FeedScalarFieldEnum
    having?: FeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedCountAggregateInputType | true
    _avg?: FeedAvgAggregateInputType
    _sum?: FeedSumAggregateInputType
    _min?: FeedMinAggregateInputType
    _max?: FeedMaxAggregateInputType
  }

  export type FeedGroupByOutputType = {
    id: string
    feedName: string
    stock: number
    branchCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeedCountAggregateOutputType | null
    _avg: FeedAvgAggregateOutputType | null
    _sum: FeedSumAggregateOutputType | null
    _min: FeedMinAggregateOutputType | null
    _max: FeedMaxAggregateOutputType | null
  }

  type GetFeedGroupByPayload<T extends FeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedGroupByOutputType[P]>
            : GetScalarType<T[P], FeedGroupByOutputType[P]>
        }
      >
    >


  export type FeedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    stock?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }, ExtArgs["result"]["feed"]>

  export type FeedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    stock?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }, ExtArgs["result"]["feed"]>

  export type FeedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedName?: boolean
    stock?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }, ExtArgs["result"]["feed"]>

  export type FeedSelectScalar = {
    id?: boolean
    feedName?: boolean
    stock?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feedName" | "stock" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["feed"]>
  export type FeedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }
  export type FeedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }
  export type FeedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedNameCategory?: boolean | FeedNameCategoryDefaultArgs<ExtArgs>
    branch?: boolean | Feed$branchArgs<ExtArgs>
  }

  export type $FeedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feed"
    objects: {
      feedNameCategory: Prisma.$FeedNameCategoryPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feedName: string
      stock: number
      branchCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feed"]>
    composites: {}
  }

  type FeedGetPayload<S extends boolean | null | undefined | FeedDefaultArgs> = $Result.GetResult<Prisma.$FeedPayload, S>

  type FeedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedCountAggregateInputType | true
    }

  export interface FeedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feed'], meta: { name: 'Feed' } }
    /**
     * Find zero or one Feed that matches the filter.
     * @param {FeedFindUniqueArgs} args - Arguments to find a Feed
     * @example
     * // Get one Feed
     * const feed = await prisma.feed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedFindUniqueArgs>(args: SelectSubset<T, FeedFindUniqueArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedFindUniqueOrThrowArgs} args - Arguments to find a Feed
     * @example
     * // Get one Feed
     * const feed = await prisma.feed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedFindFirstArgs} args - Arguments to find a Feed
     * @example
     * // Get one Feed
     * const feed = await prisma.feed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedFindFirstArgs>(args?: SelectSubset<T, FeedFindFirstArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedFindFirstOrThrowArgs} args - Arguments to find a Feed
     * @example
     * // Get one Feed
     * const feed = await prisma.feed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feeds
     * const feeds = await prisma.feed.findMany()
     * 
     * // Get first 10 Feeds
     * const feeds = await prisma.feed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedWithIdOnly = await prisma.feed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedFindManyArgs>(args?: SelectSubset<T, FeedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feed.
     * @param {FeedCreateArgs} args - Arguments to create a Feed.
     * @example
     * // Create one Feed
     * const Feed = await prisma.feed.create({
     *   data: {
     *     // ... data to create a Feed
     *   }
     * })
     * 
     */
    create<T extends FeedCreateArgs>(args: SelectSubset<T, FeedCreateArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feeds.
     * @param {FeedCreateManyArgs} args - Arguments to create many Feeds.
     * @example
     * // Create many Feeds
     * const feed = await prisma.feed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedCreateManyArgs>(args?: SelectSubset<T, FeedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feeds and returns the data saved in the database.
     * @param {FeedCreateManyAndReturnArgs} args - Arguments to create many Feeds.
     * @example
     * // Create many Feeds
     * const feed = await prisma.feed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feeds and only return the `id`
     * const feedWithIdOnly = await prisma.feed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feed.
     * @param {FeedDeleteArgs} args - Arguments to delete one Feed.
     * @example
     * // Delete one Feed
     * const Feed = await prisma.feed.delete({
     *   where: {
     *     // ... filter to delete one Feed
     *   }
     * })
     * 
     */
    delete<T extends FeedDeleteArgs>(args: SelectSubset<T, FeedDeleteArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feed.
     * @param {FeedUpdateArgs} args - Arguments to update one Feed.
     * @example
     * // Update one Feed
     * const feed = await prisma.feed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedUpdateArgs>(args: SelectSubset<T, FeedUpdateArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feeds.
     * @param {FeedDeleteManyArgs} args - Arguments to filter Feeds to delete.
     * @example
     * // Delete a few Feeds
     * const { count } = await prisma.feed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedDeleteManyArgs>(args?: SelectSubset<T, FeedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feeds
     * const feed = await prisma.feed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedUpdateManyArgs>(args: SelectSubset<T, FeedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feeds and returns the data updated in the database.
     * @param {FeedUpdateManyAndReturnArgs} args - Arguments to update many Feeds.
     * @example
     * // Update many Feeds
     * const feed = await prisma.feed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feeds and only return the `id`
     * const feedWithIdOnly = await prisma.feed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feed.
     * @param {FeedUpsertArgs} args - Arguments to update or create a Feed.
     * @example
     * // Update or create a Feed
     * const feed = await prisma.feed.upsert({
     *   create: {
     *     // ... data to create a Feed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feed we want to update
     *   }
     * })
     */
    upsert<T extends FeedUpsertArgs>(args: SelectSubset<T, FeedUpsertArgs<ExtArgs>>): Prisma__FeedClient<$Result.GetResult<Prisma.$FeedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCountArgs} args - Arguments to filter Feeds to count.
     * @example
     * // Count the number of Feeds
     * const count = await prisma.feed.count({
     *   where: {
     *     // ... the filter for the Feeds we want to count
     *   }
     * })
    **/
    count<T extends FeedCountArgs>(
      args?: Subset<T, FeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedAggregateArgs>(args: Subset<T, FeedAggregateArgs>): Prisma.PrismaPromise<GetFeedAggregateType<T>>

    /**
     * Group by Feed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedGroupByArgs['orderBy'] }
        : { orderBy?: FeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feed model
   */
  readonly fields: FeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedNameCategory<T extends FeedNameCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedNameCategoryDefaultArgs<ExtArgs>>): Prisma__FeedNameCategoryClient<$Result.GetResult<Prisma.$FeedNameCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends Feed$branchArgs<ExtArgs> = {}>(args?: Subset<T, Feed$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feed model
   */
  interface FeedFieldRefs {
    readonly id: FieldRef<"Feed", 'String'>
    readonly feedName: FieldRef<"Feed", 'String'>
    readonly stock: FieldRef<"Feed", 'Int'>
    readonly branchCode: FieldRef<"Feed", 'String'>
    readonly createdAt: FieldRef<"Feed", 'DateTime'>
    readonly updatedAt: FieldRef<"Feed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feed findUnique
   */
  export type FeedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter, which Feed to fetch.
     */
    where: FeedWhereUniqueInput
  }

  /**
   * Feed findUniqueOrThrow
   */
  export type FeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter, which Feed to fetch.
     */
    where: FeedWhereUniqueInput
  }

  /**
   * Feed findFirst
   */
  export type FeedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter, which Feed to fetch.
     */
    where?: FeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeds to fetch.
     */
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feeds.
     */
    cursor?: FeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feeds.
     */
    distinct?: FeedScalarFieldEnum | FeedScalarFieldEnum[]
  }

  /**
   * Feed findFirstOrThrow
   */
  export type FeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter, which Feed to fetch.
     */
    where?: FeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeds to fetch.
     */
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feeds.
     */
    cursor?: FeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feeds.
     */
    distinct?: FeedScalarFieldEnum | FeedScalarFieldEnum[]
  }

  /**
   * Feed findMany
   */
  export type FeedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter, which Feeds to fetch.
     */
    where?: FeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feeds to fetch.
     */
    orderBy?: FeedOrderByWithRelationInput | FeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feeds.
     */
    cursor?: FeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feeds.
     */
    skip?: number
    distinct?: FeedScalarFieldEnum | FeedScalarFieldEnum[]
  }

  /**
   * Feed create
   */
  export type FeedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * The data needed to create a Feed.
     */
    data: XOR<FeedCreateInput, FeedUncheckedCreateInput>
  }

  /**
   * Feed createMany
   */
  export type FeedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feeds.
     */
    data: FeedCreateManyInput | FeedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feed createManyAndReturn
   */
  export type FeedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * The data used to create many Feeds.
     */
    data: FeedCreateManyInput | FeedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feed update
   */
  export type FeedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * The data needed to update a Feed.
     */
    data: XOR<FeedUpdateInput, FeedUncheckedUpdateInput>
    /**
     * Choose, which Feed to update.
     */
    where: FeedWhereUniqueInput
  }

  /**
   * Feed updateMany
   */
  export type FeedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feeds.
     */
    data: XOR<FeedUpdateManyMutationInput, FeedUncheckedUpdateManyInput>
    /**
     * Filter which Feeds to update
     */
    where?: FeedWhereInput
    /**
     * Limit how many Feeds to update.
     */
    limit?: number
  }

  /**
   * Feed updateManyAndReturn
   */
  export type FeedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * The data used to update Feeds.
     */
    data: XOR<FeedUpdateManyMutationInput, FeedUncheckedUpdateManyInput>
    /**
     * Filter which Feeds to update
     */
    where?: FeedWhereInput
    /**
     * Limit how many Feeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feed upsert
   */
  export type FeedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * The filter to search for the Feed to update in case it exists.
     */
    where: FeedWhereUniqueInput
    /**
     * In case the Feed found by the `where` argument doesn't exist, create a new Feed with this data.
     */
    create: XOR<FeedCreateInput, FeedUncheckedCreateInput>
    /**
     * In case the Feed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedUpdateInput, FeedUncheckedUpdateInput>
  }

  /**
   * Feed delete
   */
  export type FeedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
    /**
     * Filter which Feed to delete.
     */
    where: FeedWhereUniqueInput
  }

  /**
   * Feed deleteMany
   */
  export type FeedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feeds to delete
     */
    where?: FeedWhereInput
    /**
     * Limit how many Feeds to delete.
     */
    limit?: number
  }

  /**
   * Feed.branch
   */
  export type Feed$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Feed without action
   */
  export type FeedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feed
     */
    select?: FeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feed
     */
    omit?: FeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInclude<ExtArgs> | null
  }


  /**
   * Model AllGenericMedicin
   */

  export type AggregateAllGenericMedicin = {
    _count: AllGenericMedicinCountAggregateOutputType | null
    _min: AllGenericMedicinMinAggregateOutputType | null
    _max: AllGenericMedicinMaxAggregateOutputType | null
  }

  export type AllGenericMedicinMinAggregateOutputType = {
    id: string | null
    genericName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllGenericMedicinMaxAggregateOutputType = {
    id: string | null
    genericName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AllGenericMedicinCountAggregateOutputType = {
    id: number
    genericName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AllGenericMedicinMinAggregateInputType = {
    id?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllGenericMedicinMaxAggregateInputType = {
    id?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AllGenericMedicinCountAggregateInputType = {
    id?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AllGenericMedicinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllGenericMedicin to aggregate.
     */
    where?: AllGenericMedicinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllGenericMedicins to fetch.
     */
    orderBy?: AllGenericMedicinOrderByWithRelationInput | AllGenericMedicinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllGenericMedicinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllGenericMedicins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllGenericMedicins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AllGenericMedicins
    **/
    _count?: true | AllGenericMedicinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllGenericMedicinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllGenericMedicinMaxAggregateInputType
  }

  export type GetAllGenericMedicinAggregateType<T extends AllGenericMedicinAggregateArgs> = {
        [P in keyof T & keyof AggregateAllGenericMedicin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllGenericMedicin[P]>
      : GetScalarType<T[P], AggregateAllGenericMedicin[P]>
  }




  export type AllGenericMedicinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllGenericMedicinWhereInput
    orderBy?: AllGenericMedicinOrderByWithAggregationInput | AllGenericMedicinOrderByWithAggregationInput[]
    by: AllGenericMedicinScalarFieldEnum[] | AllGenericMedicinScalarFieldEnum
    having?: AllGenericMedicinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllGenericMedicinCountAggregateInputType | true
    _min?: AllGenericMedicinMinAggregateInputType
    _max?: AllGenericMedicinMaxAggregateInputType
  }

  export type AllGenericMedicinGroupByOutputType = {
    id: string
    genericName: string
    createdAt: Date
    updatedAt: Date
    _count: AllGenericMedicinCountAggregateOutputType | null
    _min: AllGenericMedicinMinAggregateOutputType | null
    _max: AllGenericMedicinMaxAggregateOutputType | null
  }

  type GetAllGenericMedicinGroupByPayload<T extends AllGenericMedicinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllGenericMedicinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllGenericMedicinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllGenericMedicinGroupByOutputType[P]>
            : GetScalarType<T[P], AllGenericMedicinGroupByOutputType[P]>
        }
      >
    >


  export type AllGenericMedicinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineNameAdd?: boolean | AllGenericMedicin$medicineNameAddArgs<ExtArgs>
    medicineStock?: boolean | AllGenericMedicin$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | AllGenericMedicin$medicinePurchessArgs<ExtArgs>
    _count?: boolean | AllGenericMedicinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allGenericMedicin"]>

  export type AllGenericMedicinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["allGenericMedicin"]>

  export type AllGenericMedicinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["allGenericMedicin"]>

  export type AllGenericMedicinSelectScalar = {
    id?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AllGenericMedicinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "genericName" | "createdAt" | "updatedAt", ExtArgs["result"]["allGenericMedicin"]>
  export type AllGenericMedicinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineNameAdd?: boolean | AllGenericMedicin$medicineNameAddArgs<ExtArgs>
    medicineStock?: boolean | AllGenericMedicin$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | AllGenericMedicin$medicinePurchessArgs<ExtArgs>
    _count?: boolean | AllGenericMedicinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AllGenericMedicinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AllGenericMedicinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AllGenericMedicinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AllGenericMedicin"
    objects: {
      medicineNameAdd: Prisma.$MedicineNameAddPayload<ExtArgs>[]
      medicineStock: Prisma.$MedicineStockPayload<ExtArgs>[]
      medicinePurchess: Prisma.$MedicinePurchessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      genericName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["allGenericMedicin"]>
    composites: {}
  }

  type AllGenericMedicinGetPayload<S extends boolean | null | undefined | AllGenericMedicinDefaultArgs> = $Result.GetResult<Prisma.$AllGenericMedicinPayload, S>

  type AllGenericMedicinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllGenericMedicinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllGenericMedicinCountAggregateInputType | true
    }

  export interface AllGenericMedicinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AllGenericMedicin'], meta: { name: 'AllGenericMedicin' } }
    /**
     * Find zero or one AllGenericMedicin that matches the filter.
     * @param {AllGenericMedicinFindUniqueArgs} args - Arguments to find a AllGenericMedicin
     * @example
     * // Get one AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllGenericMedicinFindUniqueArgs>(args: SelectSubset<T, AllGenericMedicinFindUniqueArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AllGenericMedicin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllGenericMedicinFindUniqueOrThrowArgs} args - Arguments to find a AllGenericMedicin
     * @example
     * // Get one AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllGenericMedicinFindUniqueOrThrowArgs>(args: SelectSubset<T, AllGenericMedicinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AllGenericMedicin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinFindFirstArgs} args - Arguments to find a AllGenericMedicin
     * @example
     * // Get one AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllGenericMedicinFindFirstArgs>(args?: SelectSubset<T, AllGenericMedicinFindFirstArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AllGenericMedicin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinFindFirstOrThrowArgs} args - Arguments to find a AllGenericMedicin
     * @example
     * // Get one AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllGenericMedicinFindFirstOrThrowArgs>(args?: SelectSubset<T, AllGenericMedicinFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AllGenericMedicins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AllGenericMedicins
     * const allGenericMedicins = await prisma.allGenericMedicin.findMany()
     * 
     * // Get first 10 AllGenericMedicins
     * const allGenericMedicins = await prisma.allGenericMedicin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allGenericMedicinWithIdOnly = await prisma.allGenericMedicin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllGenericMedicinFindManyArgs>(args?: SelectSubset<T, AllGenericMedicinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AllGenericMedicin.
     * @param {AllGenericMedicinCreateArgs} args - Arguments to create a AllGenericMedicin.
     * @example
     * // Create one AllGenericMedicin
     * const AllGenericMedicin = await prisma.allGenericMedicin.create({
     *   data: {
     *     // ... data to create a AllGenericMedicin
     *   }
     * })
     * 
     */
    create<T extends AllGenericMedicinCreateArgs>(args: SelectSubset<T, AllGenericMedicinCreateArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AllGenericMedicins.
     * @param {AllGenericMedicinCreateManyArgs} args - Arguments to create many AllGenericMedicins.
     * @example
     * // Create many AllGenericMedicins
     * const allGenericMedicin = await prisma.allGenericMedicin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllGenericMedicinCreateManyArgs>(args?: SelectSubset<T, AllGenericMedicinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AllGenericMedicins and returns the data saved in the database.
     * @param {AllGenericMedicinCreateManyAndReturnArgs} args - Arguments to create many AllGenericMedicins.
     * @example
     * // Create many AllGenericMedicins
     * const allGenericMedicin = await prisma.allGenericMedicin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AllGenericMedicins and only return the `id`
     * const allGenericMedicinWithIdOnly = await prisma.allGenericMedicin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllGenericMedicinCreateManyAndReturnArgs>(args?: SelectSubset<T, AllGenericMedicinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AllGenericMedicin.
     * @param {AllGenericMedicinDeleteArgs} args - Arguments to delete one AllGenericMedicin.
     * @example
     * // Delete one AllGenericMedicin
     * const AllGenericMedicin = await prisma.allGenericMedicin.delete({
     *   where: {
     *     // ... filter to delete one AllGenericMedicin
     *   }
     * })
     * 
     */
    delete<T extends AllGenericMedicinDeleteArgs>(args: SelectSubset<T, AllGenericMedicinDeleteArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AllGenericMedicin.
     * @param {AllGenericMedicinUpdateArgs} args - Arguments to update one AllGenericMedicin.
     * @example
     * // Update one AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllGenericMedicinUpdateArgs>(args: SelectSubset<T, AllGenericMedicinUpdateArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AllGenericMedicins.
     * @param {AllGenericMedicinDeleteManyArgs} args - Arguments to filter AllGenericMedicins to delete.
     * @example
     * // Delete a few AllGenericMedicins
     * const { count } = await prisma.allGenericMedicin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllGenericMedicinDeleteManyArgs>(args?: SelectSubset<T, AllGenericMedicinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllGenericMedicins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AllGenericMedicins
     * const allGenericMedicin = await prisma.allGenericMedicin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllGenericMedicinUpdateManyArgs>(args: SelectSubset<T, AllGenericMedicinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllGenericMedicins and returns the data updated in the database.
     * @param {AllGenericMedicinUpdateManyAndReturnArgs} args - Arguments to update many AllGenericMedicins.
     * @example
     * // Update many AllGenericMedicins
     * const allGenericMedicin = await prisma.allGenericMedicin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AllGenericMedicins and only return the `id`
     * const allGenericMedicinWithIdOnly = await prisma.allGenericMedicin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllGenericMedicinUpdateManyAndReturnArgs>(args: SelectSubset<T, AllGenericMedicinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AllGenericMedicin.
     * @param {AllGenericMedicinUpsertArgs} args - Arguments to update or create a AllGenericMedicin.
     * @example
     * // Update or create a AllGenericMedicin
     * const allGenericMedicin = await prisma.allGenericMedicin.upsert({
     *   create: {
     *     // ... data to create a AllGenericMedicin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AllGenericMedicin we want to update
     *   }
     * })
     */
    upsert<T extends AllGenericMedicinUpsertArgs>(args: SelectSubset<T, AllGenericMedicinUpsertArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AllGenericMedicins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinCountArgs} args - Arguments to filter AllGenericMedicins to count.
     * @example
     * // Count the number of AllGenericMedicins
     * const count = await prisma.allGenericMedicin.count({
     *   where: {
     *     // ... the filter for the AllGenericMedicins we want to count
     *   }
     * })
    **/
    count<T extends AllGenericMedicinCountArgs>(
      args?: Subset<T, AllGenericMedicinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllGenericMedicinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AllGenericMedicin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllGenericMedicinAggregateArgs>(args: Subset<T, AllGenericMedicinAggregateArgs>): Prisma.PrismaPromise<GetAllGenericMedicinAggregateType<T>>

    /**
     * Group by AllGenericMedicin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllGenericMedicinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllGenericMedicinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllGenericMedicinGroupByArgs['orderBy'] }
        : { orderBy?: AllGenericMedicinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllGenericMedicinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllGenericMedicinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AllGenericMedicin model
   */
  readonly fields: AllGenericMedicinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AllGenericMedicin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllGenericMedicinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicineNameAdd<T extends AllGenericMedicin$medicineNameAddArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicin$medicineNameAddArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicineStock<T extends AllGenericMedicin$medicineStockArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicin$medicineStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicinePurchess<T extends AllGenericMedicin$medicinePurchessArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicin$medicinePurchessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AllGenericMedicin model
   */
  interface AllGenericMedicinFieldRefs {
    readonly id: FieldRef<"AllGenericMedicin", 'String'>
    readonly genericName: FieldRef<"AllGenericMedicin", 'String'>
    readonly createdAt: FieldRef<"AllGenericMedicin", 'DateTime'>
    readonly updatedAt: FieldRef<"AllGenericMedicin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AllGenericMedicin findUnique
   */
  export type AllGenericMedicinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter, which AllGenericMedicin to fetch.
     */
    where: AllGenericMedicinWhereUniqueInput
  }

  /**
   * AllGenericMedicin findUniqueOrThrow
   */
  export type AllGenericMedicinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter, which AllGenericMedicin to fetch.
     */
    where: AllGenericMedicinWhereUniqueInput
  }

  /**
   * AllGenericMedicin findFirst
   */
  export type AllGenericMedicinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter, which AllGenericMedicin to fetch.
     */
    where?: AllGenericMedicinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllGenericMedicins to fetch.
     */
    orderBy?: AllGenericMedicinOrderByWithRelationInput | AllGenericMedicinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllGenericMedicins.
     */
    cursor?: AllGenericMedicinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllGenericMedicins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllGenericMedicins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllGenericMedicins.
     */
    distinct?: AllGenericMedicinScalarFieldEnum | AllGenericMedicinScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin findFirstOrThrow
   */
  export type AllGenericMedicinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter, which AllGenericMedicin to fetch.
     */
    where?: AllGenericMedicinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllGenericMedicins to fetch.
     */
    orderBy?: AllGenericMedicinOrderByWithRelationInput | AllGenericMedicinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllGenericMedicins.
     */
    cursor?: AllGenericMedicinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllGenericMedicins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllGenericMedicins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllGenericMedicins.
     */
    distinct?: AllGenericMedicinScalarFieldEnum | AllGenericMedicinScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin findMany
   */
  export type AllGenericMedicinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter, which AllGenericMedicins to fetch.
     */
    where?: AllGenericMedicinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllGenericMedicins to fetch.
     */
    orderBy?: AllGenericMedicinOrderByWithRelationInput | AllGenericMedicinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AllGenericMedicins.
     */
    cursor?: AllGenericMedicinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllGenericMedicins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllGenericMedicins.
     */
    skip?: number
    distinct?: AllGenericMedicinScalarFieldEnum | AllGenericMedicinScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin create
   */
  export type AllGenericMedicinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * The data needed to create a AllGenericMedicin.
     */
    data: XOR<AllGenericMedicinCreateInput, AllGenericMedicinUncheckedCreateInput>
  }

  /**
   * AllGenericMedicin createMany
   */
  export type AllGenericMedicinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AllGenericMedicins.
     */
    data: AllGenericMedicinCreateManyInput | AllGenericMedicinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllGenericMedicin createManyAndReturn
   */
  export type AllGenericMedicinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * The data used to create many AllGenericMedicins.
     */
    data: AllGenericMedicinCreateManyInput | AllGenericMedicinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllGenericMedicin update
   */
  export type AllGenericMedicinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * The data needed to update a AllGenericMedicin.
     */
    data: XOR<AllGenericMedicinUpdateInput, AllGenericMedicinUncheckedUpdateInput>
    /**
     * Choose, which AllGenericMedicin to update.
     */
    where: AllGenericMedicinWhereUniqueInput
  }

  /**
   * AllGenericMedicin updateMany
   */
  export type AllGenericMedicinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AllGenericMedicins.
     */
    data: XOR<AllGenericMedicinUpdateManyMutationInput, AllGenericMedicinUncheckedUpdateManyInput>
    /**
     * Filter which AllGenericMedicins to update
     */
    where?: AllGenericMedicinWhereInput
    /**
     * Limit how many AllGenericMedicins to update.
     */
    limit?: number
  }

  /**
   * AllGenericMedicin updateManyAndReturn
   */
  export type AllGenericMedicinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * The data used to update AllGenericMedicins.
     */
    data: XOR<AllGenericMedicinUpdateManyMutationInput, AllGenericMedicinUncheckedUpdateManyInput>
    /**
     * Filter which AllGenericMedicins to update
     */
    where?: AllGenericMedicinWhereInput
    /**
     * Limit how many AllGenericMedicins to update.
     */
    limit?: number
  }

  /**
   * AllGenericMedicin upsert
   */
  export type AllGenericMedicinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * The filter to search for the AllGenericMedicin to update in case it exists.
     */
    where: AllGenericMedicinWhereUniqueInput
    /**
     * In case the AllGenericMedicin found by the `where` argument doesn't exist, create a new AllGenericMedicin with this data.
     */
    create: XOR<AllGenericMedicinCreateInput, AllGenericMedicinUncheckedCreateInput>
    /**
     * In case the AllGenericMedicin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllGenericMedicinUpdateInput, AllGenericMedicinUncheckedUpdateInput>
  }

  /**
   * AllGenericMedicin delete
   */
  export type AllGenericMedicinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
    /**
     * Filter which AllGenericMedicin to delete.
     */
    where: AllGenericMedicinWhereUniqueInput
  }

  /**
   * AllGenericMedicin deleteMany
   */
  export type AllGenericMedicinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllGenericMedicins to delete
     */
    where?: AllGenericMedicinWhereInput
    /**
     * Limit how many AllGenericMedicins to delete.
     */
    limit?: number
  }

  /**
   * AllGenericMedicin.medicineNameAdd
   */
  export type AllGenericMedicin$medicineNameAddArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    where?: MedicineNameAddWhereInput
    orderBy?: MedicineNameAddOrderByWithRelationInput | MedicineNameAddOrderByWithRelationInput[]
    cursor?: MedicineNameAddWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineNameAddScalarFieldEnum | MedicineNameAddScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin.medicineStock
   */
  export type AllGenericMedicin$medicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    where?: MedicineStockWhereInput
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    cursor?: MedicineStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin.medicinePurchess
   */
  export type AllGenericMedicin$medicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    where?: MedicinePurchessWhereInput
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    cursor?: MedicinePurchessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * AllGenericMedicin without action
   */
  export type AllGenericMedicinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllGenericMedicin
     */
    select?: AllGenericMedicinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllGenericMedicin
     */
    omit?: AllGenericMedicinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllGenericMedicinInclude<ExtArgs> | null
  }


  /**
   * Model MedicineNameAdd
   */

  export type AggregateMedicineNameAdd = {
    _count: MedicineNameAddCountAggregateOutputType | null
    _min: MedicineNameAddMinAggregateOutputType | null
    _max: MedicineNameAddMaxAggregateOutputType | null
  }

  export type MedicineNameAddMinAggregateOutputType = {
    id: string | null
    name: string | null
    conpany: string | null
    genericName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineNameAddMaxAggregateOutputType = {
    id: string | null
    name: string | null
    conpany: string | null
    genericName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineNameAddCountAggregateOutputType = {
    id: number
    name: number
    conpany: number
    genericName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineNameAddMinAggregateInputType = {
    id?: true
    name?: true
    conpany?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineNameAddMaxAggregateInputType = {
    id?: true
    name?: true
    conpany?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineNameAddCountAggregateInputType = {
    id?: true
    name?: true
    conpany?: true
    genericName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineNameAddAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineNameAdd to aggregate.
     */
    where?: MedicineNameAddWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineNameAdds to fetch.
     */
    orderBy?: MedicineNameAddOrderByWithRelationInput | MedicineNameAddOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineNameAddWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineNameAdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineNameAdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineNameAdds
    **/
    _count?: true | MedicineNameAddCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineNameAddMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineNameAddMaxAggregateInputType
  }

  export type GetMedicineNameAddAggregateType<T extends MedicineNameAddAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineNameAdd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineNameAdd[P]>
      : GetScalarType<T[P], AggregateMedicineNameAdd[P]>
  }




  export type MedicineNameAddGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineNameAddWhereInput
    orderBy?: MedicineNameAddOrderByWithAggregationInput | MedicineNameAddOrderByWithAggregationInput[]
    by: MedicineNameAddScalarFieldEnum[] | MedicineNameAddScalarFieldEnum
    having?: MedicineNameAddScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineNameAddCountAggregateInputType | true
    _min?: MedicineNameAddMinAggregateInputType
    _max?: MedicineNameAddMaxAggregateInputType
  }

  export type MedicineNameAddGroupByOutputType = {
    id: string
    name: string
    conpany: string
    genericName: string
    createdAt: Date
    updatedAt: Date
    _count: MedicineNameAddCountAggregateOutputType | null
    _min: MedicineNameAddMinAggregateOutputType | null
    _max: MedicineNameAddMaxAggregateOutputType | null
  }

  type GetMedicineNameAddGroupByPayload<T extends MedicineNameAddGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineNameAddGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineNameAddGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineNameAddGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineNameAddGroupByOutputType[P]>
        }
      >
    >


  export type MedicineNameAddSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conpany?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineStock?: boolean | MedicineNameAdd$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | MedicineNameAdd$medicinePurchessArgs<ExtArgs>
    _count?: boolean | MedicineNameAddCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineNameAdd"]>

  export type MedicineNameAddSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conpany?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineNameAdd"]>

  export type MedicineNameAddSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    conpany?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineNameAdd"]>

  export type MedicineNameAddSelectScalar = {
    id?: boolean
    name?: boolean
    conpany?: boolean
    genericName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineNameAddOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "conpany" | "genericName" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineNameAdd"]>
  export type MedicineNameAddInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineStock?: boolean | MedicineNameAdd$medicineStockArgs<ExtArgs>
    medicinePurchess?: boolean | MedicineNameAdd$medicinePurchessArgs<ExtArgs>
    _count?: boolean | MedicineNameAddCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineNameAddIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
  }
  export type MedicineNameAddIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
  }

  export type $MedicineNameAddPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineNameAdd"
    objects: {
      medicineCategory: Prisma.$AllGenericMedicinPayload<ExtArgs>
      medicineStock: Prisma.$MedicineStockPayload<ExtArgs>[]
      medicinePurchess: Prisma.$MedicinePurchessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      conpany: string
      genericName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineNameAdd"]>
    composites: {}
  }

  type MedicineNameAddGetPayload<S extends boolean | null | undefined | MedicineNameAddDefaultArgs> = $Result.GetResult<Prisma.$MedicineNameAddPayload, S>

  type MedicineNameAddCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineNameAddFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineNameAddCountAggregateInputType | true
    }

  export interface MedicineNameAddDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineNameAdd'], meta: { name: 'MedicineNameAdd' } }
    /**
     * Find zero or one MedicineNameAdd that matches the filter.
     * @param {MedicineNameAddFindUniqueArgs} args - Arguments to find a MedicineNameAdd
     * @example
     * // Get one MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineNameAddFindUniqueArgs>(args: SelectSubset<T, MedicineNameAddFindUniqueArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineNameAdd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineNameAddFindUniqueOrThrowArgs} args - Arguments to find a MedicineNameAdd
     * @example
     * // Get one MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineNameAddFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineNameAddFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineNameAdd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddFindFirstArgs} args - Arguments to find a MedicineNameAdd
     * @example
     * // Get one MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineNameAddFindFirstArgs>(args?: SelectSubset<T, MedicineNameAddFindFirstArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineNameAdd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddFindFirstOrThrowArgs} args - Arguments to find a MedicineNameAdd
     * @example
     * // Get one MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineNameAddFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineNameAddFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineNameAdds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineNameAdds
     * const medicineNameAdds = await prisma.medicineNameAdd.findMany()
     * 
     * // Get first 10 MedicineNameAdds
     * const medicineNameAdds = await prisma.medicineNameAdd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineNameAddWithIdOnly = await prisma.medicineNameAdd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineNameAddFindManyArgs>(args?: SelectSubset<T, MedicineNameAddFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineNameAdd.
     * @param {MedicineNameAddCreateArgs} args - Arguments to create a MedicineNameAdd.
     * @example
     * // Create one MedicineNameAdd
     * const MedicineNameAdd = await prisma.medicineNameAdd.create({
     *   data: {
     *     // ... data to create a MedicineNameAdd
     *   }
     * })
     * 
     */
    create<T extends MedicineNameAddCreateArgs>(args: SelectSubset<T, MedicineNameAddCreateArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineNameAdds.
     * @param {MedicineNameAddCreateManyArgs} args - Arguments to create many MedicineNameAdds.
     * @example
     * // Create many MedicineNameAdds
     * const medicineNameAdd = await prisma.medicineNameAdd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineNameAddCreateManyArgs>(args?: SelectSubset<T, MedicineNameAddCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineNameAdds and returns the data saved in the database.
     * @param {MedicineNameAddCreateManyAndReturnArgs} args - Arguments to create many MedicineNameAdds.
     * @example
     * // Create many MedicineNameAdds
     * const medicineNameAdd = await prisma.medicineNameAdd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineNameAdds and only return the `id`
     * const medicineNameAddWithIdOnly = await prisma.medicineNameAdd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineNameAddCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineNameAddCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineNameAdd.
     * @param {MedicineNameAddDeleteArgs} args - Arguments to delete one MedicineNameAdd.
     * @example
     * // Delete one MedicineNameAdd
     * const MedicineNameAdd = await prisma.medicineNameAdd.delete({
     *   where: {
     *     // ... filter to delete one MedicineNameAdd
     *   }
     * })
     * 
     */
    delete<T extends MedicineNameAddDeleteArgs>(args: SelectSubset<T, MedicineNameAddDeleteArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineNameAdd.
     * @param {MedicineNameAddUpdateArgs} args - Arguments to update one MedicineNameAdd.
     * @example
     * // Update one MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineNameAddUpdateArgs>(args: SelectSubset<T, MedicineNameAddUpdateArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineNameAdds.
     * @param {MedicineNameAddDeleteManyArgs} args - Arguments to filter MedicineNameAdds to delete.
     * @example
     * // Delete a few MedicineNameAdds
     * const { count } = await prisma.medicineNameAdd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineNameAddDeleteManyArgs>(args?: SelectSubset<T, MedicineNameAddDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineNameAdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineNameAdds
     * const medicineNameAdd = await prisma.medicineNameAdd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineNameAddUpdateManyArgs>(args: SelectSubset<T, MedicineNameAddUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineNameAdds and returns the data updated in the database.
     * @param {MedicineNameAddUpdateManyAndReturnArgs} args - Arguments to update many MedicineNameAdds.
     * @example
     * // Update many MedicineNameAdds
     * const medicineNameAdd = await prisma.medicineNameAdd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineNameAdds and only return the `id`
     * const medicineNameAddWithIdOnly = await prisma.medicineNameAdd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineNameAddUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineNameAddUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineNameAdd.
     * @param {MedicineNameAddUpsertArgs} args - Arguments to update or create a MedicineNameAdd.
     * @example
     * // Update or create a MedicineNameAdd
     * const medicineNameAdd = await prisma.medicineNameAdd.upsert({
     *   create: {
     *     // ... data to create a MedicineNameAdd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineNameAdd we want to update
     *   }
     * })
     */
    upsert<T extends MedicineNameAddUpsertArgs>(args: SelectSubset<T, MedicineNameAddUpsertArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineNameAdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddCountArgs} args - Arguments to filter MedicineNameAdds to count.
     * @example
     * // Count the number of MedicineNameAdds
     * const count = await prisma.medicineNameAdd.count({
     *   where: {
     *     // ... the filter for the MedicineNameAdds we want to count
     *   }
     * })
    **/
    count<T extends MedicineNameAddCountArgs>(
      args?: Subset<T, MedicineNameAddCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineNameAddCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineNameAdd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineNameAddAggregateArgs>(args: Subset<T, MedicineNameAddAggregateArgs>): Prisma.PrismaPromise<GetMedicineNameAddAggregateType<T>>

    /**
     * Group by MedicineNameAdd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineNameAddGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineNameAddGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineNameAddGroupByArgs['orderBy'] }
        : { orderBy?: MedicineNameAddGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineNameAddGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineNameAddGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineNameAdd model
   */
  readonly fields: MedicineNameAddFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineNameAdd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineNameAddClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicineCategory<T extends AllGenericMedicinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicinDefaultArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicineStock<T extends MedicineNameAdd$medicineStockArgs<ExtArgs> = {}>(args?: Subset<T, MedicineNameAdd$medicineStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicinePurchess<T extends MedicineNameAdd$medicinePurchessArgs<ExtArgs> = {}>(args?: Subset<T, MedicineNameAdd$medicinePurchessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineNameAdd model
   */
  interface MedicineNameAddFieldRefs {
    readonly id: FieldRef<"MedicineNameAdd", 'String'>
    readonly name: FieldRef<"MedicineNameAdd", 'String'>
    readonly conpany: FieldRef<"MedicineNameAdd", 'String'>
    readonly genericName: FieldRef<"MedicineNameAdd", 'String'>
    readonly createdAt: FieldRef<"MedicineNameAdd", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineNameAdd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineNameAdd findUnique
   */
  export type MedicineNameAddFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter, which MedicineNameAdd to fetch.
     */
    where: MedicineNameAddWhereUniqueInput
  }

  /**
   * MedicineNameAdd findUniqueOrThrow
   */
  export type MedicineNameAddFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter, which MedicineNameAdd to fetch.
     */
    where: MedicineNameAddWhereUniqueInput
  }

  /**
   * MedicineNameAdd findFirst
   */
  export type MedicineNameAddFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter, which MedicineNameAdd to fetch.
     */
    where?: MedicineNameAddWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineNameAdds to fetch.
     */
    orderBy?: MedicineNameAddOrderByWithRelationInput | MedicineNameAddOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineNameAdds.
     */
    cursor?: MedicineNameAddWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineNameAdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineNameAdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineNameAdds.
     */
    distinct?: MedicineNameAddScalarFieldEnum | MedicineNameAddScalarFieldEnum[]
  }

  /**
   * MedicineNameAdd findFirstOrThrow
   */
  export type MedicineNameAddFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter, which MedicineNameAdd to fetch.
     */
    where?: MedicineNameAddWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineNameAdds to fetch.
     */
    orderBy?: MedicineNameAddOrderByWithRelationInput | MedicineNameAddOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineNameAdds.
     */
    cursor?: MedicineNameAddWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineNameAdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineNameAdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineNameAdds.
     */
    distinct?: MedicineNameAddScalarFieldEnum | MedicineNameAddScalarFieldEnum[]
  }

  /**
   * MedicineNameAdd findMany
   */
  export type MedicineNameAddFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter, which MedicineNameAdds to fetch.
     */
    where?: MedicineNameAddWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineNameAdds to fetch.
     */
    orderBy?: MedicineNameAddOrderByWithRelationInput | MedicineNameAddOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineNameAdds.
     */
    cursor?: MedicineNameAddWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineNameAdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineNameAdds.
     */
    skip?: number
    distinct?: MedicineNameAddScalarFieldEnum | MedicineNameAddScalarFieldEnum[]
  }

  /**
   * MedicineNameAdd create
   */
  export type MedicineNameAddCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineNameAdd.
     */
    data: XOR<MedicineNameAddCreateInput, MedicineNameAddUncheckedCreateInput>
  }

  /**
   * MedicineNameAdd createMany
   */
  export type MedicineNameAddCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineNameAdds.
     */
    data: MedicineNameAddCreateManyInput | MedicineNameAddCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineNameAdd createManyAndReturn
   */
  export type MedicineNameAddCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineNameAdds.
     */
    data: MedicineNameAddCreateManyInput | MedicineNameAddCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineNameAdd update
   */
  export type MedicineNameAddUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineNameAdd.
     */
    data: XOR<MedicineNameAddUpdateInput, MedicineNameAddUncheckedUpdateInput>
    /**
     * Choose, which MedicineNameAdd to update.
     */
    where: MedicineNameAddWhereUniqueInput
  }

  /**
   * MedicineNameAdd updateMany
   */
  export type MedicineNameAddUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineNameAdds.
     */
    data: XOR<MedicineNameAddUpdateManyMutationInput, MedicineNameAddUncheckedUpdateManyInput>
    /**
     * Filter which MedicineNameAdds to update
     */
    where?: MedicineNameAddWhereInput
    /**
     * Limit how many MedicineNameAdds to update.
     */
    limit?: number
  }

  /**
   * MedicineNameAdd updateManyAndReturn
   */
  export type MedicineNameAddUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * The data used to update MedicineNameAdds.
     */
    data: XOR<MedicineNameAddUpdateManyMutationInput, MedicineNameAddUncheckedUpdateManyInput>
    /**
     * Filter which MedicineNameAdds to update
     */
    where?: MedicineNameAddWhereInput
    /**
     * Limit how many MedicineNameAdds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineNameAdd upsert
   */
  export type MedicineNameAddUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineNameAdd to update in case it exists.
     */
    where: MedicineNameAddWhereUniqueInput
    /**
     * In case the MedicineNameAdd found by the `where` argument doesn't exist, create a new MedicineNameAdd with this data.
     */
    create: XOR<MedicineNameAddCreateInput, MedicineNameAddUncheckedCreateInput>
    /**
     * In case the MedicineNameAdd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineNameAddUpdateInput, MedicineNameAddUncheckedUpdateInput>
  }

  /**
   * MedicineNameAdd delete
   */
  export type MedicineNameAddDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
    /**
     * Filter which MedicineNameAdd to delete.
     */
    where: MedicineNameAddWhereUniqueInput
  }

  /**
   * MedicineNameAdd deleteMany
   */
  export type MedicineNameAddDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineNameAdds to delete
     */
    where?: MedicineNameAddWhereInput
    /**
     * Limit how many MedicineNameAdds to delete.
     */
    limit?: number
  }

  /**
   * MedicineNameAdd.medicineStock
   */
  export type MedicineNameAdd$medicineStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    where?: MedicineStockWhereInput
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    cursor?: MedicineStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * MedicineNameAdd.medicinePurchess
   */
  export type MedicineNameAdd$medicinePurchessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    where?: MedicinePurchessWhereInput
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    cursor?: MedicinePurchessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * MedicineNameAdd without action
   */
  export type MedicineNameAddDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineNameAdd
     */
    select?: MedicineNameAddSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineNameAdd
     */
    omit?: MedicineNameAddOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineNameAddInclude<ExtArgs> | null
  }


  /**
   * Model MedicinePurchess
   */

  export type AggregateMedicinePurchess = {
    _count: MedicinePurchessCountAggregateOutputType | null
    _avg: MedicinePurchessAvgAggregateOutputType | null
    _sum: MedicinePurchessSumAggregateOutputType | null
    _min: MedicinePurchessMinAggregateOutputType | null
    _max: MedicinePurchessMaxAggregateOutputType | null
  }

  export type MedicinePurchessAvgAggregateOutputType = {
    purchaseUnitPrice: number | null
    sellUnitPrice: number | null
    purchaseQuantity: number | null
    bonusQuantity: number | null
    purchaseTotalPrice: number | null
  }

  export type MedicinePurchessSumAggregateOutputType = {
    purchaseUnitPrice: number | null
    sellUnitPrice: number | null
    purchaseQuantity: number | null
    bonusQuantity: number | null
    purchaseTotalPrice: number | null
  }

  export type MedicinePurchessMinAggregateOutputType = {
    id: string | null
    genericName: string | null
    name: string | null
    purchaseUnitPrice: number | null
    sellUnitPrice: number | null
    purchaseQuantity: number | null
    mfgDate: string | null
    expDate: string | null
    bonusQuantity: number | null
    purchaseTotalPrice: number | null
    supplierInfo: string | null
    stored: $Enums.Stored | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicinePurchessMaxAggregateOutputType = {
    id: string | null
    genericName: string | null
    name: string | null
    purchaseUnitPrice: number | null
    sellUnitPrice: number | null
    purchaseQuantity: number | null
    mfgDate: string | null
    expDate: string | null
    bonusQuantity: number | null
    purchaseTotalPrice: number | null
    supplierInfo: string | null
    stored: $Enums.Stored | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicinePurchessCountAggregateOutputType = {
    id: number
    genericName: number
    name: number
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: number
    expDate: number
    bonusQuantity: number
    purchaseTotalPrice: number
    supplierInfo: number
    stored: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicinePurchessAvgAggregateInputType = {
    purchaseUnitPrice?: true
    sellUnitPrice?: true
    purchaseQuantity?: true
    bonusQuantity?: true
    purchaseTotalPrice?: true
  }

  export type MedicinePurchessSumAggregateInputType = {
    purchaseUnitPrice?: true
    sellUnitPrice?: true
    purchaseQuantity?: true
    bonusQuantity?: true
    purchaseTotalPrice?: true
  }

  export type MedicinePurchessMinAggregateInputType = {
    id?: true
    genericName?: true
    name?: true
    purchaseUnitPrice?: true
    sellUnitPrice?: true
    purchaseQuantity?: true
    mfgDate?: true
    expDate?: true
    bonusQuantity?: true
    purchaseTotalPrice?: true
    supplierInfo?: true
    stored?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicinePurchessMaxAggregateInputType = {
    id?: true
    genericName?: true
    name?: true
    purchaseUnitPrice?: true
    sellUnitPrice?: true
    purchaseQuantity?: true
    mfgDate?: true
    expDate?: true
    bonusQuantity?: true
    purchaseTotalPrice?: true
    supplierInfo?: true
    stored?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicinePurchessCountAggregateInputType = {
    id?: true
    genericName?: true
    name?: true
    purchaseUnitPrice?: true
    sellUnitPrice?: true
    purchaseQuantity?: true
    mfgDate?: true
    expDate?: true
    bonusQuantity?: true
    purchaseTotalPrice?: true
    supplierInfo?: true
    stored?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicinePurchessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicinePurchess to aggregate.
     */
    where?: MedicinePurchessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicinePurchesses to fetch.
     */
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicinePurchessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicinePurchesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicinePurchesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicinePurchesses
    **/
    _count?: true | MedicinePurchessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicinePurchessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicinePurchessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicinePurchessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicinePurchessMaxAggregateInputType
  }

  export type GetMedicinePurchessAggregateType<T extends MedicinePurchessAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicinePurchess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicinePurchess[P]>
      : GetScalarType<T[P], AggregateMedicinePurchess[P]>
  }




  export type MedicinePurchessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicinePurchessWhereInput
    orderBy?: MedicinePurchessOrderByWithAggregationInput | MedicinePurchessOrderByWithAggregationInput[]
    by: MedicinePurchessScalarFieldEnum[] | MedicinePurchessScalarFieldEnum
    having?: MedicinePurchessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicinePurchessCountAggregateInputType | true
    _avg?: MedicinePurchessAvgAggregateInputType
    _sum?: MedicinePurchessSumAggregateInputType
    _min?: MedicinePurchessMinAggregateInputType
    _max?: MedicinePurchessMaxAggregateInputType
  }

  export type MedicinePurchessGroupByOutputType = {
    id: string
    genericName: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored: $Enums.Stored
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: MedicinePurchessCountAggregateOutputType | null
    _avg: MedicinePurchessAvgAggregateOutputType | null
    _sum: MedicinePurchessSumAggregateOutputType | null
    _min: MedicinePurchessMinAggregateOutputType | null
    _max: MedicinePurchessMaxAggregateOutputType | null
  }

  type GetMedicinePurchessGroupByPayload<T extends MedicinePurchessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicinePurchessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicinePurchessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicinePurchessGroupByOutputType[P]>
            : GetScalarType<T[P], MedicinePurchessGroupByOutputType[P]>
        }
      >
    >


  export type MedicinePurchessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    name?: boolean
    purchaseUnitPrice?: boolean
    sellUnitPrice?: boolean
    purchaseQuantity?: boolean
    mfgDate?: boolean
    expDate?: boolean
    bonusQuantity?: boolean
    purchaseTotalPrice?: boolean
    supplierInfo?: boolean
    stored?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicinePurchess"]>

  export type MedicinePurchessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    name?: boolean
    purchaseUnitPrice?: boolean
    sellUnitPrice?: boolean
    purchaseQuantity?: boolean
    mfgDate?: boolean
    expDate?: boolean
    bonusQuantity?: boolean
    purchaseTotalPrice?: boolean
    supplierInfo?: boolean
    stored?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicinePurchess"]>

  export type MedicinePurchessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    name?: boolean
    purchaseUnitPrice?: boolean
    sellUnitPrice?: boolean
    purchaseQuantity?: boolean
    mfgDate?: boolean
    expDate?: boolean
    bonusQuantity?: boolean
    purchaseTotalPrice?: boolean
    supplierInfo?: boolean
    stored?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicinePurchess"]>

  export type MedicinePurchessSelectScalar = {
    id?: boolean
    genericName?: boolean
    name?: boolean
    purchaseUnitPrice?: boolean
    sellUnitPrice?: boolean
    purchaseQuantity?: boolean
    mfgDate?: boolean
    expDate?: boolean
    bonusQuantity?: boolean
    purchaseTotalPrice?: boolean
    supplierInfo?: boolean
    stored?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicinePurchessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "genericName" | "name" | "purchaseUnitPrice" | "sellUnitPrice" | "purchaseQuantity" | "mfgDate" | "expDate" | "bonusQuantity" | "purchaseTotalPrice" | "supplierInfo" | "stored" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["medicinePurchess"]>
  export type MedicinePurchessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicinePurchessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicinePurchessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $MedicinePurchessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicinePurchess"
    objects: {
      medicineCategory: Prisma.$AllGenericMedicinPayload<ExtArgs>
      medicineNameAdd: Prisma.$MedicineNameAddPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      genericName: string
      name: string
      purchaseUnitPrice: number
      sellUnitPrice: number
      purchaseQuantity: number
      mfgDate: string
      expDate: string
      bonusQuantity: number | null
      purchaseTotalPrice: number
      supplierInfo: string
      stored: $Enums.Stored
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicinePurchess"]>
    composites: {}
  }

  type MedicinePurchessGetPayload<S extends boolean | null | undefined | MedicinePurchessDefaultArgs> = $Result.GetResult<Prisma.$MedicinePurchessPayload, S>

  type MedicinePurchessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicinePurchessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicinePurchessCountAggregateInputType | true
    }

  export interface MedicinePurchessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicinePurchess'], meta: { name: 'MedicinePurchess' } }
    /**
     * Find zero or one MedicinePurchess that matches the filter.
     * @param {MedicinePurchessFindUniqueArgs} args - Arguments to find a MedicinePurchess
     * @example
     * // Get one MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicinePurchessFindUniqueArgs>(args: SelectSubset<T, MedicinePurchessFindUniqueArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicinePurchess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicinePurchessFindUniqueOrThrowArgs} args - Arguments to find a MedicinePurchess
     * @example
     * // Get one MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicinePurchessFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicinePurchessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicinePurchess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessFindFirstArgs} args - Arguments to find a MedicinePurchess
     * @example
     * // Get one MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicinePurchessFindFirstArgs>(args?: SelectSubset<T, MedicinePurchessFindFirstArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicinePurchess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessFindFirstOrThrowArgs} args - Arguments to find a MedicinePurchess
     * @example
     * // Get one MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicinePurchessFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicinePurchessFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicinePurchesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicinePurchesses
     * const medicinePurchesses = await prisma.medicinePurchess.findMany()
     * 
     * // Get first 10 MedicinePurchesses
     * const medicinePurchesses = await prisma.medicinePurchess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicinePurchessWithIdOnly = await prisma.medicinePurchess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicinePurchessFindManyArgs>(args?: SelectSubset<T, MedicinePurchessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicinePurchess.
     * @param {MedicinePurchessCreateArgs} args - Arguments to create a MedicinePurchess.
     * @example
     * // Create one MedicinePurchess
     * const MedicinePurchess = await prisma.medicinePurchess.create({
     *   data: {
     *     // ... data to create a MedicinePurchess
     *   }
     * })
     * 
     */
    create<T extends MedicinePurchessCreateArgs>(args: SelectSubset<T, MedicinePurchessCreateArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicinePurchesses.
     * @param {MedicinePurchessCreateManyArgs} args - Arguments to create many MedicinePurchesses.
     * @example
     * // Create many MedicinePurchesses
     * const medicinePurchess = await prisma.medicinePurchess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicinePurchessCreateManyArgs>(args?: SelectSubset<T, MedicinePurchessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicinePurchesses and returns the data saved in the database.
     * @param {MedicinePurchessCreateManyAndReturnArgs} args - Arguments to create many MedicinePurchesses.
     * @example
     * // Create many MedicinePurchesses
     * const medicinePurchess = await prisma.medicinePurchess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicinePurchesses and only return the `id`
     * const medicinePurchessWithIdOnly = await prisma.medicinePurchess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicinePurchessCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicinePurchessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicinePurchess.
     * @param {MedicinePurchessDeleteArgs} args - Arguments to delete one MedicinePurchess.
     * @example
     * // Delete one MedicinePurchess
     * const MedicinePurchess = await prisma.medicinePurchess.delete({
     *   where: {
     *     // ... filter to delete one MedicinePurchess
     *   }
     * })
     * 
     */
    delete<T extends MedicinePurchessDeleteArgs>(args: SelectSubset<T, MedicinePurchessDeleteArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicinePurchess.
     * @param {MedicinePurchessUpdateArgs} args - Arguments to update one MedicinePurchess.
     * @example
     * // Update one MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicinePurchessUpdateArgs>(args: SelectSubset<T, MedicinePurchessUpdateArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicinePurchesses.
     * @param {MedicinePurchessDeleteManyArgs} args - Arguments to filter MedicinePurchesses to delete.
     * @example
     * // Delete a few MedicinePurchesses
     * const { count } = await prisma.medicinePurchess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicinePurchessDeleteManyArgs>(args?: SelectSubset<T, MedicinePurchessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicinePurchesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicinePurchesses
     * const medicinePurchess = await prisma.medicinePurchess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicinePurchessUpdateManyArgs>(args: SelectSubset<T, MedicinePurchessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicinePurchesses and returns the data updated in the database.
     * @param {MedicinePurchessUpdateManyAndReturnArgs} args - Arguments to update many MedicinePurchesses.
     * @example
     * // Update many MedicinePurchesses
     * const medicinePurchess = await prisma.medicinePurchess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicinePurchesses and only return the `id`
     * const medicinePurchessWithIdOnly = await prisma.medicinePurchess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicinePurchessUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicinePurchessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicinePurchess.
     * @param {MedicinePurchessUpsertArgs} args - Arguments to update or create a MedicinePurchess.
     * @example
     * // Update or create a MedicinePurchess
     * const medicinePurchess = await prisma.medicinePurchess.upsert({
     *   create: {
     *     // ... data to create a MedicinePurchess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicinePurchess we want to update
     *   }
     * })
     */
    upsert<T extends MedicinePurchessUpsertArgs>(args: SelectSubset<T, MedicinePurchessUpsertArgs<ExtArgs>>): Prisma__MedicinePurchessClient<$Result.GetResult<Prisma.$MedicinePurchessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicinePurchesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessCountArgs} args - Arguments to filter MedicinePurchesses to count.
     * @example
     * // Count the number of MedicinePurchesses
     * const count = await prisma.medicinePurchess.count({
     *   where: {
     *     // ... the filter for the MedicinePurchesses we want to count
     *   }
     * })
    **/
    count<T extends MedicinePurchessCountArgs>(
      args?: Subset<T, MedicinePurchessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicinePurchessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicinePurchess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicinePurchessAggregateArgs>(args: Subset<T, MedicinePurchessAggregateArgs>): Prisma.PrismaPromise<GetMedicinePurchessAggregateType<T>>

    /**
     * Group by MedicinePurchess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicinePurchessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicinePurchessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicinePurchessGroupByArgs['orderBy'] }
        : { orderBy?: MedicinePurchessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicinePurchessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicinePurchessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicinePurchess model
   */
  readonly fields: MedicinePurchessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicinePurchess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicinePurchessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicineCategory<T extends AllGenericMedicinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicinDefaultArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicineNameAdd<T extends MedicineNameAddDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineNameAddDefaultArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicinePurchess model
   */
  interface MedicinePurchessFieldRefs {
    readonly id: FieldRef<"MedicinePurchess", 'String'>
    readonly genericName: FieldRef<"MedicinePurchess", 'String'>
    readonly name: FieldRef<"MedicinePurchess", 'String'>
    readonly purchaseUnitPrice: FieldRef<"MedicinePurchess", 'Int'>
    readonly sellUnitPrice: FieldRef<"MedicinePurchess", 'Int'>
    readonly purchaseQuantity: FieldRef<"MedicinePurchess", 'Int'>
    readonly mfgDate: FieldRef<"MedicinePurchess", 'String'>
    readonly expDate: FieldRef<"MedicinePurchess", 'String'>
    readonly bonusQuantity: FieldRef<"MedicinePurchess", 'Int'>
    readonly purchaseTotalPrice: FieldRef<"MedicinePurchess", 'Int'>
    readonly supplierInfo: FieldRef<"MedicinePurchess", 'String'>
    readonly stored: FieldRef<"MedicinePurchess", 'Stored'>
    readonly branchCode: FieldRef<"MedicinePurchess", 'String'>
    readonly createdAt: FieldRef<"MedicinePurchess", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicinePurchess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicinePurchess findUnique
   */
  export type MedicinePurchessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter, which MedicinePurchess to fetch.
     */
    where: MedicinePurchessWhereUniqueInput
  }

  /**
   * MedicinePurchess findUniqueOrThrow
   */
  export type MedicinePurchessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter, which MedicinePurchess to fetch.
     */
    where: MedicinePurchessWhereUniqueInput
  }

  /**
   * MedicinePurchess findFirst
   */
  export type MedicinePurchessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter, which MedicinePurchess to fetch.
     */
    where?: MedicinePurchessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicinePurchesses to fetch.
     */
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicinePurchesses.
     */
    cursor?: MedicinePurchessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicinePurchesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicinePurchesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicinePurchesses.
     */
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * MedicinePurchess findFirstOrThrow
   */
  export type MedicinePurchessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter, which MedicinePurchess to fetch.
     */
    where?: MedicinePurchessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicinePurchesses to fetch.
     */
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicinePurchesses.
     */
    cursor?: MedicinePurchessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicinePurchesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicinePurchesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicinePurchesses.
     */
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * MedicinePurchess findMany
   */
  export type MedicinePurchessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter, which MedicinePurchesses to fetch.
     */
    where?: MedicinePurchessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicinePurchesses to fetch.
     */
    orderBy?: MedicinePurchessOrderByWithRelationInput | MedicinePurchessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicinePurchesses.
     */
    cursor?: MedicinePurchessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicinePurchesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicinePurchesses.
     */
    skip?: number
    distinct?: MedicinePurchessScalarFieldEnum | MedicinePurchessScalarFieldEnum[]
  }

  /**
   * MedicinePurchess create
   */
  export type MedicinePurchessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicinePurchess.
     */
    data: XOR<MedicinePurchessCreateInput, MedicinePurchessUncheckedCreateInput>
  }

  /**
   * MedicinePurchess createMany
   */
  export type MedicinePurchessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicinePurchesses.
     */
    data: MedicinePurchessCreateManyInput | MedicinePurchessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicinePurchess createManyAndReturn
   */
  export type MedicinePurchessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * The data used to create many MedicinePurchesses.
     */
    data: MedicinePurchessCreateManyInput | MedicinePurchessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicinePurchess update
   */
  export type MedicinePurchessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicinePurchess.
     */
    data: XOR<MedicinePurchessUpdateInput, MedicinePurchessUncheckedUpdateInput>
    /**
     * Choose, which MedicinePurchess to update.
     */
    where: MedicinePurchessWhereUniqueInput
  }

  /**
   * MedicinePurchess updateMany
   */
  export type MedicinePurchessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicinePurchesses.
     */
    data: XOR<MedicinePurchessUpdateManyMutationInput, MedicinePurchessUncheckedUpdateManyInput>
    /**
     * Filter which MedicinePurchesses to update
     */
    where?: MedicinePurchessWhereInput
    /**
     * Limit how many MedicinePurchesses to update.
     */
    limit?: number
  }

  /**
   * MedicinePurchess updateManyAndReturn
   */
  export type MedicinePurchessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * The data used to update MedicinePurchesses.
     */
    data: XOR<MedicinePurchessUpdateManyMutationInput, MedicinePurchessUncheckedUpdateManyInput>
    /**
     * Filter which MedicinePurchesses to update
     */
    where?: MedicinePurchessWhereInput
    /**
     * Limit how many MedicinePurchesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicinePurchess upsert
   */
  export type MedicinePurchessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicinePurchess to update in case it exists.
     */
    where: MedicinePurchessWhereUniqueInput
    /**
     * In case the MedicinePurchess found by the `where` argument doesn't exist, create a new MedicinePurchess with this data.
     */
    create: XOR<MedicinePurchessCreateInput, MedicinePurchessUncheckedCreateInput>
    /**
     * In case the MedicinePurchess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicinePurchessUpdateInput, MedicinePurchessUncheckedUpdateInput>
  }

  /**
   * MedicinePurchess delete
   */
  export type MedicinePurchessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
    /**
     * Filter which MedicinePurchess to delete.
     */
    where: MedicinePurchessWhereUniqueInput
  }

  /**
   * MedicinePurchess deleteMany
   */
  export type MedicinePurchessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicinePurchesses to delete
     */
    where?: MedicinePurchessWhereInput
    /**
     * Limit how many MedicinePurchesses to delete.
     */
    limit?: number
  }

  /**
   * MedicinePurchess without action
   */
  export type MedicinePurchessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicinePurchess
     */
    select?: MedicinePurchessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicinePurchess
     */
    omit?: MedicinePurchessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicinePurchessInclude<ExtArgs> | null
  }


  /**
   * Model MedicineStock
   */

  export type AggregateMedicineStock = {
    _count: MedicineStockCountAggregateOutputType | null
    _avg: MedicineStockAvgAggregateOutputType | null
    _sum: MedicineStockSumAggregateOutputType | null
    _min: MedicineStockMinAggregateOutputType | null
    _max: MedicineStockMaxAggregateOutputType | null
  }

  export type MedicineStockAvgAggregateOutputType = {
    totalStock: number | null
    price: number | null
  }

  export type MedicineStockSumAggregateOutputType = {
    totalStock: number | null
    price: number | null
  }

  export type MedicineStockMinAggregateOutputType = {
    id: string | null
    genericName: string | null
    medicineName: string | null
    branchCode: string | null
    totalStock: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineStockMaxAggregateOutputType = {
    id: string | null
    genericName: string | null
    medicineName: string | null
    branchCode: string | null
    totalStock: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineStockCountAggregateOutputType = {
    id: number
    genericName: number
    medicineName: number
    branchCode: number
    totalStock: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineStockAvgAggregateInputType = {
    totalStock?: true
    price?: true
  }

  export type MedicineStockSumAggregateInputType = {
    totalStock?: true
    price?: true
  }

  export type MedicineStockMinAggregateInputType = {
    id?: true
    genericName?: true
    medicineName?: true
    branchCode?: true
    totalStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineStockMaxAggregateInputType = {
    id?: true
    genericName?: true
    medicineName?: true
    branchCode?: true
    totalStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineStockCountAggregateInputType = {
    id?: true
    genericName?: true
    medicineName?: true
    branchCode?: true
    totalStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineStock to aggregate.
     */
    where?: MedicineStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineStocks to fetch.
     */
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineStocks
    **/
    _count?: true | MedicineStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineStockMaxAggregateInputType
  }

  export type GetMedicineStockAggregateType<T extends MedicineStockAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineStock[P]>
      : GetScalarType<T[P], AggregateMedicineStock[P]>
  }




  export type MedicineStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineStockWhereInput
    orderBy?: MedicineStockOrderByWithAggregationInput | MedicineStockOrderByWithAggregationInput[]
    by: MedicineStockScalarFieldEnum[] | MedicineStockScalarFieldEnum
    having?: MedicineStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineStockCountAggregateInputType | true
    _avg?: MedicineStockAvgAggregateInputType
    _sum?: MedicineStockSumAggregateInputType
    _min?: MedicineStockMinAggregateInputType
    _max?: MedicineStockMaxAggregateInputType
  }

  export type MedicineStockGroupByOutputType = {
    id: string
    genericName: string
    medicineName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: MedicineStockCountAggregateOutputType | null
    _avg: MedicineStockAvgAggregateOutputType | null
    _sum: MedicineStockSumAggregateOutputType | null
    _min: MedicineStockMinAggregateOutputType | null
    _max: MedicineStockMaxAggregateOutputType | null
  }

  type GetMedicineStockGroupByPayload<T extends MedicineStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineStockGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineStockGroupByOutputType[P]>
        }
      >
    >


  export type MedicineStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    medicineName?: boolean
    branchCode?: boolean
    totalStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineStock"]>

  export type MedicineStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    medicineName?: boolean
    branchCode?: boolean
    totalStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineStock"]>

  export type MedicineStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genericName?: boolean
    medicineName?: boolean
    branchCode?: boolean
    totalStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineStock"]>

  export type MedicineStockSelectScalar = {
    id?: boolean
    genericName?: boolean
    medicineName?: boolean
    branchCode?: boolean
    totalStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "genericName" | "medicineName" | "branchCode" | "totalStock" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineStock"]>
  export type MedicineStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicineStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicineStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicineNameAdd?: boolean | MedicineNameAddDefaultArgs<ExtArgs>
    medicineCategory?: boolean | AllGenericMedicinDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $MedicineStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineStock"
    objects: {
      medicineNameAdd: Prisma.$MedicineNameAddPayload<ExtArgs>
      medicineCategory: Prisma.$AllGenericMedicinPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      genericName: string
      medicineName: string
      branchCode: string
      totalStock: number
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineStock"]>
    composites: {}
  }

  type MedicineStockGetPayload<S extends boolean | null | undefined | MedicineStockDefaultArgs> = $Result.GetResult<Prisma.$MedicineStockPayload, S>

  type MedicineStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineStockCountAggregateInputType | true
    }

  export interface MedicineStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineStock'], meta: { name: 'MedicineStock' } }
    /**
     * Find zero or one MedicineStock that matches the filter.
     * @param {MedicineStockFindUniqueArgs} args - Arguments to find a MedicineStock
     * @example
     * // Get one MedicineStock
     * const medicineStock = await prisma.medicineStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineStockFindUniqueArgs>(args: SelectSubset<T, MedicineStockFindUniqueArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineStockFindUniqueOrThrowArgs} args - Arguments to find a MedicineStock
     * @example
     * // Get one MedicineStock
     * const medicineStock = await prisma.medicineStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineStockFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockFindFirstArgs} args - Arguments to find a MedicineStock
     * @example
     * // Get one MedicineStock
     * const medicineStock = await prisma.medicineStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineStockFindFirstArgs>(args?: SelectSubset<T, MedicineStockFindFirstArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockFindFirstOrThrowArgs} args - Arguments to find a MedicineStock
     * @example
     * // Get one MedicineStock
     * const medicineStock = await prisma.medicineStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineStockFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineStocks
     * const medicineStocks = await prisma.medicineStock.findMany()
     * 
     * // Get first 10 MedicineStocks
     * const medicineStocks = await prisma.medicineStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineStockWithIdOnly = await prisma.medicineStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineStockFindManyArgs>(args?: SelectSubset<T, MedicineStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineStock.
     * @param {MedicineStockCreateArgs} args - Arguments to create a MedicineStock.
     * @example
     * // Create one MedicineStock
     * const MedicineStock = await prisma.medicineStock.create({
     *   data: {
     *     // ... data to create a MedicineStock
     *   }
     * })
     * 
     */
    create<T extends MedicineStockCreateArgs>(args: SelectSubset<T, MedicineStockCreateArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineStocks.
     * @param {MedicineStockCreateManyArgs} args - Arguments to create many MedicineStocks.
     * @example
     * // Create many MedicineStocks
     * const medicineStock = await prisma.medicineStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineStockCreateManyArgs>(args?: SelectSubset<T, MedicineStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineStocks and returns the data saved in the database.
     * @param {MedicineStockCreateManyAndReturnArgs} args - Arguments to create many MedicineStocks.
     * @example
     * // Create many MedicineStocks
     * const medicineStock = await prisma.medicineStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineStocks and only return the `id`
     * const medicineStockWithIdOnly = await prisma.medicineStock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineStockCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineStock.
     * @param {MedicineStockDeleteArgs} args - Arguments to delete one MedicineStock.
     * @example
     * // Delete one MedicineStock
     * const MedicineStock = await prisma.medicineStock.delete({
     *   where: {
     *     // ... filter to delete one MedicineStock
     *   }
     * })
     * 
     */
    delete<T extends MedicineStockDeleteArgs>(args: SelectSubset<T, MedicineStockDeleteArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineStock.
     * @param {MedicineStockUpdateArgs} args - Arguments to update one MedicineStock.
     * @example
     * // Update one MedicineStock
     * const medicineStock = await prisma.medicineStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineStockUpdateArgs>(args: SelectSubset<T, MedicineStockUpdateArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineStocks.
     * @param {MedicineStockDeleteManyArgs} args - Arguments to filter MedicineStocks to delete.
     * @example
     * // Delete a few MedicineStocks
     * const { count } = await prisma.medicineStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineStockDeleteManyArgs>(args?: SelectSubset<T, MedicineStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineStocks
     * const medicineStock = await prisma.medicineStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineStockUpdateManyArgs>(args: SelectSubset<T, MedicineStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineStocks and returns the data updated in the database.
     * @param {MedicineStockUpdateManyAndReturnArgs} args - Arguments to update many MedicineStocks.
     * @example
     * // Update many MedicineStocks
     * const medicineStock = await prisma.medicineStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineStocks and only return the `id`
     * const medicineStockWithIdOnly = await prisma.medicineStock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineStockUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineStock.
     * @param {MedicineStockUpsertArgs} args - Arguments to update or create a MedicineStock.
     * @example
     * // Update or create a MedicineStock
     * const medicineStock = await prisma.medicineStock.upsert({
     *   create: {
     *     // ... data to create a MedicineStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineStock we want to update
     *   }
     * })
     */
    upsert<T extends MedicineStockUpsertArgs>(args: SelectSubset<T, MedicineStockUpsertArgs<ExtArgs>>): Prisma__MedicineStockClient<$Result.GetResult<Prisma.$MedicineStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockCountArgs} args - Arguments to filter MedicineStocks to count.
     * @example
     * // Count the number of MedicineStocks
     * const count = await prisma.medicineStock.count({
     *   where: {
     *     // ... the filter for the MedicineStocks we want to count
     *   }
     * })
    **/
    count<T extends MedicineStockCountArgs>(
      args?: Subset<T, MedicineStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineStockAggregateArgs>(args: Subset<T, MedicineStockAggregateArgs>): Prisma.PrismaPromise<GetMedicineStockAggregateType<T>>

    /**
     * Group by MedicineStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineStockGroupByArgs['orderBy'] }
        : { orderBy?: MedicineStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineStock model
   */
  readonly fields: MedicineStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicineNameAdd<T extends MedicineNameAddDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineNameAddDefaultArgs<ExtArgs>>): Prisma__MedicineNameAddClient<$Result.GetResult<Prisma.$MedicineNameAddPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicineCategory<T extends AllGenericMedicinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AllGenericMedicinDefaultArgs<ExtArgs>>): Prisma__AllGenericMedicinClient<$Result.GetResult<Prisma.$AllGenericMedicinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineStock model
   */
  interface MedicineStockFieldRefs {
    readonly id: FieldRef<"MedicineStock", 'String'>
    readonly genericName: FieldRef<"MedicineStock", 'String'>
    readonly medicineName: FieldRef<"MedicineStock", 'String'>
    readonly branchCode: FieldRef<"MedicineStock", 'String'>
    readonly totalStock: FieldRef<"MedicineStock", 'Int'>
    readonly price: FieldRef<"MedicineStock", 'Int'>
    readonly createdAt: FieldRef<"MedicineStock", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineStock findUnique
   */
  export type MedicineStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter, which MedicineStock to fetch.
     */
    where: MedicineStockWhereUniqueInput
  }

  /**
   * MedicineStock findUniqueOrThrow
   */
  export type MedicineStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter, which MedicineStock to fetch.
     */
    where: MedicineStockWhereUniqueInput
  }

  /**
   * MedicineStock findFirst
   */
  export type MedicineStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter, which MedicineStock to fetch.
     */
    where?: MedicineStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineStocks to fetch.
     */
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineStocks.
     */
    cursor?: MedicineStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineStocks.
     */
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * MedicineStock findFirstOrThrow
   */
  export type MedicineStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter, which MedicineStock to fetch.
     */
    where?: MedicineStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineStocks to fetch.
     */
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineStocks.
     */
    cursor?: MedicineStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineStocks.
     */
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * MedicineStock findMany
   */
  export type MedicineStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter, which MedicineStocks to fetch.
     */
    where?: MedicineStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineStocks to fetch.
     */
    orderBy?: MedicineStockOrderByWithRelationInput | MedicineStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineStocks.
     */
    cursor?: MedicineStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineStocks.
     */
    skip?: number
    distinct?: MedicineStockScalarFieldEnum | MedicineStockScalarFieldEnum[]
  }

  /**
   * MedicineStock create
   */
  export type MedicineStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineStock.
     */
    data: XOR<MedicineStockCreateInput, MedicineStockUncheckedCreateInput>
  }

  /**
   * MedicineStock createMany
   */
  export type MedicineStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineStocks.
     */
    data: MedicineStockCreateManyInput | MedicineStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineStock createManyAndReturn
   */
  export type MedicineStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineStocks.
     */
    data: MedicineStockCreateManyInput | MedicineStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineStock update
   */
  export type MedicineStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineStock.
     */
    data: XOR<MedicineStockUpdateInput, MedicineStockUncheckedUpdateInput>
    /**
     * Choose, which MedicineStock to update.
     */
    where: MedicineStockWhereUniqueInput
  }

  /**
   * MedicineStock updateMany
   */
  export type MedicineStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineStocks.
     */
    data: XOR<MedicineStockUpdateManyMutationInput, MedicineStockUncheckedUpdateManyInput>
    /**
     * Filter which MedicineStocks to update
     */
    where?: MedicineStockWhereInput
    /**
     * Limit how many MedicineStocks to update.
     */
    limit?: number
  }

  /**
   * MedicineStock updateManyAndReturn
   */
  export type MedicineStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * The data used to update MedicineStocks.
     */
    data: XOR<MedicineStockUpdateManyMutationInput, MedicineStockUncheckedUpdateManyInput>
    /**
     * Filter which MedicineStocks to update
     */
    where?: MedicineStockWhereInput
    /**
     * Limit how many MedicineStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineStock upsert
   */
  export type MedicineStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineStock to update in case it exists.
     */
    where: MedicineStockWhereUniqueInput
    /**
     * In case the MedicineStock found by the `where` argument doesn't exist, create a new MedicineStock with this data.
     */
    create: XOR<MedicineStockCreateInput, MedicineStockUncheckedCreateInput>
    /**
     * In case the MedicineStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineStockUpdateInput, MedicineStockUncheckedUpdateInput>
  }

  /**
   * MedicineStock delete
   */
  export type MedicineStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
    /**
     * Filter which MedicineStock to delete.
     */
    where: MedicineStockWhereUniqueInput
  }

  /**
   * MedicineStock deleteMany
   */
  export type MedicineStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineStocks to delete
     */
    where?: MedicineStockWhereInput
    /**
     * Limit how many MedicineStocks to delete.
     */
    limit?: number
  }

  /**
   * MedicineStock without action
   */
  export type MedicineStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineStock
     */
    select?: MedicineStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineStock
     */
    omit?: MedicineStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineStockInclude<ExtArgs> | null
  }


  /**
   * Model SellMedicine
   */

  export type AggregateSellMedicine = {
    _count: SellMedicineCountAggregateOutputType | null
    _avg: SellMedicineAvgAggregateOutputType | null
    _sum: SellMedicineSumAggregateOutputType | null
    _min: SellMedicineMinAggregateOutputType | null
    _max: SellMedicineMaxAggregateOutputType | null
  }

  export type SellMedicineAvgAggregateOutputType = {
    billNumber: number | null
    flockNumer: number | null
    sellQuantity: number | null
    sellPrice: number | null
  }

  export type SellMedicineSumAggregateOutputType = {
    billNumber: number | null
    flockNumer: number | null
    sellQuantity: number | null
    sellPrice: number | null
  }

  export type SellMedicineMinAggregateOutputType = {
    id: string | null
    billNumber: number | null
    farmId: string | null
    flockNumer: number | null
    genericName: string | null
    medicineName: string | null
    sellQuantity: number | null
    sellPrice: number | null
    Delivery: $Enums.DeliveryStatus | null
    sellDate: string | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellMedicineMaxAggregateOutputType = {
    id: string | null
    billNumber: number | null
    farmId: string | null
    flockNumer: number | null
    genericName: string | null
    medicineName: string | null
    sellQuantity: number | null
    sellPrice: number | null
    Delivery: $Enums.DeliveryStatus | null
    sellDate: string | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellMedicineCountAggregateOutputType = {
    id: number
    billNumber: number
    farmId: number
    flockNumer: number
    genericName: number
    medicineName: number
    sellQuantity: number
    sellPrice: number
    Delivery: number
    sellDate: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellMedicineAvgAggregateInputType = {
    billNumber?: true
    flockNumer?: true
    sellQuantity?: true
    sellPrice?: true
  }

  export type SellMedicineSumAggregateInputType = {
    billNumber?: true
    flockNumer?: true
    sellQuantity?: true
    sellPrice?: true
  }

  export type SellMedicineMinAggregateInputType = {
    id?: true
    billNumber?: true
    farmId?: true
    flockNumer?: true
    genericName?: true
    medicineName?: true
    sellQuantity?: true
    sellPrice?: true
    Delivery?: true
    sellDate?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellMedicineMaxAggregateInputType = {
    id?: true
    billNumber?: true
    farmId?: true
    flockNumer?: true
    genericName?: true
    medicineName?: true
    sellQuantity?: true
    sellPrice?: true
    Delivery?: true
    sellDate?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellMedicineCountAggregateInputType = {
    id?: true
    billNumber?: true
    farmId?: true
    flockNumer?: true
    genericName?: true
    medicineName?: true
    sellQuantity?: true
    sellPrice?: true
    Delivery?: true
    sellDate?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellMedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellMedicine to aggregate.
     */
    where?: SellMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellMedicines to fetch.
     */
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellMedicines
    **/
    _count?: true | SellMedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellMedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellMedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellMedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellMedicineMaxAggregateInputType
  }

  export type GetSellMedicineAggregateType<T extends SellMedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateSellMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellMedicine[P]>
      : GetScalarType<T[P], AggregateSellMedicine[P]>
  }




  export type SellMedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellMedicineWhereInput
    orderBy?: SellMedicineOrderByWithAggregationInput | SellMedicineOrderByWithAggregationInput[]
    by: SellMedicineScalarFieldEnum[] | SellMedicineScalarFieldEnum
    having?: SellMedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellMedicineCountAggregateInputType | true
    _avg?: SellMedicineAvgAggregateInputType
    _sum?: SellMedicineSumAggregateInputType
    _min?: SellMedicineMinAggregateInputType
    _max?: SellMedicineMaxAggregateInputType
  }

  export type SellMedicineGroupByOutputType = {
    id: string
    billNumber: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: SellMedicineCountAggregateOutputType | null
    _avg: SellMedicineAvgAggregateOutputType | null
    _sum: SellMedicineSumAggregateOutputType | null
    _min: SellMedicineMinAggregateOutputType | null
    _max: SellMedicineMaxAggregateOutputType | null
  }

  type GetSellMedicineGroupByPayload<T extends SellMedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellMedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellMedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellMedicineGroupByOutputType[P]>
            : GetScalarType<T[P], SellMedicineGroupByOutputType[P]>
        }
      >
    >


  export type SellMedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    farmId?: boolean
    flockNumer?: boolean
    genericName?: boolean
    medicineName?: boolean
    sellQuantity?: boolean
    sellPrice?: boolean
    Delivery?: boolean
    sellDate?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    MedicineTransfer?: boolean | SellMedicine$MedicineTransferArgs<ExtArgs>
    _count?: boolean | SellMedicineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellMedicine"]>

  export type SellMedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    farmId?: boolean
    flockNumer?: boolean
    genericName?: boolean
    medicineName?: boolean
    sellQuantity?: boolean
    sellPrice?: boolean
    Delivery?: boolean
    sellDate?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellMedicine"]>

  export type SellMedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    farmId?: boolean
    flockNumer?: boolean
    genericName?: boolean
    medicineName?: boolean
    sellQuantity?: boolean
    sellPrice?: boolean
    Delivery?: boolean
    sellDate?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellMedicine"]>

  export type SellMedicineSelectScalar = {
    id?: boolean
    billNumber?: boolean
    farmId?: boolean
    flockNumer?: boolean
    genericName?: boolean
    medicineName?: boolean
    sellQuantity?: boolean
    sellPrice?: boolean
    Delivery?: boolean
    sellDate?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellMedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billNumber" | "farmId" | "flockNumer" | "genericName" | "medicineName" | "sellQuantity" | "sellPrice" | "Delivery" | "sellDate" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["sellMedicine"]>
  export type SellMedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
    MedicineTransfer?: boolean | SellMedicine$MedicineTransferArgs<ExtArgs>
    _count?: boolean | SellMedicineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SellMedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }
  export type SellMedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    farmer?: boolean | FarmerDefaultArgs<ExtArgs>
  }

  export type $SellMedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellMedicine"
    objects: {
      flock: Prisma.$FlockPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      farmer: Prisma.$FarmerPayload<ExtArgs>
      MedicineTransfer: Prisma.$MedicineTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billNumber: number | null
      farmId: string
      flockNumer: number
      genericName: string
      medicineName: string
      sellQuantity: number
      sellPrice: number
      Delivery: $Enums.DeliveryStatus
      sellDate: string
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellMedicine"]>
    composites: {}
  }

  type SellMedicineGetPayload<S extends boolean | null | undefined | SellMedicineDefaultArgs> = $Result.GetResult<Prisma.$SellMedicinePayload, S>

  type SellMedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellMedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellMedicineCountAggregateInputType | true
    }

  export interface SellMedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellMedicine'], meta: { name: 'SellMedicine' } }
    /**
     * Find zero or one SellMedicine that matches the filter.
     * @param {SellMedicineFindUniqueArgs} args - Arguments to find a SellMedicine
     * @example
     * // Get one SellMedicine
     * const sellMedicine = await prisma.sellMedicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellMedicineFindUniqueArgs>(args: SelectSubset<T, SellMedicineFindUniqueArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellMedicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellMedicineFindUniqueOrThrowArgs} args - Arguments to find a SellMedicine
     * @example
     * // Get one SellMedicine
     * const sellMedicine = await prisma.sellMedicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellMedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, SellMedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellMedicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineFindFirstArgs} args - Arguments to find a SellMedicine
     * @example
     * // Get one SellMedicine
     * const sellMedicine = await prisma.sellMedicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellMedicineFindFirstArgs>(args?: SelectSubset<T, SellMedicineFindFirstArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellMedicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineFindFirstOrThrowArgs} args - Arguments to find a SellMedicine
     * @example
     * // Get one SellMedicine
     * const sellMedicine = await prisma.sellMedicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellMedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, SellMedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellMedicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellMedicines
     * const sellMedicines = await prisma.sellMedicine.findMany()
     * 
     * // Get first 10 SellMedicines
     * const sellMedicines = await prisma.sellMedicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellMedicineWithIdOnly = await prisma.sellMedicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellMedicineFindManyArgs>(args?: SelectSubset<T, SellMedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellMedicine.
     * @param {SellMedicineCreateArgs} args - Arguments to create a SellMedicine.
     * @example
     * // Create one SellMedicine
     * const SellMedicine = await prisma.sellMedicine.create({
     *   data: {
     *     // ... data to create a SellMedicine
     *   }
     * })
     * 
     */
    create<T extends SellMedicineCreateArgs>(args: SelectSubset<T, SellMedicineCreateArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellMedicines.
     * @param {SellMedicineCreateManyArgs} args - Arguments to create many SellMedicines.
     * @example
     * // Create many SellMedicines
     * const sellMedicine = await prisma.sellMedicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellMedicineCreateManyArgs>(args?: SelectSubset<T, SellMedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellMedicines and returns the data saved in the database.
     * @param {SellMedicineCreateManyAndReturnArgs} args - Arguments to create many SellMedicines.
     * @example
     * // Create many SellMedicines
     * const sellMedicine = await prisma.sellMedicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellMedicines and only return the `id`
     * const sellMedicineWithIdOnly = await prisma.sellMedicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellMedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, SellMedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellMedicine.
     * @param {SellMedicineDeleteArgs} args - Arguments to delete one SellMedicine.
     * @example
     * // Delete one SellMedicine
     * const SellMedicine = await prisma.sellMedicine.delete({
     *   where: {
     *     // ... filter to delete one SellMedicine
     *   }
     * })
     * 
     */
    delete<T extends SellMedicineDeleteArgs>(args: SelectSubset<T, SellMedicineDeleteArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellMedicine.
     * @param {SellMedicineUpdateArgs} args - Arguments to update one SellMedicine.
     * @example
     * // Update one SellMedicine
     * const sellMedicine = await prisma.sellMedicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellMedicineUpdateArgs>(args: SelectSubset<T, SellMedicineUpdateArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellMedicines.
     * @param {SellMedicineDeleteManyArgs} args - Arguments to filter SellMedicines to delete.
     * @example
     * // Delete a few SellMedicines
     * const { count } = await prisma.sellMedicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellMedicineDeleteManyArgs>(args?: SelectSubset<T, SellMedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellMedicines
     * const sellMedicine = await prisma.sellMedicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellMedicineUpdateManyArgs>(args: SelectSubset<T, SellMedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellMedicines and returns the data updated in the database.
     * @param {SellMedicineUpdateManyAndReturnArgs} args - Arguments to update many SellMedicines.
     * @example
     * // Update many SellMedicines
     * const sellMedicine = await prisma.sellMedicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellMedicines and only return the `id`
     * const sellMedicineWithIdOnly = await prisma.sellMedicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellMedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, SellMedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellMedicine.
     * @param {SellMedicineUpsertArgs} args - Arguments to update or create a SellMedicine.
     * @example
     * // Update or create a SellMedicine
     * const sellMedicine = await prisma.sellMedicine.upsert({
     *   create: {
     *     // ... data to create a SellMedicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellMedicine we want to update
     *   }
     * })
     */
    upsert<T extends SellMedicineUpsertArgs>(args: SelectSubset<T, SellMedicineUpsertArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellMedicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineCountArgs} args - Arguments to filter SellMedicines to count.
     * @example
     * // Count the number of SellMedicines
     * const count = await prisma.sellMedicine.count({
     *   where: {
     *     // ... the filter for the SellMedicines we want to count
     *   }
     * })
    **/
    count<T extends SellMedicineCountArgs>(
      args?: Subset<T, SellMedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellMedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellMedicineAggregateArgs>(args: Subset<T, SellMedicineAggregateArgs>): Prisma.PrismaPromise<GetSellMedicineAggregateType<T>>

    /**
     * Group by SellMedicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellMedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellMedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellMedicineGroupByArgs['orderBy'] }
        : { orderBy?: SellMedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellMedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellMedicine model
   */
  readonly fields: SellMedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellMedicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellMedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flock<T extends FlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlockDefaultArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    farmer<T extends FarmerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FarmerDefaultArgs<ExtArgs>>): Prisma__FarmerClient<$Result.GetResult<Prisma.$FarmerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MedicineTransfer<T extends SellMedicine$MedicineTransferArgs<ExtArgs> = {}>(args?: Subset<T, SellMedicine$MedicineTransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellMedicine model
   */
  interface SellMedicineFieldRefs {
    readonly id: FieldRef<"SellMedicine", 'String'>
    readonly billNumber: FieldRef<"SellMedicine", 'Int'>
    readonly farmId: FieldRef<"SellMedicine", 'String'>
    readonly flockNumer: FieldRef<"SellMedicine", 'Int'>
    readonly genericName: FieldRef<"SellMedicine", 'String'>
    readonly medicineName: FieldRef<"SellMedicine", 'String'>
    readonly sellQuantity: FieldRef<"SellMedicine", 'Int'>
    readonly sellPrice: FieldRef<"SellMedicine", 'Int'>
    readonly Delivery: FieldRef<"SellMedicine", 'DeliveryStatus'>
    readonly sellDate: FieldRef<"SellMedicine", 'String'>
    readonly branchCode: FieldRef<"SellMedicine", 'String'>
    readonly createdAt: FieldRef<"SellMedicine", 'DateTime'>
    readonly updatedAt: FieldRef<"SellMedicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellMedicine findUnique
   */
  export type SellMedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter, which SellMedicine to fetch.
     */
    where: SellMedicineWhereUniqueInput
  }

  /**
   * SellMedicine findUniqueOrThrow
   */
  export type SellMedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter, which SellMedicine to fetch.
     */
    where: SellMedicineWhereUniqueInput
  }

  /**
   * SellMedicine findFirst
   */
  export type SellMedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter, which SellMedicine to fetch.
     */
    where?: SellMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellMedicines to fetch.
     */
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellMedicines.
     */
    cursor?: SellMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellMedicines.
     */
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * SellMedicine findFirstOrThrow
   */
  export type SellMedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter, which SellMedicine to fetch.
     */
    where?: SellMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellMedicines to fetch.
     */
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellMedicines.
     */
    cursor?: SellMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellMedicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellMedicines.
     */
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * SellMedicine findMany
   */
  export type SellMedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter, which SellMedicines to fetch.
     */
    where?: SellMedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellMedicines to fetch.
     */
    orderBy?: SellMedicineOrderByWithRelationInput | SellMedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellMedicines.
     */
    cursor?: SellMedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellMedicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellMedicines.
     */
    skip?: number
    distinct?: SellMedicineScalarFieldEnum | SellMedicineScalarFieldEnum[]
  }

  /**
   * SellMedicine create
   */
  export type SellMedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a SellMedicine.
     */
    data: XOR<SellMedicineCreateInput, SellMedicineUncheckedCreateInput>
  }

  /**
   * SellMedicine createMany
   */
  export type SellMedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellMedicines.
     */
    data: SellMedicineCreateManyInput | SellMedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellMedicine createManyAndReturn
   */
  export type SellMedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * The data used to create many SellMedicines.
     */
    data: SellMedicineCreateManyInput | SellMedicineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellMedicine update
   */
  export type SellMedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a SellMedicine.
     */
    data: XOR<SellMedicineUpdateInput, SellMedicineUncheckedUpdateInput>
    /**
     * Choose, which SellMedicine to update.
     */
    where: SellMedicineWhereUniqueInput
  }

  /**
   * SellMedicine updateMany
   */
  export type SellMedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellMedicines.
     */
    data: XOR<SellMedicineUpdateManyMutationInput, SellMedicineUncheckedUpdateManyInput>
    /**
     * Filter which SellMedicines to update
     */
    where?: SellMedicineWhereInput
    /**
     * Limit how many SellMedicines to update.
     */
    limit?: number
  }

  /**
   * SellMedicine updateManyAndReturn
   */
  export type SellMedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * The data used to update SellMedicines.
     */
    data: XOR<SellMedicineUpdateManyMutationInput, SellMedicineUncheckedUpdateManyInput>
    /**
     * Filter which SellMedicines to update
     */
    where?: SellMedicineWhereInput
    /**
     * Limit how many SellMedicines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellMedicine upsert
   */
  export type SellMedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the SellMedicine to update in case it exists.
     */
    where: SellMedicineWhereUniqueInput
    /**
     * In case the SellMedicine found by the `where` argument doesn't exist, create a new SellMedicine with this data.
     */
    create: XOR<SellMedicineCreateInput, SellMedicineUncheckedCreateInput>
    /**
     * In case the SellMedicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellMedicineUpdateInput, SellMedicineUncheckedUpdateInput>
  }

  /**
   * SellMedicine delete
   */
  export type SellMedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
    /**
     * Filter which SellMedicine to delete.
     */
    where: SellMedicineWhereUniqueInput
  }

  /**
   * SellMedicine deleteMany
   */
  export type SellMedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellMedicines to delete
     */
    where?: SellMedicineWhereInput
    /**
     * Limit how many SellMedicines to delete.
     */
    limit?: number
  }

  /**
   * SellMedicine.MedicineTransfer
   */
  export type SellMedicine$MedicineTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    where?: MedicineTransferWhereInput
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    cursor?: MedicineTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * SellMedicine without action
   */
  export type SellMedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellMedicine
     */
    select?: SellMedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellMedicine
     */
    omit?: SellMedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellMedicineInclude<ExtArgs> | null
  }


  /**
   * Model MedicineTransfer
   */

  export type AggregateMedicineTransfer = {
    _count: MedicineTransferCountAggregateOutputType | null
    _avg: MedicineTransferAvgAggregateOutputType | null
    _sum: MedicineTransferSumAggregateOutputType | null
    _min: MedicineTransferMinAggregateOutputType | null
    _max: MedicineTransferMaxAggregateOutputType | null
  }

  export type MedicineTransferAvgAggregateOutputType = {
    billNumber: number | null
    fromFarmcode: number | null
    toFarmcode: number | null
  }

  export type MedicineTransferSumAggregateOutputType = {
    billNumber: number | null
    fromFarmcode: number | null
    toFarmcode: number | null
  }

  export type MedicineTransferMinAggregateOutputType = {
    id: string | null
    billNumber: number | null
    flockId: string | null
    fromFarmcode: number | null
    toFarmcode: number | null
    medicineName: string | null
    genericName: string | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineTransferMaxAggregateOutputType = {
    id: string | null
    billNumber: number | null
    flockId: string | null
    fromFarmcode: number | null
    toFarmcode: number | null
    medicineName: string | null
    genericName: string | null
    branchCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineTransferCountAggregateOutputType = {
    id: number
    billNumber: number
    flockId: number
    fromFarmcode: number
    toFarmcode: number
    medicineName: number
    genericName: number
    branchCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineTransferAvgAggregateInputType = {
    billNumber?: true
    fromFarmcode?: true
    toFarmcode?: true
  }

  export type MedicineTransferSumAggregateInputType = {
    billNumber?: true
    fromFarmcode?: true
    toFarmcode?: true
  }

  export type MedicineTransferMinAggregateInputType = {
    id?: true
    billNumber?: true
    flockId?: true
    fromFarmcode?: true
    toFarmcode?: true
    medicineName?: true
    genericName?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineTransferMaxAggregateInputType = {
    id?: true
    billNumber?: true
    flockId?: true
    fromFarmcode?: true
    toFarmcode?: true
    medicineName?: true
    genericName?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineTransferCountAggregateInputType = {
    id?: true
    billNumber?: true
    flockId?: true
    fromFarmcode?: true
    toFarmcode?: true
    medicineName?: true
    genericName?: true
    branchCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineTransfer to aggregate.
     */
    where?: MedicineTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineTransfers to fetch.
     */
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineTransfers
    **/
    _count?: true | MedicineTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineTransferMaxAggregateInputType
  }

  export type GetMedicineTransferAggregateType<T extends MedicineTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineTransfer[P]>
      : GetScalarType<T[P], AggregateMedicineTransfer[P]>
  }




  export type MedicineTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineTransferWhereInput
    orderBy?: MedicineTransferOrderByWithAggregationInput | MedicineTransferOrderByWithAggregationInput[]
    by: MedicineTransferScalarFieldEnum[] | MedicineTransferScalarFieldEnum
    having?: MedicineTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineTransferCountAggregateInputType | true
    _avg?: MedicineTransferAvgAggregateInputType
    _sum?: MedicineTransferSumAggregateInputType
    _min?: MedicineTransferMinAggregateInputType
    _max?: MedicineTransferMaxAggregateInputType
  }

  export type MedicineTransferGroupByOutputType = {
    id: string
    billNumber: number
    flockId: string
    fromFarmcode: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date
    updatedAt: Date
    _count: MedicineTransferCountAggregateOutputType | null
    _avg: MedicineTransferAvgAggregateOutputType | null
    _sum: MedicineTransferSumAggregateOutputType | null
    _min: MedicineTransferMinAggregateOutputType | null
    _max: MedicineTransferMaxAggregateOutputType | null
  }

  type GetMedicineTransferGroupByPayload<T extends MedicineTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineTransferGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineTransferGroupByOutputType[P]>
        }
      >
    >


  export type MedicineTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    flockId?: boolean
    fromFarmcode?: boolean
    toFarmcode?: boolean
    medicineName?: boolean
    genericName?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineTransfer"]>

  export type MedicineTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    flockId?: boolean
    fromFarmcode?: boolean
    toFarmcode?: boolean
    medicineName?: boolean
    genericName?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineTransfer"]>

  export type MedicineTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    flockId?: boolean
    fromFarmcode?: boolean
    toFarmcode?: boolean
    medicineName?: boolean
    genericName?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineTransfer"]>

  export type MedicineTransferSelectScalar = {
    id?: boolean
    billNumber?: boolean
    flockId?: boolean
    fromFarmcode?: boolean
    toFarmcode?: boolean
    medicineName?: boolean
    genericName?: boolean
    branchCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billNumber" | "flockId" | "fromFarmcode" | "toFarmcode" | "medicineName" | "genericName" | "branchCode" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineTransfer"]>
  export type MedicineTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicineTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type MedicineTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellmedicine?: boolean | SellMedicineDefaultArgs<ExtArgs>
    flock?: boolean | FlockDefaultArgs<ExtArgs>
    baranch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $MedicineTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineTransfer"
    objects: {
      sellmedicine: Prisma.$SellMedicinePayload<ExtArgs>
      flock: Prisma.$FlockPayload<ExtArgs>
      baranch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billNumber: number
      flockId: string
      fromFarmcode: number | null
      toFarmcode: number
      medicineName: string
      genericName: string
      branchCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineTransfer"]>
    composites: {}
  }

  type MedicineTransferGetPayload<S extends boolean | null | undefined | MedicineTransferDefaultArgs> = $Result.GetResult<Prisma.$MedicineTransferPayload, S>

  type MedicineTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineTransferCountAggregateInputType | true
    }

  export interface MedicineTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineTransfer'], meta: { name: 'MedicineTransfer' } }
    /**
     * Find zero or one MedicineTransfer that matches the filter.
     * @param {MedicineTransferFindUniqueArgs} args - Arguments to find a MedicineTransfer
     * @example
     * // Get one MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineTransferFindUniqueArgs>(args: SelectSubset<T, MedicineTransferFindUniqueArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineTransferFindUniqueOrThrowArgs} args - Arguments to find a MedicineTransfer
     * @example
     * // Get one MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferFindFirstArgs} args - Arguments to find a MedicineTransfer
     * @example
     * // Get one MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineTransferFindFirstArgs>(args?: SelectSubset<T, MedicineTransferFindFirstArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferFindFirstOrThrowArgs} args - Arguments to find a MedicineTransfer
     * @example
     * // Get one MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineTransfers
     * const medicineTransfers = await prisma.medicineTransfer.findMany()
     * 
     * // Get first 10 MedicineTransfers
     * const medicineTransfers = await prisma.medicineTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineTransferWithIdOnly = await prisma.medicineTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineTransferFindManyArgs>(args?: SelectSubset<T, MedicineTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineTransfer.
     * @param {MedicineTransferCreateArgs} args - Arguments to create a MedicineTransfer.
     * @example
     * // Create one MedicineTransfer
     * const MedicineTransfer = await prisma.medicineTransfer.create({
     *   data: {
     *     // ... data to create a MedicineTransfer
     *   }
     * })
     * 
     */
    create<T extends MedicineTransferCreateArgs>(args: SelectSubset<T, MedicineTransferCreateArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineTransfers.
     * @param {MedicineTransferCreateManyArgs} args - Arguments to create many MedicineTransfers.
     * @example
     * // Create many MedicineTransfers
     * const medicineTransfer = await prisma.medicineTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineTransferCreateManyArgs>(args?: SelectSubset<T, MedicineTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineTransfers and returns the data saved in the database.
     * @param {MedicineTransferCreateManyAndReturnArgs} args - Arguments to create many MedicineTransfers.
     * @example
     * // Create many MedicineTransfers
     * const medicineTransfer = await prisma.medicineTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineTransfers and only return the `id`
     * const medicineTransferWithIdOnly = await prisma.medicineTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicineTransfer.
     * @param {MedicineTransferDeleteArgs} args - Arguments to delete one MedicineTransfer.
     * @example
     * // Delete one MedicineTransfer
     * const MedicineTransfer = await prisma.medicineTransfer.delete({
     *   where: {
     *     // ... filter to delete one MedicineTransfer
     *   }
     * })
     * 
     */
    delete<T extends MedicineTransferDeleteArgs>(args: SelectSubset<T, MedicineTransferDeleteArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineTransfer.
     * @param {MedicineTransferUpdateArgs} args - Arguments to update one MedicineTransfer.
     * @example
     * // Update one MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineTransferUpdateArgs>(args: SelectSubset<T, MedicineTransferUpdateArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineTransfers.
     * @param {MedicineTransferDeleteManyArgs} args - Arguments to filter MedicineTransfers to delete.
     * @example
     * // Delete a few MedicineTransfers
     * const { count } = await prisma.medicineTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineTransferDeleteManyArgs>(args?: SelectSubset<T, MedicineTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineTransfers
     * const medicineTransfer = await prisma.medicineTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineTransferUpdateManyArgs>(args: SelectSubset<T, MedicineTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineTransfers and returns the data updated in the database.
     * @param {MedicineTransferUpdateManyAndReturnArgs} args - Arguments to update many MedicineTransfers.
     * @example
     * // Update many MedicineTransfers
     * const medicineTransfer = await prisma.medicineTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineTransfers and only return the `id`
     * const medicineTransferWithIdOnly = await prisma.medicineTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicineTransfer.
     * @param {MedicineTransferUpsertArgs} args - Arguments to update or create a MedicineTransfer.
     * @example
     * // Update or create a MedicineTransfer
     * const medicineTransfer = await prisma.medicineTransfer.upsert({
     *   create: {
     *     // ... data to create a MedicineTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineTransfer we want to update
     *   }
     * })
     */
    upsert<T extends MedicineTransferUpsertArgs>(args: SelectSubset<T, MedicineTransferUpsertArgs<ExtArgs>>): Prisma__MedicineTransferClient<$Result.GetResult<Prisma.$MedicineTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferCountArgs} args - Arguments to filter MedicineTransfers to count.
     * @example
     * // Count the number of MedicineTransfers
     * const count = await prisma.medicineTransfer.count({
     *   where: {
     *     // ... the filter for the MedicineTransfers we want to count
     *   }
     * })
    **/
    count<T extends MedicineTransferCountArgs>(
      args?: Subset<T, MedicineTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineTransferAggregateArgs>(args: Subset<T, MedicineTransferAggregateArgs>): Prisma.PrismaPromise<GetMedicineTransferAggregateType<T>>

    /**
     * Group by MedicineTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineTransferGroupByArgs['orderBy'] }
        : { orderBy?: MedicineTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineTransfer model
   */
  readonly fields: MedicineTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sellmedicine<T extends SellMedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellMedicineDefaultArgs<ExtArgs>>): Prisma__SellMedicineClient<$Result.GetResult<Prisma.$SellMedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flock<T extends FlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlockDefaultArgs<ExtArgs>>): Prisma__FlockClient<$Result.GetResult<Prisma.$FlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineTransfer model
   */
  interface MedicineTransferFieldRefs {
    readonly id: FieldRef<"MedicineTransfer", 'String'>
    readonly billNumber: FieldRef<"MedicineTransfer", 'Int'>
    readonly flockId: FieldRef<"MedicineTransfer", 'String'>
    readonly fromFarmcode: FieldRef<"MedicineTransfer", 'Int'>
    readonly toFarmcode: FieldRef<"MedicineTransfer", 'Int'>
    readonly medicineName: FieldRef<"MedicineTransfer", 'String'>
    readonly genericName: FieldRef<"MedicineTransfer", 'String'>
    readonly branchCode: FieldRef<"MedicineTransfer", 'String'>
    readonly createdAt: FieldRef<"MedicineTransfer", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineTransfer findUnique
   */
  export type MedicineTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter, which MedicineTransfer to fetch.
     */
    where: MedicineTransferWhereUniqueInput
  }

  /**
   * MedicineTransfer findUniqueOrThrow
   */
  export type MedicineTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter, which MedicineTransfer to fetch.
     */
    where: MedicineTransferWhereUniqueInput
  }

  /**
   * MedicineTransfer findFirst
   */
  export type MedicineTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter, which MedicineTransfer to fetch.
     */
    where?: MedicineTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineTransfers to fetch.
     */
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineTransfers.
     */
    cursor?: MedicineTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineTransfers.
     */
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * MedicineTransfer findFirstOrThrow
   */
  export type MedicineTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter, which MedicineTransfer to fetch.
     */
    where?: MedicineTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineTransfers to fetch.
     */
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineTransfers.
     */
    cursor?: MedicineTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineTransfers.
     */
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * MedicineTransfer findMany
   */
  export type MedicineTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter, which MedicineTransfers to fetch.
     */
    where?: MedicineTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineTransfers to fetch.
     */
    orderBy?: MedicineTransferOrderByWithRelationInput | MedicineTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineTransfers.
     */
    cursor?: MedicineTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineTransfers.
     */
    skip?: number
    distinct?: MedicineTransferScalarFieldEnum | MedicineTransferScalarFieldEnum[]
  }

  /**
   * MedicineTransfer create
   */
  export type MedicineTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineTransfer.
     */
    data: XOR<MedicineTransferCreateInput, MedicineTransferUncheckedCreateInput>
  }

  /**
   * MedicineTransfer createMany
   */
  export type MedicineTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineTransfers.
     */
    data: MedicineTransferCreateManyInput | MedicineTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineTransfer createManyAndReturn
   */
  export type MedicineTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineTransfers.
     */
    data: MedicineTransferCreateManyInput | MedicineTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineTransfer update
   */
  export type MedicineTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineTransfer.
     */
    data: XOR<MedicineTransferUpdateInput, MedicineTransferUncheckedUpdateInput>
    /**
     * Choose, which MedicineTransfer to update.
     */
    where: MedicineTransferWhereUniqueInput
  }

  /**
   * MedicineTransfer updateMany
   */
  export type MedicineTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineTransfers.
     */
    data: XOR<MedicineTransferUpdateManyMutationInput, MedicineTransferUncheckedUpdateManyInput>
    /**
     * Filter which MedicineTransfers to update
     */
    where?: MedicineTransferWhereInput
    /**
     * Limit how many MedicineTransfers to update.
     */
    limit?: number
  }

  /**
   * MedicineTransfer updateManyAndReturn
   */
  export type MedicineTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * The data used to update MedicineTransfers.
     */
    data: XOR<MedicineTransferUpdateManyMutationInput, MedicineTransferUncheckedUpdateManyInput>
    /**
     * Filter which MedicineTransfers to update
     */
    where?: MedicineTransferWhereInput
    /**
     * Limit how many MedicineTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineTransfer upsert
   */
  export type MedicineTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineTransfer to update in case it exists.
     */
    where: MedicineTransferWhereUniqueInput
    /**
     * In case the MedicineTransfer found by the `where` argument doesn't exist, create a new MedicineTransfer with this data.
     */
    create: XOR<MedicineTransferCreateInput, MedicineTransferUncheckedCreateInput>
    /**
     * In case the MedicineTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineTransferUpdateInput, MedicineTransferUncheckedUpdateInput>
  }

  /**
   * MedicineTransfer delete
   */
  export type MedicineTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
    /**
     * Filter which MedicineTransfer to delete.
     */
    where: MedicineTransferWhereUniqueInput
  }

  /**
   * MedicineTransfer deleteMany
   */
  export type MedicineTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineTransfers to delete
     */
    where?: MedicineTransferWhereInput
    /**
     * Limit how many MedicineTransfers to delete.
     */
    limit?: number
  }

  /**
   * MedicineTransfer without action
   */
  export type MedicineTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineTransfer
     */
    select?: MedicineTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineTransfer
     */
    omit?: MedicineTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineTransferInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    id: 'id',
    locationName: 'locationName',
    type: 'type',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const FarmerScalarFieldEnum: {
    id: 'id',
    branchCode: 'branchCode',
    farmCode: 'farmCode',
    name: 'name',
    farmType: 'farmType',
    totalShed: 'totalShed',
    totalSquare: 'totalSquare',
    phoneNumber: 'phoneNumber',
    capacity: 'capacity',
    addressId: 'addressId',
    nid: 'nid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FarmerScalarFieldEnum = (typeof FarmerScalarFieldEnum)[keyof typeof FarmerScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    village: 'village',
    post: 'post',
    union: 'union',
    thana: 'thana',
    upazila: 'upazila',
    city: 'city',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BranchEmployeeHistoryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchEmployeeHistoryScalarFieldEnum = (typeof BranchEmployeeHistoryScalarFieldEnum)[keyof typeof BranchEmployeeHistoryScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    name: 'name',
    workingLocation: 'workingLocation',
    designation: 'designation',
    phoneNumber: 'phoneNumber',
    addressId: 'addressId',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const FlockScalarFieldEnum: {
    id: 'id',
    flockNumber: 'flockNumber',
    flockStatus: 'flockStatus',
    startDate: 'startDate',
    endDate: 'endDate',
    executiveId: 'executiveId',
    farmId: 'farmId',
    docName: 'docName',
    docQuantity: 'docQuantity',
    approvedBy: 'approvedBy',
    branchCode: 'branchCode',
    totalFeedKg: 'totalFeedKg',
    totalMedicine: 'totalMedicine',
    fcr: 'fcr',
    totalSellBirds: 'totalSellBirds',
    mortality: 'mortality',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlockScalarFieldEnum = (typeof FlockScalarFieldEnum)[keyof typeof FlockScalarFieldEnum]


  export const FlockReportScalarFieldEnum: {
    id: 'id',
    housedBirds: 'housedBirds',
    fcr: 'fcr',
    executiveId: 'executiveId',
    totalMortality: 'totalMortality',
    todayMortality: 'todayMortality',
    todayMortalityPercent: 'todayMortalityPercent',
    totalMortalityPercentage: 'totalMortalityPercentage',
    bodyWeight: 'bodyWeight',
    todayWeightGain: 'todayWeightGain',
    todayFeedEting: 'todayFeedEting',
    suggestTosell: 'suggestTosell',
    averageBodyWight: 'averageBodyWight',
    totalFeedEting: 'totalFeedEting',
    feedStock: 'feedStock',
    diseases: 'diseases',
    birdsStock: 'birdsStock',
    condition: 'condition',
    description: 'description',
    executiveName: 'executiveName',
    flockNumber: 'flockNumber',
    age: 'age',
    imagesOne: 'imagesOne',
    imageTwo: 'imageTwo',
    imageThree: 'imageThree',
    visitedDate: 'visitedDate',
    locationLink: 'locationLink',
    farmId: 'farmId',
    flockId: 'flockId',
    birdsSalesStart: 'birdsSalesStart',
    birdsSalesEnd: 'birdsSalesEnd',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlockReportScalarFieldEnum = (typeof FlockReportScalarFieldEnum)[keyof typeof FlockReportScalarFieldEnum]


  export const FeedNameCategoryScalarFieldEnum: {
    id: 'id',
    feedName: 'feedName',
    feedCodeNumber: 'feedCodeNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedNameCategoryScalarFieldEnum = (typeof FeedNameCategoryScalarFieldEnum)[keyof typeof FeedNameCategoryScalarFieldEnum]


  export const FeedScalarFieldEnum: {
    id: 'id',
    feedName: 'feedName',
    stock: 'stock',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedScalarFieldEnum = (typeof FeedScalarFieldEnum)[keyof typeof FeedScalarFieldEnum]


  export const AllGenericMedicinScalarFieldEnum: {
    id: 'id',
    genericName: 'genericName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AllGenericMedicinScalarFieldEnum = (typeof AllGenericMedicinScalarFieldEnum)[keyof typeof AllGenericMedicinScalarFieldEnum]


  export const MedicineNameAddScalarFieldEnum: {
    id: 'id',
    name: 'name',
    conpany: 'conpany',
    genericName: 'genericName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineNameAddScalarFieldEnum = (typeof MedicineNameAddScalarFieldEnum)[keyof typeof MedicineNameAddScalarFieldEnum]


  export const MedicinePurchessScalarFieldEnum: {
    id: 'id',
    genericName: 'genericName',
    name: 'name',
    purchaseUnitPrice: 'purchaseUnitPrice',
    sellUnitPrice: 'sellUnitPrice',
    purchaseQuantity: 'purchaseQuantity',
    mfgDate: 'mfgDate',
    expDate: 'expDate',
    bonusQuantity: 'bonusQuantity',
    purchaseTotalPrice: 'purchaseTotalPrice',
    supplierInfo: 'supplierInfo',
    stored: 'stored',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicinePurchessScalarFieldEnum = (typeof MedicinePurchessScalarFieldEnum)[keyof typeof MedicinePurchessScalarFieldEnum]


  export const MedicineStockScalarFieldEnum: {
    id: 'id',
    genericName: 'genericName',
    medicineName: 'medicineName',
    branchCode: 'branchCode',
    totalStock: 'totalStock',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineStockScalarFieldEnum = (typeof MedicineStockScalarFieldEnum)[keyof typeof MedicineStockScalarFieldEnum]


  export const SellMedicineScalarFieldEnum: {
    id: 'id',
    billNumber: 'billNumber',
    farmId: 'farmId',
    flockNumer: 'flockNumer',
    genericName: 'genericName',
    medicineName: 'medicineName',
    sellQuantity: 'sellQuantity',
    sellPrice: 'sellPrice',
    Delivery: 'Delivery',
    sellDate: 'sellDate',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellMedicineScalarFieldEnum = (typeof SellMedicineScalarFieldEnum)[keyof typeof SellMedicineScalarFieldEnum]


  export const MedicineTransferScalarFieldEnum: {
    id: 'id',
    billNumber: 'billNumber',
    flockId: 'flockId',
    fromFarmcode: 'fromFarmcode',
    toFarmcode: 'toFarmcode',
    medicineName: 'medicineName',
    genericName: 'genericName',
    branchCode: 'branchCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineTransferScalarFieldEnum = (typeof MedicineTransferScalarFieldEnum)[keyof typeof MedicineTransferScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BranchType'
   */
  export type EnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType'>
    


  /**
   * Reference to a field of type 'BranchType[]'
   */
  export type ListEnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Custtype'
   */
  export type EnumCusttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Custtype'>
    


  /**
   * Reference to a field of type 'Custtype[]'
   */
  export type ListEnumCusttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Custtype[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FlockStatus'
   */
  export type EnumFlockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlockStatus'>
    


  /**
   * Reference to a field of type 'FlockStatus[]'
   */
  export type ListEnumFlockStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlockStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Stored'
   */
  export type EnumStoredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Stored'>
    


  /**
   * Reference to a field of type 'Stored[]'
   */
  export type ListEnumStoredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Stored[]'>
    


  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus'>
    


  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    locationName?: StringFilter<"Branch"> | string
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    branchCode?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    farmer?: FarmerListRelationFilter
    flocks?: FlockListRelationFilter
    feed?: FeedListRelationFilter
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
    sellMedicine?: SellMedicineListRelationFilter
    medicineTransfer?: MedicineTransferListRelationFilter
    flockReport?: FlockReportListRelationFilter
    branchEmployeeHistory?: BranchEmployeeHistoryListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    locationName?: SortOrder
    type?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmer?: FarmerOrderByRelationAggregateInput
    flocks?: FlockOrderByRelationAggregateInput
    feed?: FeedOrderByRelationAggregateInput
    medicineStock?: MedicineStockOrderByRelationAggregateInput
    medicinePurchess?: MedicinePurchessOrderByRelationAggregateInput
    sellMedicine?: SellMedicineOrderByRelationAggregateInput
    medicineTransfer?: MedicineTransferOrderByRelationAggregateInput
    flockReport?: FlockReportOrderByRelationAggregateInput
    branchEmployeeHistory?: BranchEmployeeHistoryOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationName?: string
    branchCode?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    farmer?: FarmerListRelationFilter
    flocks?: FlockListRelationFilter
    feed?: FeedListRelationFilter
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
    sellMedicine?: SellMedicineListRelationFilter
    medicineTransfer?: MedicineTransferListRelationFilter
    flockReport?: FlockReportListRelationFilter
    branchEmployeeHistory?: BranchEmployeeHistoryListRelationFilter
  }, "id" | "locationName" | "branchCode">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    locationName?: SortOrder
    type?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    locationName?: StringWithAggregatesFilter<"Branch"> | string
    type?: EnumBranchTypeWithAggregatesFilter<"Branch"> | $Enums.BranchType
    branchCode?: StringWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type FarmerWhereInput = {
    AND?: FarmerWhereInput | FarmerWhereInput[]
    OR?: FarmerWhereInput[]
    NOT?: FarmerWhereInput | FarmerWhereInput[]
    id?: StringFilter<"Farmer"> | string
    branchCode?: StringNullableFilter<"Farmer"> | string | null
    farmCode?: IntFilter<"Farmer"> | number
    name?: StringFilter<"Farmer"> | string
    farmType?: EnumCusttypeFilter<"Farmer"> | $Enums.Custtype
    totalShed?: IntFilter<"Farmer"> | number
    totalSquare?: IntFilter<"Farmer"> | number
    phoneNumber?: StringFilter<"Farmer"> | string
    capacity?: IntFilter<"Farmer"> | number
    addressId?: StringNullableFilter<"Farmer"> | string | null
    nid?: StringFilter<"Farmer"> | string
    createdAt?: DateTimeFilter<"Farmer"> | Date | string
    updatedAt?: DateTimeFilter<"Farmer"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    flocks?: FlockListRelationFilter
    sellMedicine?: SellMedicineListRelationFilter
    flockReport?: FlockReportListRelationFilter
  }

  export type FarmerOrderByWithRelationInput = {
    id?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    farmCode?: SortOrder
    name?: SortOrder
    farmType?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    phoneNumber?: SortOrder
    capacity?: SortOrder
    addressId?: SortOrderInput | SortOrder
    nid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    flocks?: FlockOrderByRelationAggregateInput
    sellMedicine?: SellMedicineOrderByRelationAggregateInput
    flockReport?: FlockReportOrderByRelationAggregateInput
  }

  export type FarmerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    addressId?: string
    branchCode_farmCode?: FarmerBranchCodeFarmCodeCompoundUniqueInput
    AND?: FarmerWhereInput | FarmerWhereInput[]
    OR?: FarmerWhereInput[]
    NOT?: FarmerWhereInput | FarmerWhereInput[]
    branchCode?: StringNullableFilter<"Farmer"> | string | null
    farmCode?: IntFilter<"Farmer"> | number
    name?: StringFilter<"Farmer"> | string
    farmType?: EnumCusttypeFilter<"Farmer"> | $Enums.Custtype
    totalShed?: IntFilter<"Farmer"> | number
    totalSquare?: IntFilter<"Farmer"> | number
    phoneNumber?: StringFilter<"Farmer"> | string
    capacity?: IntFilter<"Farmer"> | number
    nid?: StringFilter<"Farmer"> | string
    createdAt?: DateTimeFilter<"Farmer"> | Date | string
    updatedAt?: DateTimeFilter<"Farmer"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    flocks?: FlockListRelationFilter
    sellMedicine?: SellMedicineListRelationFilter
    flockReport?: FlockReportListRelationFilter
  }, "id" | "addressId" | "branchCode_farmCode">

  export type FarmerOrderByWithAggregationInput = {
    id?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    farmCode?: SortOrder
    name?: SortOrder
    farmType?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    phoneNumber?: SortOrder
    capacity?: SortOrder
    addressId?: SortOrderInput | SortOrder
    nid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FarmerCountOrderByAggregateInput
    _avg?: FarmerAvgOrderByAggregateInput
    _max?: FarmerMaxOrderByAggregateInput
    _min?: FarmerMinOrderByAggregateInput
    _sum?: FarmerSumOrderByAggregateInput
  }

  export type FarmerScalarWhereWithAggregatesInput = {
    AND?: FarmerScalarWhereWithAggregatesInput | FarmerScalarWhereWithAggregatesInput[]
    OR?: FarmerScalarWhereWithAggregatesInput[]
    NOT?: FarmerScalarWhereWithAggregatesInput | FarmerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Farmer"> | string
    branchCode?: StringNullableWithAggregatesFilter<"Farmer"> | string | null
    farmCode?: IntWithAggregatesFilter<"Farmer"> | number
    name?: StringWithAggregatesFilter<"Farmer"> | string
    farmType?: EnumCusttypeWithAggregatesFilter<"Farmer"> | $Enums.Custtype
    totalShed?: IntWithAggregatesFilter<"Farmer"> | number
    totalSquare?: IntWithAggregatesFilter<"Farmer"> | number
    phoneNumber?: StringWithAggregatesFilter<"Farmer"> | string
    capacity?: IntWithAggregatesFilter<"Farmer"> | number
    addressId?: StringNullableWithAggregatesFilter<"Farmer"> | string | null
    nid?: StringWithAggregatesFilter<"Farmer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Farmer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Farmer"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    village?: StringFilter<"Address"> | string
    post?: StringFilter<"Address"> | string
    union?: StringNullableFilter<"Address"> | string | null
    thana?: StringNullableFilter<"Address"> | string | null
    upazila?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    Farmer?: XOR<FarmerNullableScalarRelationFilter, FarmerWhereInput> | null
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    village?: SortOrder
    post?: SortOrder
    union?: SortOrderInput | SortOrder
    thana?: SortOrderInput | SortOrder
    upazila?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Farmer?: FarmerOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    village?: StringFilter<"Address"> | string
    post?: StringFilter<"Address"> | string
    union?: StringNullableFilter<"Address"> | string | null
    thana?: StringNullableFilter<"Address"> | string | null
    upazila?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    Farmer?: XOR<FarmerNullableScalarRelationFilter, FarmerWhereInput> | null
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    village?: SortOrder
    post?: SortOrder
    union?: SortOrderInput | SortOrder
    thana?: SortOrderInput | SortOrder
    upazila?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    village?: StringWithAggregatesFilter<"Address"> | string
    post?: StringWithAggregatesFilter<"Address"> | string
    union?: StringNullableWithAggregatesFilter<"Address"> | string | null
    thana?: StringNullableWithAggregatesFilter<"Address"> | string | null
    upazila?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type BranchEmployeeHistoryWhereInput = {
    AND?: BranchEmployeeHistoryWhereInput | BranchEmployeeHistoryWhereInput[]
    OR?: BranchEmployeeHistoryWhereInput[]
    NOT?: BranchEmployeeHistoryWhereInput | BranchEmployeeHistoryWhereInput[]
    id?: StringFilter<"BranchEmployeeHistory"> | string
    employeeId?: StringFilter<"BranchEmployeeHistory"> | string
    startDate?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"BranchEmployeeHistory"> | Date | string | null
    isActive?: BoolFilter<"BranchEmployeeHistory"> | boolean
    branchCode?: StringFilter<"BranchEmployeeHistory"> | string
    createdAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type BranchEmployeeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type BranchEmployeeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchEmployeeHistoryWhereInput | BranchEmployeeHistoryWhereInput[]
    OR?: BranchEmployeeHistoryWhereInput[]
    NOT?: BranchEmployeeHistoryWhereInput | BranchEmployeeHistoryWhereInput[]
    employeeId?: StringFilter<"BranchEmployeeHistory"> | string
    startDate?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"BranchEmployeeHistory"> | Date | string | null
    isActive?: BoolFilter<"BranchEmployeeHistory"> | boolean
    branchCode?: StringFilter<"BranchEmployeeHistory"> | string
    createdAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type BranchEmployeeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchEmployeeHistoryCountOrderByAggregateInput
    _max?: BranchEmployeeHistoryMaxOrderByAggregateInput
    _min?: BranchEmployeeHistoryMinOrderByAggregateInput
  }

  export type BranchEmployeeHistoryScalarWhereWithAggregatesInput = {
    AND?: BranchEmployeeHistoryScalarWhereWithAggregatesInput | BranchEmployeeHistoryScalarWhereWithAggregatesInput[]
    OR?: BranchEmployeeHistoryScalarWhereWithAggregatesInput[]
    NOT?: BranchEmployeeHistoryScalarWhereWithAggregatesInput | BranchEmployeeHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BranchEmployeeHistory"> | string
    employeeId?: StringWithAggregatesFilter<"BranchEmployeeHistory"> | string
    startDate?: DateTimeWithAggregatesFilter<"BranchEmployeeHistory"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"BranchEmployeeHistory"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"BranchEmployeeHistory"> | boolean
    branchCode?: StringWithAggregatesFilter<"BranchEmployeeHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BranchEmployeeHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BranchEmployeeHistory"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeId?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    workingLocation?: StringFilter<"Employee"> | string
    designation?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    addressId?: StringNullableFilter<"Employee"> | string | null
    branchId?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    flocks?: FlockListRelationFilter
    branchEmployeeHistory?: BranchEmployeeHistoryListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    workingLocation?: SortOrder
    designation?: SortOrder
    phoneNumber?: SortOrder
    addressId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: AddressOrderByWithRelationInput
    flocks?: FlockOrderByRelationAggregateInput
    branchEmployeeHistory?: BranchEmployeeHistoryOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    addressId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    workingLocation?: StringFilter<"Employee"> | string
    designation?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    branchId?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    flocks?: FlockListRelationFilter
    branchEmployeeHistory?: BranchEmployeeHistoryListRelationFilter
  }, "id" | "employeeId" | "addressId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    workingLocation?: SortOrder
    designation?: SortOrder
    phoneNumber?: SortOrder
    addressId?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employeeId?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    workingLocation?: StringWithAggregatesFilter<"Employee"> | string
    designation?: StringWithAggregatesFilter<"Employee"> | string
    phoneNumber?: StringWithAggregatesFilter<"Employee"> | string
    addressId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type FlockWhereInput = {
    AND?: FlockWhereInput | FlockWhereInput[]
    OR?: FlockWhereInput[]
    NOT?: FlockWhereInput | FlockWhereInput[]
    id?: StringFilter<"Flock"> | string
    flockNumber?: IntFilter<"Flock"> | number
    flockStatus?: EnumFlockStatusFilter<"Flock"> | $Enums.FlockStatus
    startDate?: DateTimeFilter<"Flock"> | Date | string
    endDate?: DateTimeNullableFilter<"Flock"> | Date | string | null
    executiveId?: StringFilter<"Flock"> | string
    farmId?: StringFilter<"Flock"> | string
    docName?: StringFilter<"Flock"> | string
    docQuantity?: IntFilter<"Flock"> | number
    approvedBy?: StringNullableFilter<"Flock"> | string | null
    branchCode?: StringFilter<"Flock"> | string
    totalFeedKg?: IntFilter<"Flock"> | number
    totalMedicine?: IntFilter<"Flock"> | number
    fcr?: FloatFilter<"Flock"> | number
    totalSellBirds?: IntFilter<"Flock"> | number
    mortality?: IntFilter<"Flock"> | number
    createdAt?: DateTimeFilter<"Flock"> | Date | string
    updatedAt?: DateTimeFilter<"Flock"> | Date | string
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    sellMedicine?: SellMedicineListRelationFilter
    medicineTransfer?: MedicineTransferListRelationFilter
    flockReport?: FlockReportListRelationFilter
  }

  export type FlockOrderByWithRelationInput = {
    id?: SortOrder
    flockNumber?: SortOrder
    flockStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    farmId?: SortOrder
    docName?: SortOrder
    docQuantity?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    branchCode?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmer?: FarmerOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    sellMedicine?: SellMedicineOrderByRelationAggregateInput
    medicineTransfer?: MedicineTransferOrderByRelationAggregateInput
    flockReport?: FlockReportOrderByRelationAggregateInput
  }

  export type FlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flockNumber?: number
    AND?: FlockWhereInput | FlockWhereInput[]
    OR?: FlockWhereInput[]
    NOT?: FlockWhereInput | FlockWhereInput[]
    flockStatus?: EnumFlockStatusFilter<"Flock"> | $Enums.FlockStatus
    startDate?: DateTimeFilter<"Flock"> | Date | string
    endDate?: DateTimeNullableFilter<"Flock"> | Date | string | null
    executiveId?: StringFilter<"Flock"> | string
    farmId?: StringFilter<"Flock"> | string
    docName?: StringFilter<"Flock"> | string
    docQuantity?: IntFilter<"Flock"> | number
    approvedBy?: StringNullableFilter<"Flock"> | string | null
    branchCode?: StringFilter<"Flock"> | string
    totalFeedKg?: IntFilter<"Flock"> | number
    totalMedicine?: IntFilter<"Flock"> | number
    fcr?: FloatFilter<"Flock"> | number
    totalSellBirds?: IntFilter<"Flock"> | number
    mortality?: IntFilter<"Flock"> | number
    createdAt?: DateTimeFilter<"Flock"> | Date | string
    updatedAt?: DateTimeFilter<"Flock"> | Date | string
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    sellMedicine?: SellMedicineListRelationFilter
    medicineTransfer?: MedicineTransferListRelationFilter
    flockReport?: FlockReportListRelationFilter
  }, "id" | "flockNumber">

  export type FlockOrderByWithAggregationInput = {
    id?: SortOrder
    flockNumber?: SortOrder
    flockStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    farmId?: SortOrder
    docName?: SortOrder
    docQuantity?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    branchCode?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlockCountOrderByAggregateInput
    _avg?: FlockAvgOrderByAggregateInput
    _max?: FlockMaxOrderByAggregateInput
    _min?: FlockMinOrderByAggregateInput
    _sum?: FlockSumOrderByAggregateInput
  }

  export type FlockScalarWhereWithAggregatesInput = {
    AND?: FlockScalarWhereWithAggregatesInput | FlockScalarWhereWithAggregatesInput[]
    OR?: FlockScalarWhereWithAggregatesInput[]
    NOT?: FlockScalarWhereWithAggregatesInput | FlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flock"> | string
    flockNumber?: IntWithAggregatesFilter<"Flock"> | number
    flockStatus?: EnumFlockStatusWithAggregatesFilter<"Flock"> | $Enums.FlockStatus
    startDate?: DateTimeWithAggregatesFilter<"Flock"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Flock"> | Date | string | null
    executiveId?: StringWithAggregatesFilter<"Flock"> | string
    farmId?: StringWithAggregatesFilter<"Flock"> | string
    docName?: StringWithAggregatesFilter<"Flock"> | string
    docQuantity?: IntWithAggregatesFilter<"Flock"> | number
    approvedBy?: StringNullableWithAggregatesFilter<"Flock"> | string | null
    branchCode?: StringWithAggregatesFilter<"Flock"> | string
    totalFeedKg?: IntWithAggregatesFilter<"Flock"> | number
    totalMedicine?: IntWithAggregatesFilter<"Flock"> | number
    fcr?: FloatWithAggregatesFilter<"Flock"> | number
    totalSellBirds?: IntWithAggregatesFilter<"Flock"> | number
    mortality?: IntWithAggregatesFilter<"Flock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Flock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flock"> | Date | string
  }

  export type FlockReportWhereInput = {
    AND?: FlockReportWhereInput | FlockReportWhereInput[]
    OR?: FlockReportWhereInput[]
    NOT?: FlockReportWhereInput | FlockReportWhereInput[]
    id?: StringFilter<"FlockReport"> | string
    housedBirds?: IntFilter<"FlockReport"> | number
    fcr?: FloatNullableFilter<"FlockReport"> | number | null
    executiveId?: StringFilter<"FlockReport"> | string
    totalMortality?: IntNullableFilter<"FlockReport"> | number | null
    todayMortality?: IntFilter<"FlockReport"> | number
    todayMortalityPercent?: FloatNullableFilter<"FlockReport"> | number | null
    totalMortalityPercentage?: FloatNullableFilter<"FlockReport"> | number | null
    bodyWeight?: FloatFilter<"FlockReport"> | number
    todayWeightGain?: IntFilter<"FlockReport"> | number
    todayFeedEting?: IntFilter<"FlockReport"> | number
    suggestTosell?: BoolFilter<"FlockReport"> | boolean
    averageBodyWight?: FloatNullableFilter<"FlockReport"> | number | null
    totalFeedEting?: IntFilter<"FlockReport"> | number
    feedStock?: IntFilter<"FlockReport"> | number
    diseases?: StringFilter<"FlockReport"> | string
    birdsStock?: IntFilter<"FlockReport"> | number
    condition?: StringFilter<"FlockReport"> | string
    description?: StringFilter<"FlockReport"> | string
    executiveName?: StringFilter<"FlockReport"> | string
    flockNumber?: StringFilter<"FlockReport"> | string
    age?: IntNullableFilter<"FlockReport"> | number | null
    imagesOne?: StringNullableFilter<"FlockReport"> | string | null
    imageTwo?: StringNullableFilter<"FlockReport"> | string | null
    imageThree?: StringNullableFilter<"FlockReport"> | string | null
    visitedDate?: DateTimeFilter<"FlockReport"> | Date | string
    locationLink?: StringFilter<"FlockReport"> | string
    farmId?: StringFilter<"FlockReport"> | string
    flockId?: StringFilter<"FlockReport"> | string
    birdsSalesStart?: BoolFilter<"FlockReport"> | boolean
    birdsSalesEnd?: BoolFilter<"FlockReport"> | boolean
    branchCode?: StringFilter<"FlockReport"> | string
    createdAt?: DateTimeFilter<"FlockReport"> | Date | string
    updatedAt?: DateTimeFilter<"FlockReport"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
  }

  export type FlockReportOrderByWithRelationInput = {
    id?: SortOrder
    housedBirds?: SortOrder
    fcr?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    totalMortality?: SortOrderInput | SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrderInput | SortOrder
    totalMortalityPercentage?: SortOrderInput | SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    suggestTosell?: SortOrder
    averageBodyWight?: SortOrderInput | SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    diseases?: SortOrder
    birdsStock?: SortOrder
    condition?: SortOrder
    description?: SortOrder
    executiveName?: SortOrder
    flockNumber?: SortOrder
    age?: SortOrderInput | SortOrder
    imagesOne?: SortOrderInput | SortOrder
    imageTwo?: SortOrderInput | SortOrder
    imageThree?: SortOrderInput | SortOrder
    visitedDate?: SortOrder
    locationLink?: SortOrder
    farmId?: SortOrder
    flockId?: SortOrder
    birdsSalesStart?: SortOrder
    birdsSalesEnd?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    flock?: FlockOrderByWithRelationInput
    farmer?: FarmerOrderByWithRelationInput
  }

  export type FlockReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlockReportWhereInput | FlockReportWhereInput[]
    OR?: FlockReportWhereInput[]
    NOT?: FlockReportWhereInput | FlockReportWhereInput[]
    housedBirds?: IntFilter<"FlockReport"> | number
    fcr?: FloatNullableFilter<"FlockReport"> | number | null
    executiveId?: StringFilter<"FlockReport"> | string
    totalMortality?: IntNullableFilter<"FlockReport"> | number | null
    todayMortality?: IntFilter<"FlockReport"> | number
    todayMortalityPercent?: FloatNullableFilter<"FlockReport"> | number | null
    totalMortalityPercentage?: FloatNullableFilter<"FlockReport"> | number | null
    bodyWeight?: FloatFilter<"FlockReport"> | number
    todayWeightGain?: IntFilter<"FlockReport"> | number
    todayFeedEting?: IntFilter<"FlockReport"> | number
    suggestTosell?: BoolFilter<"FlockReport"> | boolean
    averageBodyWight?: FloatNullableFilter<"FlockReport"> | number | null
    totalFeedEting?: IntFilter<"FlockReport"> | number
    feedStock?: IntFilter<"FlockReport"> | number
    diseases?: StringFilter<"FlockReport"> | string
    birdsStock?: IntFilter<"FlockReport"> | number
    condition?: StringFilter<"FlockReport"> | string
    description?: StringFilter<"FlockReport"> | string
    executiveName?: StringFilter<"FlockReport"> | string
    flockNumber?: StringFilter<"FlockReport"> | string
    age?: IntNullableFilter<"FlockReport"> | number | null
    imagesOne?: StringNullableFilter<"FlockReport"> | string | null
    imageTwo?: StringNullableFilter<"FlockReport"> | string | null
    imageThree?: StringNullableFilter<"FlockReport"> | string | null
    visitedDate?: DateTimeFilter<"FlockReport"> | Date | string
    locationLink?: StringFilter<"FlockReport"> | string
    farmId?: StringFilter<"FlockReport"> | string
    flockId?: StringFilter<"FlockReport"> | string
    birdsSalesStart?: BoolFilter<"FlockReport"> | boolean
    birdsSalesEnd?: BoolFilter<"FlockReport"> | boolean
    branchCode?: StringFilter<"FlockReport"> | string
    createdAt?: DateTimeFilter<"FlockReport"> | Date | string
    updatedAt?: DateTimeFilter<"FlockReport"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
  }, "id">

  export type FlockReportOrderByWithAggregationInput = {
    id?: SortOrder
    housedBirds?: SortOrder
    fcr?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    totalMortality?: SortOrderInput | SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrderInput | SortOrder
    totalMortalityPercentage?: SortOrderInput | SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    suggestTosell?: SortOrder
    averageBodyWight?: SortOrderInput | SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    diseases?: SortOrder
    birdsStock?: SortOrder
    condition?: SortOrder
    description?: SortOrder
    executiveName?: SortOrder
    flockNumber?: SortOrder
    age?: SortOrderInput | SortOrder
    imagesOne?: SortOrderInput | SortOrder
    imageTwo?: SortOrderInput | SortOrder
    imageThree?: SortOrderInput | SortOrder
    visitedDate?: SortOrder
    locationLink?: SortOrder
    farmId?: SortOrder
    flockId?: SortOrder
    birdsSalesStart?: SortOrder
    birdsSalesEnd?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlockReportCountOrderByAggregateInput
    _avg?: FlockReportAvgOrderByAggregateInput
    _max?: FlockReportMaxOrderByAggregateInput
    _min?: FlockReportMinOrderByAggregateInput
    _sum?: FlockReportSumOrderByAggregateInput
  }

  export type FlockReportScalarWhereWithAggregatesInput = {
    AND?: FlockReportScalarWhereWithAggregatesInput | FlockReportScalarWhereWithAggregatesInput[]
    OR?: FlockReportScalarWhereWithAggregatesInput[]
    NOT?: FlockReportScalarWhereWithAggregatesInput | FlockReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlockReport"> | string
    housedBirds?: IntWithAggregatesFilter<"FlockReport"> | number
    fcr?: FloatNullableWithAggregatesFilter<"FlockReport"> | number | null
    executiveId?: StringWithAggregatesFilter<"FlockReport"> | string
    totalMortality?: IntNullableWithAggregatesFilter<"FlockReport"> | number | null
    todayMortality?: IntWithAggregatesFilter<"FlockReport"> | number
    todayMortalityPercent?: FloatNullableWithAggregatesFilter<"FlockReport"> | number | null
    totalMortalityPercentage?: FloatNullableWithAggregatesFilter<"FlockReport"> | number | null
    bodyWeight?: FloatWithAggregatesFilter<"FlockReport"> | number
    todayWeightGain?: IntWithAggregatesFilter<"FlockReport"> | number
    todayFeedEting?: IntWithAggregatesFilter<"FlockReport"> | number
    suggestTosell?: BoolWithAggregatesFilter<"FlockReport"> | boolean
    averageBodyWight?: FloatNullableWithAggregatesFilter<"FlockReport"> | number | null
    totalFeedEting?: IntWithAggregatesFilter<"FlockReport"> | number
    feedStock?: IntWithAggregatesFilter<"FlockReport"> | number
    diseases?: StringWithAggregatesFilter<"FlockReport"> | string
    birdsStock?: IntWithAggregatesFilter<"FlockReport"> | number
    condition?: StringWithAggregatesFilter<"FlockReport"> | string
    description?: StringWithAggregatesFilter<"FlockReport"> | string
    executiveName?: StringWithAggregatesFilter<"FlockReport"> | string
    flockNumber?: StringWithAggregatesFilter<"FlockReport"> | string
    age?: IntNullableWithAggregatesFilter<"FlockReport"> | number | null
    imagesOne?: StringNullableWithAggregatesFilter<"FlockReport"> | string | null
    imageTwo?: StringNullableWithAggregatesFilter<"FlockReport"> | string | null
    imageThree?: StringNullableWithAggregatesFilter<"FlockReport"> | string | null
    visitedDate?: DateTimeWithAggregatesFilter<"FlockReport"> | Date | string
    locationLink?: StringWithAggregatesFilter<"FlockReport"> | string
    farmId?: StringWithAggregatesFilter<"FlockReport"> | string
    flockId?: StringWithAggregatesFilter<"FlockReport"> | string
    birdsSalesStart?: BoolWithAggregatesFilter<"FlockReport"> | boolean
    birdsSalesEnd?: BoolWithAggregatesFilter<"FlockReport"> | boolean
    branchCode?: StringWithAggregatesFilter<"FlockReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FlockReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FlockReport"> | Date | string
  }

  export type FeedNameCategoryWhereInput = {
    AND?: FeedNameCategoryWhereInput | FeedNameCategoryWhereInput[]
    OR?: FeedNameCategoryWhereInput[]
    NOT?: FeedNameCategoryWhereInput | FeedNameCategoryWhereInput[]
    id?: StringFilter<"FeedNameCategory"> | string
    feedName?: StringFilter<"FeedNameCategory"> | string
    feedCodeNumber?: IntFilter<"FeedNameCategory"> | number
    createdAt?: DateTimeFilter<"FeedNameCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FeedNameCategory"> | Date | string
    feeds?: FeedListRelationFilter
  }

  export type FeedNameCategoryOrderByWithRelationInput = {
    id?: SortOrder
    feedName?: SortOrder
    feedCodeNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feeds?: FeedOrderByRelationAggregateInput
  }

  export type FeedNameCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    feedName?: string
    feedCodeNumber?: number
    AND?: FeedNameCategoryWhereInput | FeedNameCategoryWhereInput[]
    OR?: FeedNameCategoryWhereInput[]
    NOT?: FeedNameCategoryWhereInput | FeedNameCategoryWhereInput[]
    createdAt?: DateTimeFilter<"FeedNameCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FeedNameCategory"> | Date | string
    feeds?: FeedListRelationFilter
  }, "id" | "feedName" | "feedCodeNumber">

  export type FeedNameCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    feedName?: SortOrder
    feedCodeNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedNameCategoryCountOrderByAggregateInput
    _avg?: FeedNameCategoryAvgOrderByAggregateInput
    _max?: FeedNameCategoryMaxOrderByAggregateInput
    _min?: FeedNameCategoryMinOrderByAggregateInput
    _sum?: FeedNameCategorySumOrderByAggregateInput
  }

  export type FeedNameCategoryScalarWhereWithAggregatesInput = {
    AND?: FeedNameCategoryScalarWhereWithAggregatesInput | FeedNameCategoryScalarWhereWithAggregatesInput[]
    OR?: FeedNameCategoryScalarWhereWithAggregatesInput[]
    NOT?: FeedNameCategoryScalarWhereWithAggregatesInput | FeedNameCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedNameCategory"> | string
    feedName?: StringWithAggregatesFilter<"FeedNameCategory"> | string
    feedCodeNumber?: IntWithAggregatesFilter<"FeedNameCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FeedNameCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedNameCategory"> | Date | string
  }

  export type FeedWhereInput = {
    AND?: FeedWhereInput | FeedWhereInput[]
    OR?: FeedWhereInput[]
    NOT?: FeedWhereInput | FeedWhereInput[]
    id?: StringFilter<"Feed"> | string
    feedName?: StringFilter<"Feed"> | string
    stock?: IntFilter<"Feed"> | number
    branchCode?: StringNullableFilter<"Feed"> | string | null
    createdAt?: DateTimeFilter<"Feed"> | Date | string
    updatedAt?: DateTimeFilter<"Feed"> | Date | string
    feedNameCategory?: XOR<FeedNameCategoryScalarRelationFilter, FeedNameCategoryWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }

  export type FeedOrderByWithRelationInput = {
    id?: SortOrder
    feedName?: SortOrder
    stock?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedNameCategory?: FeedNameCategoryOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type FeedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedWhereInput | FeedWhereInput[]
    OR?: FeedWhereInput[]
    NOT?: FeedWhereInput | FeedWhereInput[]
    feedName?: StringFilter<"Feed"> | string
    stock?: IntFilter<"Feed"> | number
    branchCode?: StringNullableFilter<"Feed"> | string | null
    createdAt?: DateTimeFilter<"Feed"> | Date | string
    updatedAt?: DateTimeFilter<"Feed"> | Date | string
    feedNameCategory?: XOR<FeedNameCategoryScalarRelationFilter, FeedNameCategoryWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
  }, "id">

  export type FeedOrderByWithAggregationInput = {
    id?: SortOrder
    feedName?: SortOrder
    stock?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedCountOrderByAggregateInput
    _avg?: FeedAvgOrderByAggregateInput
    _max?: FeedMaxOrderByAggregateInput
    _min?: FeedMinOrderByAggregateInput
    _sum?: FeedSumOrderByAggregateInput
  }

  export type FeedScalarWhereWithAggregatesInput = {
    AND?: FeedScalarWhereWithAggregatesInput | FeedScalarWhereWithAggregatesInput[]
    OR?: FeedScalarWhereWithAggregatesInput[]
    NOT?: FeedScalarWhereWithAggregatesInput | FeedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feed"> | string
    feedName?: StringWithAggregatesFilter<"Feed"> | string
    stock?: IntWithAggregatesFilter<"Feed"> | number
    branchCode?: StringNullableWithAggregatesFilter<"Feed"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feed"> | Date | string
  }

  export type AllGenericMedicinWhereInput = {
    AND?: AllGenericMedicinWhereInput | AllGenericMedicinWhereInput[]
    OR?: AllGenericMedicinWhereInput[]
    NOT?: AllGenericMedicinWhereInput | AllGenericMedicinWhereInput[]
    id?: StringFilter<"AllGenericMedicin"> | string
    genericName?: StringFilter<"AllGenericMedicin"> | string
    createdAt?: DateTimeFilter<"AllGenericMedicin"> | Date | string
    updatedAt?: DateTimeFilter<"AllGenericMedicin"> | Date | string
    medicineNameAdd?: MedicineNameAddListRelationFilter
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
  }

  export type AllGenericMedicinOrderByWithRelationInput = {
    id?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicineNameAdd?: MedicineNameAddOrderByRelationAggregateInput
    medicineStock?: MedicineStockOrderByRelationAggregateInput
    medicinePurchess?: MedicinePurchessOrderByRelationAggregateInput
  }

  export type AllGenericMedicinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    genericName?: string
    AND?: AllGenericMedicinWhereInput | AllGenericMedicinWhereInput[]
    OR?: AllGenericMedicinWhereInput[]
    NOT?: AllGenericMedicinWhereInput | AllGenericMedicinWhereInput[]
    createdAt?: DateTimeFilter<"AllGenericMedicin"> | Date | string
    updatedAt?: DateTimeFilter<"AllGenericMedicin"> | Date | string
    medicineNameAdd?: MedicineNameAddListRelationFilter
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
  }, "id" | "genericName">

  export type AllGenericMedicinOrderByWithAggregationInput = {
    id?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AllGenericMedicinCountOrderByAggregateInput
    _max?: AllGenericMedicinMaxOrderByAggregateInput
    _min?: AllGenericMedicinMinOrderByAggregateInput
  }

  export type AllGenericMedicinScalarWhereWithAggregatesInput = {
    AND?: AllGenericMedicinScalarWhereWithAggregatesInput | AllGenericMedicinScalarWhereWithAggregatesInput[]
    OR?: AllGenericMedicinScalarWhereWithAggregatesInput[]
    NOT?: AllGenericMedicinScalarWhereWithAggregatesInput | AllGenericMedicinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AllGenericMedicin"> | string
    genericName?: StringWithAggregatesFilter<"AllGenericMedicin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AllGenericMedicin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AllGenericMedicin"> | Date | string
  }

  export type MedicineNameAddWhereInput = {
    AND?: MedicineNameAddWhereInput | MedicineNameAddWhereInput[]
    OR?: MedicineNameAddWhereInput[]
    NOT?: MedicineNameAddWhereInput | MedicineNameAddWhereInput[]
    id?: StringFilter<"MedicineNameAdd"> | string
    name?: StringFilter<"MedicineNameAdd"> | string
    conpany?: StringFilter<"MedicineNameAdd"> | string
    genericName?: StringFilter<"MedicineNameAdd"> | string
    createdAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
  }

  export type MedicineNameAddOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    conpany?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicineCategory?: AllGenericMedicinOrderByWithRelationInput
    medicineStock?: MedicineStockOrderByRelationAggregateInput
    medicinePurchess?: MedicinePurchessOrderByRelationAggregateInput
  }

  export type MedicineNameAddWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MedicineNameAddWhereInput | MedicineNameAddWhereInput[]
    OR?: MedicineNameAddWhereInput[]
    NOT?: MedicineNameAddWhereInput | MedicineNameAddWhereInput[]
    conpany?: StringFilter<"MedicineNameAdd"> | string
    genericName?: StringFilter<"MedicineNameAdd"> | string
    createdAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    medicineStock?: MedicineStockListRelationFilter
    medicinePurchess?: MedicinePurchessListRelationFilter
  }, "id" | "name">

  export type MedicineNameAddOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    conpany?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineNameAddCountOrderByAggregateInput
    _max?: MedicineNameAddMaxOrderByAggregateInput
    _min?: MedicineNameAddMinOrderByAggregateInput
  }

  export type MedicineNameAddScalarWhereWithAggregatesInput = {
    AND?: MedicineNameAddScalarWhereWithAggregatesInput | MedicineNameAddScalarWhereWithAggregatesInput[]
    OR?: MedicineNameAddScalarWhereWithAggregatesInput[]
    NOT?: MedicineNameAddScalarWhereWithAggregatesInput | MedicineNameAddScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicineNameAdd"> | string
    name?: StringWithAggregatesFilter<"MedicineNameAdd"> | string
    conpany?: StringWithAggregatesFilter<"MedicineNameAdd"> | string
    genericName?: StringWithAggregatesFilter<"MedicineNameAdd"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicineNameAdd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineNameAdd"> | Date | string
  }

  export type MedicinePurchessWhereInput = {
    AND?: MedicinePurchessWhereInput | MedicinePurchessWhereInput[]
    OR?: MedicinePurchessWhereInput[]
    NOT?: MedicinePurchessWhereInput | MedicinePurchessWhereInput[]
    id?: StringFilter<"MedicinePurchess"> | string
    genericName?: StringFilter<"MedicinePurchess"> | string
    name?: StringFilter<"MedicinePurchess"> | string
    purchaseUnitPrice?: IntFilter<"MedicinePurchess"> | number
    sellUnitPrice?: IntFilter<"MedicinePurchess"> | number
    purchaseQuantity?: IntFilter<"MedicinePurchess"> | number
    mfgDate?: StringFilter<"MedicinePurchess"> | string
    expDate?: StringFilter<"MedicinePurchess"> | string
    bonusQuantity?: IntNullableFilter<"MedicinePurchess"> | number | null
    purchaseTotalPrice?: IntFilter<"MedicinePurchess"> | number
    supplierInfo?: StringFilter<"MedicinePurchess"> | string
    stored?: EnumStoredFilter<"MedicinePurchess"> | $Enums.Stored
    branchCode?: StringFilter<"MedicinePurchess"> | string
    createdAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
    updatedAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    medicineNameAdd?: XOR<MedicineNameAddScalarRelationFilter, MedicineNameAddWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type MedicinePurchessOrderByWithRelationInput = {
    id?: SortOrder
    genericName?: SortOrder
    name?: SortOrder
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    mfgDate?: SortOrder
    expDate?: SortOrder
    bonusQuantity?: SortOrderInput | SortOrder
    purchaseTotalPrice?: SortOrder
    supplierInfo?: SortOrder
    stored?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicineCategory?: AllGenericMedicinOrderByWithRelationInput
    medicineNameAdd?: MedicineNameAddOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type MedicinePurchessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicinePurchessWhereInput | MedicinePurchessWhereInput[]
    OR?: MedicinePurchessWhereInput[]
    NOT?: MedicinePurchessWhereInput | MedicinePurchessWhereInput[]
    genericName?: StringFilter<"MedicinePurchess"> | string
    name?: StringFilter<"MedicinePurchess"> | string
    purchaseUnitPrice?: IntFilter<"MedicinePurchess"> | number
    sellUnitPrice?: IntFilter<"MedicinePurchess"> | number
    purchaseQuantity?: IntFilter<"MedicinePurchess"> | number
    mfgDate?: StringFilter<"MedicinePurchess"> | string
    expDate?: StringFilter<"MedicinePurchess"> | string
    bonusQuantity?: IntNullableFilter<"MedicinePurchess"> | number | null
    purchaseTotalPrice?: IntFilter<"MedicinePurchess"> | number
    supplierInfo?: StringFilter<"MedicinePurchess"> | string
    stored?: EnumStoredFilter<"MedicinePurchess"> | $Enums.Stored
    branchCode?: StringFilter<"MedicinePurchess"> | string
    createdAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
    updatedAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    medicineNameAdd?: XOR<MedicineNameAddScalarRelationFilter, MedicineNameAddWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id">

  export type MedicinePurchessOrderByWithAggregationInput = {
    id?: SortOrder
    genericName?: SortOrder
    name?: SortOrder
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    mfgDate?: SortOrder
    expDate?: SortOrder
    bonusQuantity?: SortOrderInput | SortOrder
    purchaseTotalPrice?: SortOrder
    supplierInfo?: SortOrder
    stored?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicinePurchessCountOrderByAggregateInput
    _avg?: MedicinePurchessAvgOrderByAggregateInput
    _max?: MedicinePurchessMaxOrderByAggregateInput
    _min?: MedicinePurchessMinOrderByAggregateInput
    _sum?: MedicinePurchessSumOrderByAggregateInput
  }

  export type MedicinePurchessScalarWhereWithAggregatesInput = {
    AND?: MedicinePurchessScalarWhereWithAggregatesInput | MedicinePurchessScalarWhereWithAggregatesInput[]
    OR?: MedicinePurchessScalarWhereWithAggregatesInput[]
    NOT?: MedicinePurchessScalarWhereWithAggregatesInput | MedicinePurchessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    genericName?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    name?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    purchaseUnitPrice?: IntWithAggregatesFilter<"MedicinePurchess"> | number
    sellUnitPrice?: IntWithAggregatesFilter<"MedicinePurchess"> | number
    purchaseQuantity?: IntWithAggregatesFilter<"MedicinePurchess"> | number
    mfgDate?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    expDate?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    bonusQuantity?: IntNullableWithAggregatesFilter<"MedicinePurchess"> | number | null
    purchaseTotalPrice?: IntWithAggregatesFilter<"MedicinePurchess"> | number
    supplierInfo?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    stored?: EnumStoredWithAggregatesFilter<"MedicinePurchess"> | $Enums.Stored
    branchCode?: StringWithAggregatesFilter<"MedicinePurchess"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicinePurchess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicinePurchess"> | Date | string
  }

  export type MedicineStockWhereInput = {
    AND?: MedicineStockWhereInput | MedicineStockWhereInput[]
    OR?: MedicineStockWhereInput[]
    NOT?: MedicineStockWhereInput | MedicineStockWhereInput[]
    id?: StringFilter<"MedicineStock"> | string
    genericName?: StringFilter<"MedicineStock"> | string
    medicineName?: StringFilter<"MedicineStock"> | string
    branchCode?: StringFilter<"MedicineStock"> | string
    totalStock?: IntFilter<"MedicineStock"> | number
    price?: IntFilter<"MedicineStock"> | number
    createdAt?: DateTimeFilter<"MedicineStock"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineStock"> | Date | string
    medicineNameAdd?: XOR<MedicineNameAddScalarRelationFilter, MedicineNameAddWhereInput>
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type MedicineStockOrderByWithRelationInput = {
    id?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    branchCode?: SortOrder
    totalStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicineNameAdd?: MedicineNameAddOrderByWithRelationInput
    medicineCategory?: AllGenericMedicinOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type MedicineStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    genericName_medicineName_branchCode?: MedicineStockGenericNameMedicineNameBranchCodeCompoundUniqueInput
    AND?: MedicineStockWhereInput | MedicineStockWhereInput[]
    OR?: MedicineStockWhereInput[]
    NOT?: MedicineStockWhereInput | MedicineStockWhereInput[]
    genericName?: StringFilter<"MedicineStock"> | string
    medicineName?: StringFilter<"MedicineStock"> | string
    branchCode?: StringFilter<"MedicineStock"> | string
    totalStock?: IntFilter<"MedicineStock"> | number
    price?: IntFilter<"MedicineStock"> | number
    createdAt?: DateTimeFilter<"MedicineStock"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineStock"> | Date | string
    medicineNameAdd?: XOR<MedicineNameAddScalarRelationFilter, MedicineNameAddWhereInput>
    medicineCategory?: XOR<AllGenericMedicinScalarRelationFilter, AllGenericMedicinWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id" | "genericName_medicineName_branchCode">

  export type MedicineStockOrderByWithAggregationInput = {
    id?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    branchCode?: SortOrder
    totalStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineStockCountOrderByAggregateInput
    _avg?: MedicineStockAvgOrderByAggregateInput
    _max?: MedicineStockMaxOrderByAggregateInput
    _min?: MedicineStockMinOrderByAggregateInput
    _sum?: MedicineStockSumOrderByAggregateInput
  }

  export type MedicineStockScalarWhereWithAggregatesInput = {
    AND?: MedicineStockScalarWhereWithAggregatesInput | MedicineStockScalarWhereWithAggregatesInput[]
    OR?: MedicineStockScalarWhereWithAggregatesInput[]
    NOT?: MedicineStockScalarWhereWithAggregatesInput | MedicineStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicineStock"> | string
    genericName?: StringWithAggregatesFilter<"MedicineStock"> | string
    medicineName?: StringWithAggregatesFilter<"MedicineStock"> | string
    branchCode?: StringWithAggregatesFilter<"MedicineStock"> | string
    totalStock?: IntWithAggregatesFilter<"MedicineStock"> | number
    price?: IntWithAggregatesFilter<"MedicineStock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MedicineStock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineStock"> | Date | string
  }

  export type SellMedicineWhereInput = {
    AND?: SellMedicineWhereInput | SellMedicineWhereInput[]
    OR?: SellMedicineWhereInput[]
    NOT?: SellMedicineWhereInput | SellMedicineWhereInput[]
    id?: StringFilter<"SellMedicine"> | string
    billNumber?: IntNullableFilter<"SellMedicine"> | number | null
    farmId?: StringFilter<"SellMedicine"> | string
    flockNumer?: IntFilter<"SellMedicine"> | number
    genericName?: StringFilter<"SellMedicine"> | string
    medicineName?: StringFilter<"SellMedicine"> | string
    sellQuantity?: IntFilter<"SellMedicine"> | number
    sellPrice?: IntFilter<"SellMedicine"> | number
    Delivery?: EnumDeliveryStatusFilter<"SellMedicine"> | $Enums.DeliveryStatus
    sellDate?: StringFilter<"SellMedicine"> | string
    branchCode?: StringFilter<"SellMedicine"> | string
    createdAt?: DateTimeFilter<"SellMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"SellMedicine"> | Date | string
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
    MedicineTransfer?: MedicineTransferListRelationFilter
  }

  export type SellMedicineOrderByWithRelationInput = {
    id?: SortOrder
    billNumber?: SortOrderInput | SortOrder
    farmId?: SortOrder
    flockNumer?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
    Delivery?: SortOrder
    sellDate?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flock?: FlockOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    farmer?: FarmerOrderByWithRelationInput
    MedicineTransfer?: MedicineTransferOrderByRelationAggregateInput
  }

  export type SellMedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    billNumber?: number
    AND?: SellMedicineWhereInput | SellMedicineWhereInput[]
    OR?: SellMedicineWhereInput[]
    NOT?: SellMedicineWhereInput | SellMedicineWhereInput[]
    farmId?: StringFilter<"SellMedicine"> | string
    flockNumer?: IntFilter<"SellMedicine"> | number
    genericName?: StringFilter<"SellMedicine"> | string
    medicineName?: StringFilter<"SellMedicine"> | string
    sellQuantity?: IntFilter<"SellMedicine"> | number
    sellPrice?: IntFilter<"SellMedicine"> | number
    Delivery?: EnumDeliveryStatusFilter<"SellMedicine"> | $Enums.DeliveryStatus
    sellDate?: StringFilter<"SellMedicine"> | string
    branchCode?: StringFilter<"SellMedicine"> | string
    createdAt?: DateTimeFilter<"SellMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"SellMedicine"> | Date | string
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    farmer?: XOR<FarmerScalarRelationFilter, FarmerWhereInput>
    MedicineTransfer?: MedicineTransferListRelationFilter
  }, "id" | "billNumber">

  export type SellMedicineOrderByWithAggregationInput = {
    id?: SortOrder
    billNumber?: SortOrderInput | SortOrder
    farmId?: SortOrder
    flockNumer?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
    Delivery?: SortOrder
    sellDate?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellMedicineCountOrderByAggregateInput
    _avg?: SellMedicineAvgOrderByAggregateInput
    _max?: SellMedicineMaxOrderByAggregateInput
    _min?: SellMedicineMinOrderByAggregateInput
    _sum?: SellMedicineSumOrderByAggregateInput
  }

  export type SellMedicineScalarWhereWithAggregatesInput = {
    AND?: SellMedicineScalarWhereWithAggregatesInput | SellMedicineScalarWhereWithAggregatesInput[]
    OR?: SellMedicineScalarWhereWithAggregatesInput[]
    NOT?: SellMedicineScalarWhereWithAggregatesInput | SellMedicineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellMedicine"> | string
    billNumber?: IntNullableWithAggregatesFilter<"SellMedicine"> | number | null
    farmId?: StringWithAggregatesFilter<"SellMedicine"> | string
    flockNumer?: IntWithAggregatesFilter<"SellMedicine"> | number
    genericName?: StringWithAggregatesFilter<"SellMedicine"> | string
    medicineName?: StringWithAggregatesFilter<"SellMedicine"> | string
    sellQuantity?: IntWithAggregatesFilter<"SellMedicine"> | number
    sellPrice?: IntWithAggregatesFilter<"SellMedicine"> | number
    Delivery?: EnumDeliveryStatusWithAggregatesFilter<"SellMedicine"> | $Enums.DeliveryStatus
    sellDate?: StringWithAggregatesFilter<"SellMedicine"> | string
    branchCode?: StringWithAggregatesFilter<"SellMedicine"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SellMedicine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellMedicine"> | Date | string
  }

  export type MedicineTransferWhereInput = {
    AND?: MedicineTransferWhereInput | MedicineTransferWhereInput[]
    OR?: MedicineTransferWhereInput[]
    NOT?: MedicineTransferWhereInput | MedicineTransferWhereInput[]
    id?: StringFilter<"MedicineTransfer"> | string
    billNumber?: IntFilter<"MedicineTransfer"> | number
    flockId?: StringFilter<"MedicineTransfer"> | string
    fromFarmcode?: IntNullableFilter<"MedicineTransfer"> | number | null
    toFarmcode?: IntFilter<"MedicineTransfer"> | number
    medicineName?: StringFilter<"MedicineTransfer"> | string
    genericName?: StringFilter<"MedicineTransfer"> | string
    branchCode?: StringFilter<"MedicineTransfer"> | string
    createdAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
    sellmedicine?: XOR<SellMedicineScalarRelationFilter, SellMedicineWhereInput>
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    baranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }

  export type MedicineTransferOrderByWithRelationInput = {
    id?: SortOrder
    billNumber?: SortOrder
    flockId?: SortOrder
    fromFarmcode?: SortOrderInput | SortOrder
    toFarmcode?: SortOrder
    medicineName?: SortOrder
    genericName?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sellmedicine?: SellMedicineOrderByWithRelationInput
    flock?: FlockOrderByWithRelationInput
    baranch?: BranchOrderByWithRelationInput
  }

  export type MedicineTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicineTransferWhereInput | MedicineTransferWhereInput[]
    OR?: MedicineTransferWhereInput[]
    NOT?: MedicineTransferWhereInput | MedicineTransferWhereInput[]
    billNumber?: IntFilter<"MedicineTransfer"> | number
    flockId?: StringFilter<"MedicineTransfer"> | string
    fromFarmcode?: IntNullableFilter<"MedicineTransfer"> | number | null
    toFarmcode?: IntFilter<"MedicineTransfer"> | number
    medicineName?: StringFilter<"MedicineTransfer"> | string
    genericName?: StringFilter<"MedicineTransfer"> | string
    branchCode?: StringFilter<"MedicineTransfer"> | string
    createdAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
    sellmedicine?: XOR<SellMedicineScalarRelationFilter, SellMedicineWhereInput>
    flock?: XOR<FlockScalarRelationFilter, FlockWhereInput>
    baranch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
  }, "id">

  export type MedicineTransferOrderByWithAggregationInput = {
    id?: SortOrder
    billNumber?: SortOrder
    flockId?: SortOrder
    fromFarmcode?: SortOrderInput | SortOrder
    toFarmcode?: SortOrder
    medicineName?: SortOrder
    genericName?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineTransferCountOrderByAggregateInput
    _avg?: MedicineTransferAvgOrderByAggregateInput
    _max?: MedicineTransferMaxOrderByAggregateInput
    _min?: MedicineTransferMinOrderByAggregateInput
    _sum?: MedicineTransferSumOrderByAggregateInput
  }

  export type MedicineTransferScalarWhereWithAggregatesInput = {
    AND?: MedicineTransferScalarWhereWithAggregatesInput | MedicineTransferScalarWhereWithAggregatesInput[]
    OR?: MedicineTransferScalarWhereWithAggregatesInput[]
    NOT?: MedicineTransferScalarWhereWithAggregatesInput | MedicineTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicineTransfer"> | string
    billNumber?: IntWithAggregatesFilter<"MedicineTransfer"> | number
    flockId?: StringWithAggregatesFilter<"MedicineTransfer"> | string
    fromFarmcode?: IntNullableWithAggregatesFilter<"MedicineTransfer"> | number | null
    toFarmcode?: IntWithAggregatesFilter<"MedicineTransfer"> | number
    medicineName?: StringWithAggregatesFilter<"MedicineTransfer"> | string
    genericName?: StringWithAggregatesFilter<"MedicineTransfer"> | string
    branchCode?: StringWithAggregatesFilter<"MedicineTransfer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicineTransfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineTransfer"> | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmerCreateInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFarmerInput
    address?: AddressCreateNestedOneWithoutFarmerInput
    flocks?: FlockCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFarmerNestedInput
    address?: AddressUpdateOneWithoutFarmerNestedInput
    flocks?: FlockUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerCreateManyInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FarmerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FarmerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Farmer?: FarmerCreateNestedOneWithoutAddressInput
    Employee?: EmployeeCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Farmer?: FarmerUncheckedCreateNestedOneWithoutAddressInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Farmer?: FarmerUpdateOneWithoutAddressNestedInput
    Employee?: EmployeeUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Farmer?: FarmerUncheckedUpdateOneWithoutAddressNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryCreateInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBranchEmployeeHistoryInput
    employee: EmployeeCreateNestedOneWithoutBranchEmployeeHistoryInput
  }

  export type BranchEmployeeHistoryUncheckedCreateInput = {
    id?: string
    employeeId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput
  }

  export type BranchEmployeeHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryCreateManyInput = {
    id?: string
    employeeId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutEmployeeInput
    flocks?: FlockCreateNestedManyWithoutEmployeeInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    addressId?: string | null
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutEmployeeInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutEmployeeNestedInput
    flocks?: FlockUpdateManyWithoutEmployeeNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutEmployeeNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    addressId?: string | null
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockCreateInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type FlockCreateManyInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportCreateInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFlockReportInput
    flock: FlockCreateNestedOneWithoutFlockReportInput
    farmer: FarmerCreateNestedOneWithoutFlockReportInput
  }

  export type FlockReportUncheckedCreateInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFlockReportNestedInput
    flock?: FlockUpdateOneRequiredWithoutFlockReportNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutFlockReportNestedInput
  }

  export type FlockReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportCreateManyInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedNameCategoryCreateInput = {
    id?: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date | string
    updatedAt?: Date | string
    feeds?: FeedCreateNestedManyWithoutFeedNameCategoryInput
  }

  export type FeedNameCategoryUncheckedCreateInput = {
    id?: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date | string
    updatedAt?: Date | string
    feeds?: FeedUncheckedCreateNestedManyWithoutFeedNameCategoryInput
  }

  export type FeedNameCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeds?: FeedUpdateManyWithoutFeedNameCategoryNestedInput
  }

  export type FeedNameCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeds?: FeedUncheckedUpdateManyWithoutFeedNameCategoryNestedInput
  }

  export type FeedNameCategoryCreateManyInput = {
    id?: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedNameCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedNameCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCreateInput = {
    id?: string
    stock: number
    createdAt: Date | string
    updatedAt?: Date | string
    feedNameCategory: FeedNameCategoryCreateNestedOneWithoutFeedsInput
    branch?: BranchCreateNestedOneWithoutFeedInput
  }

  export type FeedUncheckedCreateInput = {
    id?: string
    feedName: string
    stock: number
    branchCode?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedNameCategory?: FeedNameCategoryUpdateOneRequiredWithoutFeedsNestedInput
    branch?: BranchUpdateOneWithoutFeedNestedInput
  }

  export type FeedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCreateManyInput = {
    id?: string
    feedName: string
    stock: number
    branchCode?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllGenericMedicinCreateInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddCreateNestedManyWithoutMedicineCategoryInput
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinUncheckedCreateInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddUncheckedCreateNestedManyWithoutMedicineCategoryInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateManyWithoutMedicineCategoryNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type AllGenericMedicinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type AllGenericMedicinCreateManyInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AllGenericMedicinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllGenericMedicinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineNameAddCreateInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineNameAddInput
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineNameAddInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddUncheckedCreateInput = {
    id?: string
    name: string
    conpany: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineNameAddInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineNameAddNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutMedicineNameAddNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineNameAddNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddCreateManyInput = {
    id?: string
    name: string
    conpany: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineNameAddUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineNameAddUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessCreateInput = {
    id?: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicinePurchessInput
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicinePurchessInput
    branch: BranchCreateNestedOneWithoutMedicinePurchessInput
  }

  export type MedicinePurchessUncheckedCreateInput = {
    id?: string
    genericName: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicinePurchessNestedInput
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicinePurchessNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicinePurchessNestedInput
  }

  export type MedicinePurchessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessCreateManyInput = {
    id?: string
    genericName: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockCreateInput = {
    id?: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicineStockInput
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineStockInput
    branch: BranchCreateNestedOneWithoutMedicineStockInput
  }

  export type MedicineStockUncheckedCreateInput = {
    id?: string
    genericName: string
    medicineName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicineStockNestedInput
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineStockNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicineStockNestedInput
  }

  export type MedicineStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockCreateManyInput = {
    id?: string
    genericName: string
    medicineName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellMedicineCreateInput = {
    id?: string
    billNumber?: number | null
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutSellMedicineInput
    branch: BranchCreateNestedOneWithoutSellMedicineInput
    farmer: FarmerCreateNestedOneWithoutSellMedicineInput
    MedicineTransfer?: MedicineTransferCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineUncheckedCreateInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    MedicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutSellMedicineNestedInput
    branch?: BranchUpdateOneRequiredWithoutSellMedicineNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutSellMedicineNestedInput
    MedicineTransfer?: MedicineTransferUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MedicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineCreateManyInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type SellMedicineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellMedicineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferCreateInput = {
    id?: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    sellmedicine: SellMedicineCreateNestedOneWithoutMedicineTransferInput
    flock: FlockCreateNestedOneWithoutMedicineTransferInput
    baranch: BranchCreateNestedOneWithoutMedicineTransferInput
  }

  export type MedicineTransferUncheckedCreateInput = {
    id?: string
    billNumber: number
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellmedicine?: SellMedicineUpdateOneRequiredWithoutMedicineTransferNestedInput
    flock?: FlockUpdateOneRequiredWithoutMedicineTransferNestedInput
    baranch?: BranchUpdateOneRequiredWithoutMedicineTransferNestedInput
  }

  export type MedicineTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferCreateManyInput = {
    id?: string
    billNumber: number
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FarmerListRelationFilter = {
    every?: FarmerWhereInput
    some?: FarmerWhereInput
    none?: FarmerWhereInput
  }

  export type FlockListRelationFilter = {
    every?: FlockWhereInput
    some?: FlockWhereInput
    none?: FlockWhereInput
  }

  export type FeedListRelationFilter = {
    every?: FeedWhereInput
    some?: FeedWhereInput
    none?: FeedWhereInput
  }

  export type MedicineStockListRelationFilter = {
    every?: MedicineStockWhereInput
    some?: MedicineStockWhereInput
    none?: MedicineStockWhereInput
  }

  export type MedicinePurchessListRelationFilter = {
    every?: MedicinePurchessWhereInput
    some?: MedicinePurchessWhereInput
    none?: MedicinePurchessWhereInput
  }

  export type SellMedicineListRelationFilter = {
    every?: SellMedicineWhereInput
    some?: SellMedicineWhereInput
    none?: SellMedicineWhereInput
  }

  export type MedicineTransferListRelationFilter = {
    every?: MedicineTransferWhereInput
    some?: MedicineTransferWhereInput
    none?: MedicineTransferWhereInput
  }

  export type FlockReportListRelationFilter = {
    every?: FlockReportWhereInput
    some?: FlockReportWhereInput
    none?: FlockReportWhereInput
  }

  export type BranchEmployeeHistoryListRelationFilter = {
    every?: BranchEmployeeHistoryWhereInput
    some?: BranchEmployeeHistoryWhereInput
    none?: BranchEmployeeHistoryWhereInput
  }

  export type FarmerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicinePurchessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellMedicineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlockReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchEmployeeHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    type?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    type?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    type?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCusttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Custtype | EnumCusttypeFieldRefInput<$PrismaModel>
    in?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCusttypeFilter<$PrismaModel> | $Enums.Custtype
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FarmerBranchCodeFarmCodeCompoundUniqueInput = {
    branchCode: string
    farmCode: number
  }

  export type FarmerCountOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    farmCode?: SortOrder
    name?: SortOrder
    farmType?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    phoneNumber?: SortOrder
    capacity?: SortOrder
    addressId?: SortOrder
    nid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmerAvgOrderByAggregateInput = {
    farmCode?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    capacity?: SortOrder
  }

  export type FarmerMaxOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    farmCode?: SortOrder
    name?: SortOrder
    farmType?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    phoneNumber?: SortOrder
    capacity?: SortOrder
    addressId?: SortOrder
    nid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmerMinOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    farmCode?: SortOrder
    name?: SortOrder
    farmType?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    phoneNumber?: SortOrder
    capacity?: SortOrder
    addressId?: SortOrder
    nid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FarmerSumOrderByAggregateInput = {
    farmCode?: SortOrder
    totalShed?: SortOrder
    totalSquare?: SortOrder
    capacity?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCusttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Custtype | EnumCusttypeFieldRefInput<$PrismaModel>
    in?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCusttypeWithAggregatesFilter<$PrismaModel> | $Enums.Custtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCusttypeFilter<$PrismaModel>
    _max?: NestedEnumCusttypeFilter<$PrismaModel>
  }

  export type FarmerNullableScalarRelationFilter = {
    is?: FarmerWhereInput | null
    isNot?: FarmerWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    village?: SortOrder
    post?: SortOrder
    union?: SortOrder
    thana?: SortOrder
    upazila?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    village?: SortOrder
    post?: SortOrder
    union?: SortOrder
    thana?: SortOrder
    upazila?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    village?: SortOrder
    post?: SortOrder
    union?: SortOrder
    thana?: SortOrder
    upazila?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type BranchEmployeeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchEmployeeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchEmployeeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    workingLocation?: SortOrder
    designation?: SortOrder
    phoneNumber?: SortOrder
    addressId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    workingLocation?: SortOrder
    designation?: SortOrder
    phoneNumber?: SortOrder
    addressId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    workingLocation?: SortOrder
    designation?: SortOrder
    phoneNumber?: SortOrder
    addressId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFlockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlockStatus | EnumFlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlockStatusFilter<$PrismaModel> | $Enums.FlockStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FarmerScalarRelationFilter = {
    is?: FarmerWhereInput
    isNot?: FarmerWhereInput
  }

  export type FlockCountOrderByAggregateInput = {
    id?: SortOrder
    flockNumber?: SortOrder
    flockStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    executiveId?: SortOrder
    farmId?: SortOrder
    docName?: SortOrder
    docQuantity?: SortOrder
    approvedBy?: SortOrder
    branchCode?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockAvgOrderByAggregateInput = {
    flockNumber?: SortOrder
    docQuantity?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
  }

  export type FlockMaxOrderByAggregateInput = {
    id?: SortOrder
    flockNumber?: SortOrder
    flockStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    executiveId?: SortOrder
    farmId?: SortOrder
    docName?: SortOrder
    docQuantity?: SortOrder
    approvedBy?: SortOrder
    branchCode?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockMinOrderByAggregateInput = {
    id?: SortOrder
    flockNumber?: SortOrder
    flockStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    executiveId?: SortOrder
    farmId?: SortOrder
    docName?: SortOrder
    docQuantity?: SortOrder
    approvedBy?: SortOrder
    branchCode?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockSumOrderByAggregateInput = {
    flockNumber?: SortOrder
    docQuantity?: SortOrder
    totalFeedKg?: SortOrder
    totalMedicine?: SortOrder
    fcr?: SortOrder
    totalSellBirds?: SortOrder
    mortality?: SortOrder
  }

  export type EnumFlockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlockStatus | EnumFlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlockStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlockStatusFilter<$PrismaModel>
    _max?: NestedEnumFlockStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FlockScalarRelationFilter = {
    is?: FlockWhereInput
    isNot?: FlockWhereInput
  }

  export type FlockReportCountOrderByAggregateInput = {
    id?: SortOrder
    housedBirds?: SortOrder
    fcr?: SortOrder
    executiveId?: SortOrder
    totalMortality?: SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrder
    totalMortalityPercentage?: SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    suggestTosell?: SortOrder
    averageBodyWight?: SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    diseases?: SortOrder
    birdsStock?: SortOrder
    condition?: SortOrder
    description?: SortOrder
    executiveName?: SortOrder
    flockNumber?: SortOrder
    age?: SortOrder
    imagesOne?: SortOrder
    imageTwo?: SortOrder
    imageThree?: SortOrder
    visitedDate?: SortOrder
    locationLink?: SortOrder
    farmId?: SortOrder
    flockId?: SortOrder
    birdsSalesStart?: SortOrder
    birdsSalesEnd?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockReportAvgOrderByAggregateInput = {
    housedBirds?: SortOrder
    fcr?: SortOrder
    totalMortality?: SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrder
    totalMortalityPercentage?: SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    averageBodyWight?: SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    birdsStock?: SortOrder
    age?: SortOrder
  }

  export type FlockReportMaxOrderByAggregateInput = {
    id?: SortOrder
    housedBirds?: SortOrder
    fcr?: SortOrder
    executiveId?: SortOrder
    totalMortality?: SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrder
    totalMortalityPercentage?: SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    suggestTosell?: SortOrder
    averageBodyWight?: SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    diseases?: SortOrder
    birdsStock?: SortOrder
    condition?: SortOrder
    description?: SortOrder
    executiveName?: SortOrder
    flockNumber?: SortOrder
    age?: SortOrder
    imagesOne?: SortOrder
    imageTwo?: SortOrder
    imageThree?: SortOrder
    visitedDate?: SortOrder
    locationLink?: SortOrder
    farmId?: SortOrder
    flockId?: SortOrder
    birdsSalesStart?: SortOrder
    birdsSalesEnd?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockReportMinOrderByAggregateInput = {
    id?: SortOrder
    housedBirds?: SortOrder
    fcr?: SortOrder
    executiveId?: SortOrder
    totalMortality?: SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrder
    totalMortalityPercentage?: SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    suggestTosell?: SortOrder
    averageBodyWight?: SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    diseases?: SortOrder
    birdsStock?: SortOrder
    condition?: SortOrder
    description?: SortOrder
    executiveName?: SortOrder
    flockNumber?: SortOrder
    age?: SortOrder
    imagesOne?: SortOrder
    imageTwo?: SortOrder
    imageThree?: SortOrder
    visitedDate?: SortOrder
    locationLink?: SortOrder
    farmId?: SortOrder
    flockId?: SortOrder
    birdsSalesStart?: SortOrder
    birdsSalesEnd?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlockReportSumOrderByAggregateInput = {
    housedBirds?: SortOrder
    fcr?: SortOrder
    totalMortality?: SortOrder
    todayMortality?: SortOrder
    todayMortalityPercent?: SortOrder
    totalMortalityPercentage?: SortOrder
    bodyWeight?: SortOrder
    todayWeightGain?: SortOrder
    todayFeedEting?: SortOrder
    averageBodyWight?: SortOrder
    totalFeedEting?: SortOrder
    feedStock?: SortOrder
    birdsStock?: SortOrder
    age?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FeedNameCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    feedCodeNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedNameCategoryAvgOrderByAggregateInput = {
    feedCodeNumber?: SortOrder
  }

  export type FeedNameCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    feedCodeNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedNameCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    feedCodeNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedNameCategorySumOrderByAggregateInput = {
    feedCodeNumber?: SortOrder
  }

  export type FeedNameCategoryScalarRelationFilter = {
    is?: FeedNameCategoryWhereInput
    isNot?: FeedNameCategoryWhereInput
  }

  export type FeedCountOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    stock?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedAvgOrderByAggregateInput = {
    stock?: SortOrder
  }

  export type FeedMaxOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    stock?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedMinOrderByAggregateInput = {
    id?: SortOrder
    feedName?: SortOrder
    stock?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedSumOrderByAggregateInput = {
    stock?: SortOrder
  }

  export type MedicineNameAddListRelationFilter = {
    every?: MedicineNameAddWhereInput
    some?: MedicineNameAddWhereInput
    none?: MedicineNameAddWhereInput
  }

  export type MedicineNameAddOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllGenericMedicinCountOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllGenericMedicinMaxOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllGenericMedicinMinOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AllGenericMedicinScalarRelationFilter = {
    is?: AllGenericMedicinWhereInput
    isNot?: AllGenericMedicinWhereInput
  }

  export type MedicineNameAddCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conpany?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineNameAddMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conpany?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineNameAddMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    conpany?: SortOrder
    genericName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoredFilter<$PrismaModel = never> = {
    equals?: $Enums.Stored | EnumStoredFieldRefInput<$PrismaModel>
    in?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    not?: NestedEnumStoredFilter<$PrismaModel> | $Enums.Stored
  }

  export type MedicineNameAddScalarRelationFilter = {
    is?: MedicineNameAddWhereInput
    isNot?: MedicineNameAddWhereInput
  }

  export type MedicinePurchessCountOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    name?: SortOrder
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    mfgDate?: SortOrder
    expDate?: SortOrder
    bonusQuantity?: SortOrder
    purchaseTotalPrice?: SortOrder
    supplierInfo?: SortOrder
    stored?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicinePurchessAvgOrderByAggregateInput = {
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    bonusQuantity?: SortOrder
    purchaseTotalPrice?: SortOrder
  }

  export type MedicinePurchessMaxOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    name?: SortOrder
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    mfgDate?: SortOrder
    expDate?: SortOrder
    bonusQuantity?: SortOrder
    purchaseTotalPrice?: SortOrder
    supplierInfo?: SortOrder
    stored?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicinePurchessMinOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    name?: SortOrder
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    mfgDate?: SortOrder
    expDate?: SortOrder
    bonusQuantity?: SortOrder
    purchaseTotalPrice?: SortOrder
    supplierInfo?: SortOrder
    stored?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicinePurchessSumOrderByAggregateInput = {
    purchaseUnitPrice?: SortOrder
    sellUnitPrice?: SortOrder
    purchaseQuantity?: SortOrder
    bonusQuantity?: SortOrder
    purchaseTotalPrice?: SortOrder
  }

  export type EnumStoredWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stored | EnumStoredFieldRefInput<$PrismaModel>
    in?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    not?: NestedEnumStoredWithAggregatesFilter<$PrismaModel> | $Enums.Stored
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoredFilter<$PrismaModel>
    _max?: NestedEnumStoredFilter<$PrismaModel>
  }

  export type MedicineStockGenericNameMedicineNameBranchCodeCompoundUniqueInput = {
    genericName: string
    medicineName: string
    branchCode: string
  }

  export type MedicineStockCountOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    branchCode?: SortOrder
    totalStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineStockAvgOrderByAggregateInput = {
    totalStock?: SortOrder
    price?: SortOrder
  }

  export type MedicineStockMaxOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    branchCode?: SortOrder
    totalStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineStockMinOrderByAggregateInput = {
    id?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    branchCode?: SortOrder
    totalStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineStockSumOrderByAggregateInput = {
    totalStock?: SortOrder
    price?: SortOrder
  }

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type SellMedicineCountOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    farmId?: SortOrder
    flockNumer?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
    Delivery?: SortOrder
    sellDate?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellMedicineAvgOrderByAggregateInput = {
    billNumber?: SortOrder
    flockNumer?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
  }

  export type SellMedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    farmId?: SortOrder
    flockNumer?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
    Delivery?: SortOrder
    sellDate?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellMedicineMinOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    farmId?: SortOrder
    flockNumer?: SortOrder
    genericName?: SortOrder
    medicineName?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
    Delivery?: SortOrder
    sellDate?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellMedicineSumOrderByAggregateInput = {
    billNumber?: SortOrder
    flockNumer?: SortOrder
    sellQuantity?: SortOrder
    sellPrice?: SortOrder
  }

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type SellMedicineScalarRelationFilter = {
    is?: SellMedicineWhereInput
    isNot?: SellMedicineWhereInput
  }

  export type MedicineTransferCountOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    flockId?: SortOrder
    fromFarmcode?: SortOrder
    toFarmcode?: SortOrder
    medicineName?: SortOrder
    genericName?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineTransferAvgOrderByAggregateInput = {
    billNumber?: SortOrder
    fromFarmcode?: SortOrder
    toFarmcode?: SortOrder
  }

  export type MedicineTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    flockId?: SortOrder
    fromFarmcode?: SortOrder
    toFarmcode?: SortOrder
    medicineName?: SortOrder
    genericName?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineTransferMinOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    flockId?: SortOrder
    fromFarmcode?: SortOrder
    toFarmcode?: SortOrder
    medicineName?: SortOrder
    genericName?: SortOrder
    branchCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineTransferSumOrderByAggregateInput = {
    billNumber?: SortOrder
    fromFarmcode?: SortOrder
    toFarmcode?: SortOrder
  }

  export type FarmerCreateNestedManyWithoutBranchInput = {
    create?: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput> | FarmerCreateWithoutBranchInput[] | FarmerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FarmerCreateOrConnectWithoutBranchInput | FarmerCreateOrConnectWithoutBranchInput[]
    createMany?: FarmerCreateManyBranchInputEnvelope
    connect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
  }

  export type FlockCreateNestedManyWithoutBranchInput = {
    create?: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput> | FlockCreateWithoutBranchInput[] | FlockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutBranchInput | FlockCreateOrConnectWithoutBranchInput[]
    createMany?: FlockCreateManyBranchInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type FeedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput> | FeedCreateWithoutBranchInput[] | FeedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutBranchInput | FeedCreateOrConnectWithoutBranchInput[]
    createMany?: FeedCreateManyBranchInputEnvelope
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
  }

  export type MedicineStockCreateNestedManyWithoutBranchInput = {
    create?: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput> | MedicineStockCreateWithoutBranchInput[] | MedicineStockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutBranchInput | MedicineStockCreateOrConnectWithoutBranchInput[]
    createMany?: MedicineStockCreateManyBranchInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessCreateNestedManyWithoutBranchInput = {
    create?: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput> | MedicinePurchessCreateWithoutBranchInput[] | MedicinePurchessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutBranchInput | MedicinePurchessCreateOrConnectWithoutBranchInput[]
    createMany?: MedicinePurchessCreateManyBranchInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type SellMedicineCreateNestedManyWithoutBranchInput = {
    create?: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput> | SellMedicineCreateWithoutBranchInput[] | SellMedicineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutBranchInput | SellMedicineCreateOrConnectWithoutBranchInput[]
    createMany?: SellMedicineCreateManyBranchInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type MedicineTransferCreateNestedManyWithoutBaranchInput = {
    create?: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput> | MedicineTransferCreateWithoutBaranchInput[] | MedicineTransferUncheckedCreateWithoutBaranchInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutBaranchInput | MedicineTransferCreateOrConnectWithoutBaranchInput[]
    createMany?: MedicineTransferCreateManyBaranchInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type FlockReportCreateNestedManyWithoutBranchInput = {
    create?: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput> | FlockReportCreateWithoutBranchInput[] | FlockReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutBranchInput | FlockReportCreateOrConnectWithoutBranchInput[]
    createMany?: FlockReportCreateManyBranchInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type BranchEmployeeHistoryCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput> | BranchEmployeeHistoryCreateWithoutBranchInput[] | BranchEmployeeHistoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutBranchInput | BranchEmployeeHistoryCreateOrConnectWithoutBranchInput[]
    createMany?: BranchEmployeeHistoryCreateManyBranchInputEnvelope
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
  }

  export type FarmerUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput> | FarmerCreateWithoutBranchInput[] | FarmerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FarmerCreateOrConnectWithoutBranchInput | FarmerCreateOrConnectWithoutBranchInput[]
    createMany?: FarmerCreateManyBranchInputEnvelope
    connect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
  }

  export type FlockUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput> | FlockCreateWithoutBranchInput[] | FlockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutBranchInput | FlockCreateOrConnectWithoutBranchInput[]
    createMany?: FlockCreateManyBranchInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type FeedUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput> | FeedCreateWithoutBranchInput[] | FeedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutBranchInput | FeedCreateOrConnectWithoutBranchInput[]
    createMany?: FeedCreateManyBranchInputEnvelope
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
  }

  export type MedicineStockUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput> | MedicineStockCreateWithoutBranchInput[] | MedicineStockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutBranchInput | MedicineStockCreateOrConnectWithoutBranchInput[]
    createMany?: MedicineStockCreateManyBranchInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput> | MedicinePurchessCreateWithoutBranchInput[] | MedicinePurchessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutBranchInput | MedicinePurchessCreateOrConnectWithoutBranchInput[]
    createMany?: MedicinePurchessCreateManyBranchInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type SellMedicineUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput> | SellMedicineCreateWithoutBranchInput[] | SellMedicineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutBranchInput | SellMedicineCreateOrConnectWithoutBranchInput[]
    createMany?: SellMedicineCreateManyBranchInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput = {
    create?: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput> | MedicineTransferCreateWithoutBaranchInput[] | MedicineTransferUncheckedCreateWithoutBaranchInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutBaranchInput | MedicineTransferCreateOrConnectWithoutBaranchInput[]
    createMany?: MedicineTransferCreateManyBaranchInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type FlockReportUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput> | FlockReportCreateWithoutBranchInput[] | FlockReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutBranchInput | FlockReportCreateOrConnectWithoutBranchInput[]
    createMany?: FlockReportCreateManyBranchInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput> | BranchEmployeeHistoryCreateWithoutBranchInput[] | BranchEmployeeHistoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutBranchInput | BranchEmployeeHistoryCreateOrConnectWithoutBranchInput[]
    createMany?: BranchEmployeeHistoryCreateManyBranchInputEnvelope
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumBranchTypeFieldUpdateOperationsInput = {
    set?: $Enums.BranchType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FarmerUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput> | FarmerCreateWithoutBranchInput[] | FarmerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FarmerCreateOrConnectWithoutBranchInput | FarmerCreateOrConnectWithoutBranchInput[]
    upsert?: FarmerUpsertWithWhereUniqueWithoutBranchInput | FarmerUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FarmerCreateManyBranchInputEnvelope
    set?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    disconnect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    delete?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    connect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    update?: FarmerUpdateWithWhereUniqueWithoutBranchInput | FarmerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FarmerUpdateManyWithWhereWithoutBranchInput | FarmerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FarmerScalarWhereInput | FarmerScalarWhereInput[]
  }

  export type FlockUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput> | FlockCreateWithoutBranchInput[] | FlockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutBranchInput | FlockCreateOrConnectWithoutBranchInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutBranchInput | FlockUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FlockCreateManyBranchInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutBranchInput | FlockUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutBranchInput | FlockUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type FeedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput> | FeedCreateWithoutBranchInput[] | FeedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutBranchInput | FeedCreateOrConnectWithoutBranchInput[]
    upsert?: FeedUpsertWithWhereUniqueWithoutBranchInput | FeedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FeedCreateManyBranchInputEnvelope
    set?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    disconnect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    delete?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    update?: FeedUpdateWithWhereUniqueWithoutBranchInput | FeedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FeedUpdateManyWithWhereWithoutBranchInput | FeedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FeedScalarWhereInput | FeedScalarWhereInput[]
  }

  export type MedicineStockUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput> | MedicineStockCreateWithoutBranchInput[] | MedicineStockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutBranchInput | MedicineStockCreateOrConnectWithoutBranchInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutBranchInput | MedicineStockUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MedicineStockCreateManyBranchInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutBranchInput | MedicineStockUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutBranchInput | MedicineStockUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput> | MedicinePurchessCreateWithoutBranchInput[] | MedicinePurchessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutBranchInput | MedicinePurchessCreateOrConnectWithoutBranchInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutBranchInput | MedicinePurchessUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MedicinePurchessCreateManyBranchInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutBranchInput | MedicinePurchessUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutBranchInput | MedicinePurchessUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type SellMedicineUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput> | SellMedicineCreateWithoutBranchInput[] | SellMedicineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutBranchInput | SellMedicineCreateOrConnectWithoutBranchInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutBranchInput | SellMedicineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SellMedicineCreateManyBranchInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutBranchInput | SellMedicineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutBranchInput | SellMedicineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type MedicineTransferUpdateManyWithoutBaranchNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput> | MedicineTransferCreateWithoutBaranchInput[] | MedicineTransferUncheckedCreateWithoutBaranchInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutBaranchInput | MedicineTransferCreateOrConnectWithoutBaranchInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutBaranchInput | MedicineTransferUpsertWithWhereUniqueWithoutBaranchInput[]
    createMany?: MedicineTransferCreateManyBaranchInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutBaranchInput | MedicineTransferUpdateWithWhereUniqueWithoutBaranchInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutBaranchInput | MedicineTransferUpdateManyWithWhereWithoutBaranchInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type FlockReportUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput> | FlockReportCreateWithoutBranchInput[] | FlockReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutBranchInput | FlockReportCreateOrConnectWithoutBranchInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutBranchInput | FlockReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FlockReportCreateManyBranchInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutBranchInput | FlockReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutBranchInput | FlockReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput> | BranchEmployeeHistoryCreateWithoutBranchInput[] | BranchEmployeeHistoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutBranchInput | BranchEmployeeHistoryCreateOrConnectWithoutBranchInput[]
    upsert?: BranchEmployeeHistoryUpsertWithWhereUniqueWithoutBranchInput | BranchEmployeeHistoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchEmployeeHistoryCreateManyBranchInputEnvelope
    set?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    disconnect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    delete?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    update?: BranchEmployeeHistoryUpdateWithWhereUniqueWithoutBranchInput | BranchEmployeeHistoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchEmployeeHistoryUpdateManyWithWhereWithoutBranchInput | BranchEmployeeHistoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
  }

  export type FarmerUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput> | FarmerCreateWithoutBranchInput[] | FarmerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FarmerCreateOrConnectWithoutBranchInput | FarmerCreateOrConnectWithoutBranchInput[]
    upsert?: FarmerUpsertWithWhereUniqueWithoutBranchInput | FarmerUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FarmerCreateManyBranchInputEnvelope
    set?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    disconnect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    delete?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    connect?: FarmerWhereUniqueInput | FarmerWhereUniqueInput[]
    update?: FarmerUpdateWithWhereUniqueWithoutBranchInput | FarmerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FarmerUpdateManyWithWhereWithoutBranchInput | FarmerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FarmerScalarWhereInput | FarmerScalarWhereInput[]
  }

  export type FlockUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput> | FlockCreateWithoutBranchInput[] | FlockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutBranchInput | FlockCreateOrConnectWithoutBranchInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutBranchInput | FlockUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FlockCreateManyBranchInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutBranchInput | FlockUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutBranchInput | FlockUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type FeedUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput> | FeedCreateWithoutBranchInput[] | FeedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutBranchInput | FeedCreateOrConnectWithoutBranchInput[]
    upsert?: FeedUpsertWithWhereUniqueWithoutBranchInput | FeedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FeedCreateManyBranchInputEnvelope
    set?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    disconnect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    delete?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    update?: FeedUpdateWithWhereUniqueWithoutBranchInput | FeedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FeedUpdateManyWithWhereWithoutBranchInput | FeedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FeedScalarWhereInput | FeedScalarWhereInput[]
  }

  export type MedicineStockUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput> | MedicineStockCreateWithoutBranchInput[] | MedicineStockUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutBranchInput | MedicineStockCreateOrConnectWithoutBranchInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutBranchInput | MedicineStockUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MedicineStockCreateManyBranchInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutBranchInput | MedicineStockUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutBranchInput | MedicineStockUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput> | MedicinePurchessCreateWithoutBranchInput[] | MedicinePurchessUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutBranchInput | MedicinePurchessCreateOrConnectWithoutBranchInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutBranchInput | MedicinePurchessUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: MedicinePurchessCreateManyBranchInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutBranchInput | MedicinePurchessUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutBranchInput | MedicinePurchessUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type SellMedicineUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput> | SellMedicineCreateWithoutBranchInput[] | SellMedicineUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutBranchInput | SellMedicineCreateOrConnectWithoutBranchInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutBranchInput | SellMedicineUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SellMedicineCreateManyBranchInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutBranchInput | SellMedicineUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutBranchInput | SellMedicineUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput> | MedicineTransferCreateWithoutBaranchInput[] | MedicineTransferUncheckedCreateWithoutBaranchInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutBaranchInput | MedicineTransferCreateOrConnectWithoutBaranchInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutBaranchInput | MedicineTransferUpsertWithWhereUniqueWithoutBaranchInput[]
    createMany?: MedicineTransferCreateManyBaranchInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutBaranchInput | MedicineTransferUpdateWithWhereUniqueWithoutBaranchInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutBaranchInput | MedicineTransferUpdateManyWithWhereWithoutBaranchInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type FlockReportUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput> | FlockReportCreateWithoutBranchInput[] | FlockReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutBranchInput | FlockReportCreateOrConnectWithoutBranchInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutBranchInput | FlockReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FlockReportCreateManyBranchInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutBranchInput | FlockReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutBranchInput | FlockReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput> | BranchEmployeeHistoryCreateWithoutBranchInput[] | BranchEmployeeHistoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutBranchInput | BranchEmployeeHistoryCreateOrConnectWithoutBranchInput[]
    upsert?: BranchEmployeeHistoryUpsertWithWhereUniqueWithoutBranchInput | BranchEmployeeHistoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchEmployeeHistoryCreateManyBranchInputEnvelope
    set?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    disconnect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    delete?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    update?: BranchEmployeeHistoryUpdateWithWhereUniqueWithoutBranchInput | BranchEmployeeHistoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchEmployeeHistoryUpdateManyWithWhereWithoutBranchInput | BranchEmployeeHistoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutFarmerInput = {
    create?: XOR<BranchCreateWithoutFarmerInput, BranchUncheckedCreateWithoutFarmerInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFarmerInput
    connect?: BranchWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutFarmerInput = {
    create?: XOR<AddressCreateWithoutFarmerInput, AddressUncheckedCreateWithoutFarmerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFarmerInput
    connect?: AddressWhereUniqueInput
  }

  export type FlockCreateNestedManyWithoutFarmerInput = {
    create?: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput> | FlockCreateWithoutFarmerInput[] | FlockUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutFarmerInput | FlockCreateOrConnectWithoutFarmerInput[]
    createMany?: FlockCreateManyFarmerInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type SellMedicineCreateNestedManyWithoutFarmerInput = {
    create?: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput> | SellMedicineCreateWithoutFarmerInput[] | SellMedicineUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFarmerInput | SellMedicineCreateOrConnectWithoutFarmerInput[]
    createMany?: SellMedicineCreateManyFarmerInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type FlockReportCreateNestedManyWithoutFarmerInput = {
    create?: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput> | FlockReportCreateWithoutFarmerInput[] | FlockReportUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFarmerInput | FlockReportCreateOrConnectWithoutFarmerInput[]
    createMany?: FlockReportCreateManyFarmerInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type FlockUncheckedCreateNestedManyWithoutFarmerInput = {
    create?: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput> | FlockCreateWithoutFarmerInput[] | FlockUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutFarmerInput | FlockCreateOrConnectWithoutFarmerInput[]
    createMany?: FlockCreateManyFarmerInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type SellMedicineUncheckedCreateNestedManyWithoutFarmerInput = {
    create?: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput> | SellMedicineCreateWithoutFarmerInput[] | SellMedicineUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFarmerInput | SellMedicineCreateOrConnectWithoutFarmerInput[]
    createMany?: SellMedicineCreateManyFarmerInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type FlockReportUncheckedCreateNestedManyWithoutFarmerInput = {
    create?: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput> | FlockReportCreateWithoutFarmerInput[] | FlockReportUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFarmerInput | FlockReportCreateOrConnectWithoutFarmerInput[]
    createMany?: FlockReportCreateManyFarmerInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCusttypeFieldUpdateOperationsInput = {
    set?: $Enums.Custtype
  }

  export type BranchUpdateOneWithoutFarmerNestedInput = {
    create?: XOR<BranchCreateWithoutFarmerInput, BranchUncheckedCreateWithoutFarmerInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFarmerInput
    upsert?: BranchUpsertWithoutFarmerInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFarmerInput, BranchUpdateWithoutFarmerInput>, BranchUncheckedUpdateWithoutFarmerInput>
  }

  export type AddressUpdateOneWithoutFarmerNestedInput = {
    create?: XOR<AddressCreateWithoutFarmerInput, AddressUncheckedCreateWithoutFarmerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFarmerInput
    upsert?: AddressUpsertWithoutFarmerInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutFarmerInput, AddressUpdateWithoutFarmerInput>, AddressUncheckedUpdateWithoutFarmerInput>
  }

  export type FlockUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput> | FlockCreateWithoutFarmerInput[] | FlockUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutFarmerInput | FlockCreateOrConnectWithoutFarmerInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutFarmerInput | FlockUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: FlockCreateManyFarmerInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutFarmerInput | FlockUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutFarmerInput | FlockUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type SellMedicineUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput> | SellMedicineCreateWithoutFarmerInput[] | SellMedicineUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFarmerInput | SellMedicineCreateOrConnectWithoutFarmerInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutFarmerInput | SellMedicineUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: SellMedicineCreateManyFarmerInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutFarmerInput | SellMedicineUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutFarmerInput | SellMedicineUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type FlockReportUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput> | FlockReportCreateWithoutFarmerInput[] | FlockReportUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFarmerInput | FlockReportCreateOrConnectWithoutFarmerInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutFarmerInput | FlockReportUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: FlockReportCreateManyFarmerInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutFarmerInput | FlockReportUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutFarmerInput | FlockReportUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FlockUncheckedUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput> | FlockCreateWithoutFarmerInput[] | FlockUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutFarmerInput | FlockCreateOrConnectWithoutFarmerInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutFarmerInput | FlockUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: FlockCreateManyFarmerInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutFarmerInput | FlockUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutFarmerInput | FlockUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput> | SellMedicineCreateWithoutFarmerInput[] | SellMedicineUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFarmerInput | SellMedicineCreateOrConnectWithoutFarmerInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutFarmerInput | SellMedicineUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: SellMedicineCreateManyFarmerInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutFarmerInput | SellMedicineUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutFarmerInput | SellMedicineUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type FlockReportUncheckedUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput> | FlockReportCreateWithoutFarmerInput[] | FlockReportUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFarmerInput | FlockReportCreateOrConnectWithoutFarmerInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutFarmerInput | FlockReportUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: FlockReportCreateManyFarmerInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutFarmerInput | FlockReportUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutFarmerInput | FlockReportUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type FarmerCreateNestedOneWithoutAddressInput = {
    create?: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutAddressInput
    connect?: FarmerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAddressInput = {
    create?: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAddressInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FarmerUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutAddressInput
    connect?: FarmerWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAddressInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FarmerUpdateOneWithoutAddressNestedInput = {
    create?: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutAddressInput
    upsert?: FarmerUpsertWithoutAddressInput
    disconnect?: FarmerWhereInput | boolean
    delete?: FarmerWhereInput | boolean
    connect?: FarmerWhereUniqueInput
    update?: XOR<XOR<FarmerUpdateToOneWithWhereWithoutAddressInput, FarmerUpdateWithoutAddressInput>, FarmerUncheckedUpdateWithoutAddressInput>
  }

  export type EmployeeUpdateOneWithoutAddressNestedInput = {
    create?: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAddressInput
    upsert?: EmployeeUpsertWithoutAddressInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAddressInput, EmployeeUpdateWithoutAddressInput>, EmployeeUncheckedUpdateWithoutAddressInput>
  }

  export type FarmerUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutAddressInput
    upsert?: FarmerUpsertWithoutAddressInput
    disconnect?: FarmerWhereInput | boolean
    delete?: FarmerWhereInput | boolean
    connect?: FarmerWhereUniqueInput
    update?: XOR<XOR<FarmerUpdateToOneWithWhereWithoutAddressInput, FarmerUpdateWithoutAddressInput>, FarmerUncheckedUpdateWithoutAddressInput>
  }

  export type EmployeeUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAddressInput
    upsert?: EmployeeUpsertWithoutAddressInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAddressInput, EmployeeUpdateWithoutAddressInput>, EmployeeUncheckedUpdateWithoutAddressInput>
  }

  export type BranchCreateNestedOneWithoutBranchEmployeeHistoryInput = {
    create?: XOR<BranchCreateWithoutBranchEmployeeHistoryInput, BranchUncheckedCreateWithoutBranchEmployeeHistoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBranchEmployeeHistoryInput
    connect?: BranchWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutBranchEmployeeHistoryInput = {
    create?: XOR<EmployeeCreateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedCreateWithoutBranchEmployeeHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchEmployeeHistoryInput
    connect?: EmployeeWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BranchUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput = {
    create?: XOR<BranchCreateWithoutBranchEmployeeHistoryInput, BranchUncheckedCreateWithoutBranchEmployeeHistoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBranchEmployeeHistoryInput
    upsert?: BranchUpsertWithoutBranchEmployeeHistoryInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBranchEmployeeHistoryInput, BranchUpdateWithoutBranchEmployeeHistoryInput>, BranchUncheckedUpdateWithoutBranchEmployeeHistoryInput>
  }

  export type EmployeeUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput = {
    create?: XOR<EmployeeCreateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedCreateWithoutBranchEmployeeHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchEmployeeHistoryInput
    upsert?: EmployeeUpsertWithoutBranchEmployeeHistoryInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutBranchEmployeeHistoryInput, EmployeeUpdateWithoutBranchEmployeeHistoryInput>, EmployeeUncheckedUpdateWithoutBranchEmployeeHistoryInput>
  }

  export type AddressCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<AddressCreateWithoutEmployeeInput, AddressUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: AddressCreateOrConnectWithoutEmployeeInput
    connect?: AddressWhereUniqueInput
  }

  export type FlockCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput> | FlockCreateWithoutEmployeeInput[] | FlockUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutEmployeeInput | FlockCreateOrConnectWithoutEmployeeInput[]
    createMany?: FlockCreateManyEmployeeInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type BranchEmployeeHistoryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput> | BranchEmployeeHistoryCreateWithoutEmployeeInput[] | BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput | BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput[]
    createMany?: BranchEmployeeHistoryCreateManyEmployeeInputEnvelope
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
  }

  export type FlockUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput> | FlockCreateWithoutEmployeeInput[] | FlockUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutEmployeeInput | FlockCreateOrConnectWithoutEmployeeInput[]
    createMany?: FlockCreateManyEmployeeInputEnvelope
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
  }

  export type BranchEmployeeHistoryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput> | BranchEmployeeHistoryCreateWithoutEmployeeInput[] | BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput | BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput[]
    createMany?: BranchEmployeeHistoryCreateManyEmployeeInputEnvelope
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
  }

  export type AddressUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<AddressCreateWithoutEmployeeInput, AddressUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: AddressCreateOrConnectWithoutEmployeeInput
    upsert?: AddressUpsertWithoutEmployeeInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutEmployeeInput, AddressUpdateWithoutEmployeeInput>, AddressUncheckedUpdateWithoutEmployeeInput>
  }

  export type FlockUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput> | FlockCreateWithoutEmployeeInput[] | FlockUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutEmployeeInput | FlockCreateOrConnectWithoutEmployeeInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutEmployeeInput | FlockUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FlockCreateManyEmployeeInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutEmployeeInput | FlockUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutEmployeeInput | FlockUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type BranchEmployeeHistoryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput> | BranchEmployeeHistoryCreateWithoutEmployeeInput[] | BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput | BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput[]
    upsert?: BranchEmployeeHistoryUpsertWithWhereUniqueWithoutEmployeeInput | BranchEmployeeHistoryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BranchEmployeeHistoryCreateManyEmployeeInputEnvelope
    set?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    disconnect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    delete?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    update?: BranchEmployeeHistoryUpdateWithWhereUniqueWithoutEmployeeInput | BranchEmployeeHistoryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BranchEmployeeHistoryUpdateManyWithWhereWithoutEmployeeInput | BranchEmployeeHistoryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
  }

  export type FlockUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput> | FlockCreateWithoutEmployeeInput[] | FlockUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FlockCreateOrConnectWithoutEmployeeInput | FlockCreateOrConnectWithoutEmployeeInput[]
    upsert?: FlockUpsertWithWhereUniqueWithoutEmployeeInput | FlockUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FlockCreateManyEmployeeInputEnvelope
    set?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    disconnect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    delete?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    connect?: FlockWhereUniqueInput | FlockWhereUniqueInput[]
    update?: FlockUpdateWithWhereUniqueWithoutEmployeeInput | FlockUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FlockUpdateManyWithWhereWithoutEmployeeInput | FlockUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FlockScalarWhereInput | FlockScalarWhereInput[]
  }

  export type BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput> | BranchEmployeeHistoryCreateWithoutEmployeeInput[] | BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput | BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput[]
    upsert?: BranchEmployeeHistoryUpsertWithWhereUniqueWithoutEmployeeInput | BranchEmployeeHistoryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BranchEmployeeHistoryCreateManyEmployeeInputEnvelope
    set?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    disconnect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    delete?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    connect?: BranchEmployeeHistoryWhereUniqueInput | BranchEmployeeHistoryWhereUniqueInput[]
    update?: BranchEmployeeHistoryUpdateWithWhereUniqueWithoutEmployeeInput | BranchEmployeeHistoryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BranchEmployeeHistoryUpdateManyWithWhereWithoutEmployeeInput | BranchEmployeeHistoryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
  }

  export type FarmerCreateNestedOneWithoutFlocksInput = {
    create?: XOR<FarmerCreateWithoutFlocksInput, FarmerUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutFlocksInput
    connect?: FarmerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutFlocksInput = {
    create?: XOR<EmployeeCreateWithoutFlocksInput, EmployeeUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFlocksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutFlocksInput = {
    create?: XOR<BranchCreateWithoutFlocksInput, BranchUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFlocksInput
    connect?: BranchWhereUniqueInput
  }

  export type SellMedicineCreateNestedManyWithoutFlockInput = {
    create?: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput> | SellMedicineCreateWithoutFlockInput[] | SellMedicineUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFlockInput | SellMedicineCreateOrConnectWithoutFlockInput[]
    createMany?: SellMedicineCreateManyFlockInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type MedicineTransferCreateNestedManyWithoutFlockInput = {
    create?: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput> | MedicineTransferCreateWithoutFlockInput[] | MedicineTransferUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutFlockInput | MedicineTransferCreateOrConnectWithoutFlockInput[]
    createMany?: MedicineTransferCreateManyFlockInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type FlockReportCreateNestedManyWithoutFlockInput = {
    create?: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput> | FlockReportCreateWithoutFlockInput[] | FlockReportUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFlockInput | FlockReportCreateOrConnectWithoutFlockInput[]
    createMany?: FlockReportCreateManyFlockInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type SellMedicineUncheckedCreateNestedManyWithoutFlockInput = {
    create?: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput> | SellMedicineCreateWithoutFlockInput[] | SellMedicineUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFlockInput | SellMedicineCreateOrConnectWithoutFlockInput[]
    createMany?: SellMedicineCreateManyFlockInputEnvelope
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
  }

  export type MedicineTransferUncheckedCreateNestedManyWithoutFlockInput = {
    create?: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput> | MedicineTransferCreateWithoutFlockInput[] | MedicineTransferUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutFlockInput | MedicineTransferCreateOrConnectWithoutFlockInput[]
    createMany?: MedicineTransferCreateManyFlockInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type FlockReportUncheckedCreateNestedManyWithoutFlockInput = {
    create?: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput> | FlockReportCreateWithoutFlockInput[] | FlockReportUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFlockInput | FlockReportCreateOrConnectWithoutFlockInput[]
    createMany?: FlockReportCreateManyFlockInputEnvelope
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
  }

  export type EnumFlockStatusFieldUpdateOperationsInput = {
    set?: $Enums.FlockStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FarmerUpdateOneRequiredWithoutFlocksNestedInput = {
    create?: XOR<FarmerCreateWithoutFlocksInput, FarmerUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutFlocksInput
    upsert?: FarmerUpsertWithoutFlocksInput
    connect?: FarmerWhereUniqueInput
    update?: XOR<XOR<FarmerUpdateToOneWithWhereWithoutFlocksInput, FarmerUpdateWithoutFlocksInput>, FarmerUncheckedUpdateWithoutFlocksInput>
  }

  export type EmployeeUpdateOneRequiredWithoutFlocksNestedInput = {
    create?: XOR<EmployeeCreateWithoutFlocksInput, EmployeeUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFlocksInput
    upsert?: EmployeeUpsertWithoutFlocksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutFlocksInput, EmployeeUpdateWithoutFlocksInput>, EmployeeUncheckedUpdateWithoutFlocksInput>
  }

  export type BranchUpdateOneRequiredWithoutFlocksNestedInput = {
    create?: XOR<BranchCreateWithoutFlocksInput, BranchUncheckedCreateWithoutFlocksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFlocksInput
    upsert?: BranchUpsertWithoutFlocksInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFlocksInput, BranchUpdateWithoutFlocksInput>, BranchUncheckedUpdateWithoutFlocksInput>
  }

  export type SellMedicineUpdateManyWithoutFlockNestedInput = {
    create?: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput> | SellMedicineCreateWithoutFlockInput[] | SellMedicineUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFlockInput | SellMedicineCreateOrConnectWithoutFlockInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutFlockInput | SellMedicineUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: SellMedicineCreateManyFlockInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutFlockInput | SellMedicineUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutFlockInput | SellMedicineUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type MedicineTransferUpdateManyWithoutFlockNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput> | MedicineTransferCreateWithoutFlockInput[] | MedicineTransferUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutFlockInput | MedicineTransferCreateOrConnectWithoutFlockInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutFlockInput | MedicineTransferUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: MedicineTransferCreateManyFlockInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutFlockInput | MedicineTransferUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutFlockInput | MedicineTransferUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type FlockReportUpdateManyWithoutFlockNestedInput = {
    create?: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput> | FlockReportCreateWithoutFlockInput[] | FlockReportUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFlockInput | FlockReportCreateOrConnectWithoutFlockInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutFlockInput | FlockReportUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: FlockReportCreateManyFlockInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutFlockInput | FlockReportUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutFlockInput | FlockReportUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type SellMedicineUncheckedUpdateManyWithoutFlockNestedInput = {
    create?: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput> | SellMedicineCreateWithoutFlockInput[] | SellMedicineUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: SellMedicineCreateOrConnectWithoutFlockInput | SellMedicineCreateOrConnectWithoutFlockInput[]
    upsert?: SellMedicineUpsertWithWhereUniqueWithoutFlockInput | SellMedicineUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: SellMedicineCreateManyFlockInputEnvelope
    set?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    disconnect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    delete?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    connect?: SellMedicineWhereUniqueInput | SellMedicineWhereUniqueInput[]
    update?: SellMedicineUpdateWithWhereUniqueWithoutFlockInput | SellMedicineUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: SellMedicineUpdateManyWithWhereWithoutFlockInput | SellMedicineUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
  }

  export type MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput> | MedicineTransferCreateWithoutFlockInput[] | MedicineTransferUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutFlockInput | MedicineTransferCreateOrConnectWithoutFlockInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutFlockInput | MedicineTransferUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: MedicineTransferCreateManyFlockInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutFlockInput | MedicineTransferUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutFlockInput | MedicineTransferUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type FlockReportUncheckedUpdateManyWithoutFlockNestedInput = {
    create?: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput> | FlockReportCreateWithoutFlockInput[] | FlockReportUncheckedCreateWithoutFlockInput[]
    connectOrCreate?: FlockReportCreateOrConnectWithoutFlockInput | FlockReportCreateOrConnectWithoutFlockInput[]
    upsert?: FlockReportUpsertWithWhereUniqueWithoutFlockInput | FlockReportUpsertWithWhereUniqueWithoutFlockInput[]
    createMany?: FlockReportCreateManyFlockInputEnvelope
    set?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    disconnect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    delete?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    connect?: FlockReportWhereUniqueInput | FlockReportWhereUniqueInput[]
    update?: FlockReportUpdateWithWhereUniqueWithoutFlockInput | FlockReportUpdateWithWhereUniqueWithoutFlockInput[]
    updateMany?: FlockReportUpdateManyWithWhereWithoutFlockInput | FlockReportUpdateManyWithWhereWithoutFlockInput[]
    deleteMany?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutFlockReportInput = {
    create?: XOR<BranchCreateWithoutFlockReportInput, BranchUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFlockReportInput
    connect?: BranchWhereUniqueInput
  }

  export type FlockCreateNestedOneWithoutFlockReportInput = {
    create?: XOR<FlockCreateWithoutFlockReportInput, FlockUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: FlockCreateOrConnectWithoutFlockReportInput
    connect?: FlockWhereUniqueInput
  }

  export type FarmerCreateNestedOneWithoutFlockReportInput = {
    create?: XOR<FarmerCreateWithoutFlockReportInput, FarmerUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutFlockReportInput
    connect?: FarmerWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchUpdateOneRequiredWithoutFlockReportNestedInput = {
    create?: XOR<BranchCreateWithoutFlockReportInput, BranchUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFlockReportInput
    upsert?: BranchUpsertWithoutFlockReportInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFlockReportInput, BranchUpdateWithoutFlockReportInput>, BranchUncheckedUpdateWithoutFlockReportInput>
  }

  export type FlockUpdateOneRequiredWithoutFlockReportNestedInput = {
    create?: XOR<FlockCreateWithoutFlockReportInput, FlockUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: FlockCreateOrConnectWithoutFlockReportInput
    upsert?: FlockUpsertWithoutFlockReportInput
    connect?: FlockWhereUniqueInput
    update?: XOR<XOR<FlockUpdateToOneWithWhereWithoutFlockReportInput, FlockUpdateWithoutFlockReportInput>, FlockUncheckedUpdateWithoutFlockReportInput>
  }

  export type FarmerUpdateOneRequiredWithoutFlockReportNestedInput = {
    create?: XOR<FarmerCreateWithoutFlockReportInput, FarmerUncheckedCreateWithoutFlockReportInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutFlockReportInput
    upsert?: FarmerUpsertWithoutFlockReportInput
    connect?: FarmerWhereUniqueInput
    update?: XOR<XOR<FarmerUpdateToOneWithWhereWithoutFlockReportInput, FarmerUpdateWithoutFlockReportInput>, FarmerUncheckedUpdateWithoutFlockReportInput>
  }

  export type FeedCreateNestedManyWithoutFeedNameCategoryInput = {
    create?: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput> | FeedCreateWithoutFeedNameCategoryInput[] | FeedUncheckedCreateWithoutFeedNameCategoryInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutFeedNameCategoryInput | FeedCreateOrConnectWithoutFeedNameCategoryInput[]
    createMany?: FeedCreateManyFeedNameCategoryInputEnvelope
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
  }

  export type FeedUncheckedCreateNestedManyWithoutFeedNameCategoryInput = {
    create?: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput> | FeedCreateWithoutFeedNameCategoryInput[] | FeedUncheckedCreateWithoutFeedNameCategoryInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutFeedNameCategoryInput | FeedCreateOrConnectWithoutFeedNameCategoryInput[]
    createMany?: FeedCreateManyFeedNameCategoryInputEnvelope
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
  }

  export type FeedUpdateManyWithoutFeedNameCategoryNestedInput = {
    create?: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput> | FeedCreateWithoutFeedNameCategoryInput[] | FeedUncheckedCreateWithoutFeedNameCategoryInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutFeedNameCategoryInput | FeedCreateOrConnectWithoutFeedNameCategoryInput[]
    upsert?: FeedUpsertWithWhereUniqueWithoutFeedNameCategoryInput | FeedUpsertWithWhereUniqueWithoutFeedNameCategoryInput[]
    createMany?: FeedCreateManyFeedNameCategoryInputEnvelope
    set?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    disconnect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    delete?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    update?: FeedUpdateWithWhereUniqueWithoutFeedNameCategoryInput | FeedUpdateWithWhereUniqueWithoutFeedNameCategoryInput[]
    updateMany?: FeedUpdateManyWithWhereWithoutFeedNameCategoryInput | FeedUpdateManyWithWhereWithoutFeedNameCategoryInput[]
    deleteMany?: FeedScalarWhereInput | FeedScalarWhereInput[]
  }

  export type FeedUncheckedUpdateManyWithoutFeedNameCategoryNestedInput = {
    create?: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput> | FeedCreateWithoutFeedNameCategoryInput[] | FeedUncheckedCreateWithoutFeedNameCategoryInput[]
    connectOrCreate?: FeedCreateOrConnectWithoutFeedNameCategoryInput | FeedCreateOrConnectWithoutFeedNameCategoryInput[]
    upsert?: FeedUpsertWithWhereUniqueWithoutFeedNameCategoryInput | FeedUpsertWithWhereUniqueWithoutFeedNameCategoryInput[]
    createMany?: FeedCreateManyFeedNameCategoryInputEnvelope
    set?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    disconnect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    delete?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    connect?: FeedWhereUniqueInput | FeedWhereUniqueInput[]
    update?: FeedUpdateWithWhereUniqueWithoutFeedNameCategoryInput | FeedUpdateWithWhereUniqueWithoutFeedNameCategoryInput[]
    updateMany?: FeedUpdateManyWithWhereWithoutFeedNameCategoryInput | FeedUpdateManyWithWhereWithoutFeedNameCategoryInput[]
    deleteMany?: FeedScalarWhereInput | FeedScalarWhereInput[]
  }

  export type FeedNameCategoryCreateNestedOneWithoutFeedsInput = {
    create?: XOR<FeedNameCategoryCreateWithoutFeedsInput, FeedNameCategoryUncheckedCreateWithoutFeedsInput>
    connectOrCreate?: FeedNameCategoryCreateOrConnectWithoutFeedsInput
    connect?: FeedNameCategoryWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutFeedInput = {
    create?: XOR<BranchCreateWithoutFeedInput, BranchUncheckedCreateWithoutFeedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFeedInput
    connect?: BranchWhereUniqueInput
  }

  export type FeedNameCategoryUpdateOneRequiredWithoutFeedsNestedInput = {
    create?: XOR<FeedNameCategoryCreateWithoutFeedsInput, FeedNameCategoryUncheckedCreateWithoutFeedsInput>
    connectOrCreate?: FeedNameCategoryCreateOrConnectWithoutFeedsInput
    upsert?: FeedNameCategoryUpsertWithoutFeedsInput
    connect?: FeedNameCategoryWhereUniqueInput
    update?: XOR<XOR<FeedNameCategoryUpdateToOneWithWhereWithoutFeedsInput, FeedNameCategoryUpdateWithoutFeedsInput>, FeedNameCategoryUncheckedUpdateWithoutFeedsInput>
  }

  export type BranchUpdateOneWithoutFeedNestedInput = {
    create?: XOR<BranchCreateWithoutFeedInput, BranchUncheckedCreateWithoutFeedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFeedInput
    upsert?: BranchUpsertWithoutFeedInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFeedInput, BranchUpdateWithoutFeedInput>, BranchUncheckedUpdateWithoutFeedInput>
  }

  export type MedicineNameAddCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput> | MedicineNameAddCreateWithoutMedicineCategoryInput[] | MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput | MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicineNameAddCreateManyMedicineCategoryInputEnvelope
    connect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
  }

  export type MedicineStockCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput> | MedicineStockCreateWithoutMedicineCategoryInput[] | MedicineStockUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineCategoryInput | MedicineStockCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicineStockCreateManyMedicineCategoryInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput> | MedicinePurchessCreateWithoutMedicineCategoryInput[] | MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput | MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicinePurchessCreateManyMedicineCategoryInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type MedicineNameAddUncheckedCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput> | MedicineNameAddCreateWithoutMedicineCategoryInput[] | MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput | MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicineNameAddCreateManyMedicineCategoryInputEnvelope
    connect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
  }

  export type MedicineStockUncheckedCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput> | MedicineStockCreateWithoutMedicineCategoryInput[] | MedicineStockUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineCategoryInput | MedicineStockCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicineStockCreateManyMedicineCategoryInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessUncheckedCreateNestedManyWithoutMedicineCategoryInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput> | MedicinePurchessCreateWithoutMedicineCategoryInput[] | MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput | MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput[]
    createMany?: MedicinePurchessCreateManyMedicineCategoryInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type MedicineNameAddUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput> | MedicineNameAddCreateWithoutMedicineCategoryInput[] | MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput | MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicineNameAddUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicineNameAddUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicineNameAddCreateManyMedicineCategoryInputEnvelope
    set?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    disconnect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    delete?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    connect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    update?: MedicineNameAddUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicineNameAddUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicineNameAddUpdateManyWithWhereWithoutMedicineCategoryInput | MedicineNameAddUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicineNameAddScalarWhereInput | MedicineNameAddScalarWhereInput[]
  }

  export type MedicineStockUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput> | MedicineStockCreateWithoutMedicineCategoryInput[] | MedicineStockUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineCategoryInput | MedicineStockCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicineStockUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicineStockCreateManyMedicineCategoryInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicineStockUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutMedicineCategoryInput | MedicineStockUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput> | MedicinePurchessCreateWithoutMedicineCategoryInput[] | MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput | MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicinePurchessUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicinePurchessCreateManyMedicineCategoryInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicinePurchessUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutMedicineCategoryInput | MedicinePurchessUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput> | MedicineNameAddCreateWithoutMedicineCategoryInput[] | MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput | MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicineNameAddUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicineNameAddUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicineNameAddCreateManyMedicineCategoryInputEnvelope
    set?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    disconnect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    delete?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    connect?: MedicineNameAddWhereUniqueInput | MedicineNameAddWhereUniqueInput[]
    update?: MedicineNameAddUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicineNameAddUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicineNameAddUpdateManyWithWhereWithoutMedicineCategoryInput | MedicineNameAddUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicineNameAddScalarWhereInput | MedicineNameAddScalarWhereInput[]
  }

  export type MedicineStockUncheckedUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput> | MedicineStockCreateWithoutMedicineCategoryInput[] | MedicineStockUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineCategoryInput | MedicineStockCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicineStockUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicineStockCreateManyMedicineCategoryInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicineStockUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutMedicineCategoryInput | MedicineStockUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput> | MedicinePurchessCreateWithoutMedicineCategoryInput[] | MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput | MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutMedicineCategoryInput | MedicinePurchessUpsertWithWhereUniqueWithoutMedicineCategoryInput[]
    createMany?: MedicinePurchessCreateManyMedicineCategoryInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutMedicineCategoryInput | MedicinePurchessUpdateWithWhereUniqueWithoutMedicineCategoryInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutMedicineCategoryInput | MedicinePurchessUpdateManyWithWhereWithoutMedicineCategoryInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type AllGenericMedicinCreateNestedOneWithoutMedicineNameAddInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedCreateWithoutMedicineNameAddInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicineNameAddInput
    connect?: AllGenericMedicinWhereUniqueInput
  }

  export type MedicineStockCreateNestedManyWithoutMedicineNameAddInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput> | MedicineStockCreateWithoutMedicineNameAddInput[] | MedicineStockUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineNameAddInput | MedicineStockCreateOrConnectWithoutMedicineNameAddInput[]
    createMany?: MedicineStockCreateManyMedicineNameAddInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessCreateNestedManyWithoutMedicineNameAddInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput> | MedicinePurchessCreateWithoutMedicineNameAddInput[] | MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput | MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput[]
    createMany?: MedicinePurchessCreateManyMedicineNameAddInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type MedicineStockUncheckedCreateNestedManyWithoutMedicineNameAddInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput> | MedicineStockCreateWithoutMedicineNameAddInput[] | MedicineStockUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineNameAddInput | MedicineStockCreateOrConnectWithoutMedicineNameAddInput[]
    createMany?: MedicineStockCreateManyMedicineNameAddInputEnvelope
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
  }

  export type MedicinePurchessUncheckedCreateNestedManyWithoutMedicineNameAddInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput> | MedicinePurchessCreateWithoutMedicineNameAddInput[] | MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput | MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput[]
    createMany?: MedicinePurchessCreateManyMedicineNameAddInputEnvelope
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
  }

  export type AllGenericMedicinUpdateOneRequiredWithoutMedicineNameAddNestedInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedCreateWithoutMedicineNameAddInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicineNameAddInput
    upsert?: AllGenericMedicinUpsertWithoutMedicineNameAddInput
    connect?: AllGenericMedicinWhereUniqueInput
    update?: XOR<XOR<AllGenericMedicinUpdateToOneWithWhereWithoutMedicineNameAddInput, AllGenericMedicinUpdateWithoutMedicineNameAddInput>, AllGenericMedicinUncheckedUpdateWithoutMedicineNameAddInput>
  }

  export type MedicineStockUpdateManyWithoutMedicineNameAddNestedInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput> | MedicineStockCreateWithoutMedicineNameAddInput[] | MedicineStockUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineNameAddInput | MedicineStockCreateOrConnectWithoutMedicineNameAddInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutMedicineNameAddInput | MedicineStockUpsertWithWhereUniqueWithoutMedicineNameAddInput[]
    createMany?: MedicineStockCreateManyMedicineNameAddInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutMedicineNameAddInput | MedicineStockUpdateWithWhereUniqueWithoutMedicineNameAddInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutMedicineNameAddInput | MedicineStockUpdateManyWithWhereWithoutMedicineNameAddInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUpdateManyWithoutMedicineNameAddNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput> | MedicinePurchessCreateWithoutMedicineNameAddInput[] | MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput | MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutMedicineNameAddInput | MedicinePurchessUpsertWithWhereUniqueWithoutMedicineNameAddInput[]
    createMany?: MedicinePurchessCreateManyMedicineNameAddInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutMedicineNameAddInput | MedicinePurchessUpdateWithWhereUniqueWithoutMedicineNameAddInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutMedicineNameAddInput | MedicinePurchessUpdateManyWithWhereWithoutMedicineNameAddInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type MedicineStockUncheckedUpdateManyWithoutMedicineNameAddNestedInput = {
    create?: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput> | MedicineStockCreateWithoutMedicineNameAddInput[] | MedicineStockUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicineStockCreateOrConnectWithoutMedicineNameAddInput | MedicineStockCreateOrConnectWithoutMedicineNameAddInput[]
    upsert?: MedicineStockUpsertWithWhereUniqueWithoutMedicineNameAddInput | MedicineStockUpsertWithWhereUniqueWithoutMedicineNameAddInput[]
    createMany?: MedicineStockCreateManyMedicineNameAddInputEnvelope
    set?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    disconnect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    delete?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    connect?: MedicineStockWhereUniqueInput | MedicineStockWhereUniqueInput[]
    update?: MedicineStockUpdateWithWhereUniqueWithoutMedicineNameAddInput | MedicineStockUpdateWithWhereUniqueWithoutMedicineNameAddInput[]
    updateMany?: MedicineStockUpdateManyWithWhereWithoutMedicineNameAddInput | MedicineStockUpdateManyWithWhereWithoutMedicineNameAddInput[]
    deleteMany?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddNestedInput = {
    create?: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput> | MedicinePurchessCreateWithoutMedicineNameAddInput[] | MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput[]
    connectOrCreate?: MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput | MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput[]
    upsert?: MedicinePurchessUpsertWithWhereUniqueWithoutMedicineNameAddInput | MedicinePurchessUpsertWithWhereUniqueWithoutMedicineNameAddInput[]
    createMany?: MedicinePurchessCreateManyMedicineNameAddInputEnvelope
    set?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    disconnect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    delete?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    connect?: MedicinePurchessWhereUniqueInput | MedicinePurchessWhereUniqueInput[]
    update?: MedicinePurchessUpdateWithWhereUniqueWithoutMedicineNameAddInput | MedicinePurchessUpdateWithWhereUniqueWithoutMedicineNameAddInput[]
    updateMany?: MedicinePurchessUpdateManyWithWhereWithoutMedicineNameAddInput | MedicinePurchessUpdateManyWithWhereWithoutMedicineNameAddInput[]
    deleteMany?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
  }

  export type AllGenericMedicinCreateNestedOneWithoutMedicinePurchessInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicinePurchessInput
    connect?: AllGenericMedicinWhereUniqueInput
  }

  export type MedicineNameAddCreateNestedOneWithoutMedicinePurchessInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicinePurchessInput, MedicineNameAddUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicinePurchessInput
    connect?: MedicineNameAddWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutMedicinePurchessInput = {
    create?: XOR<BranchCreateWithoutMedicinePurchessInput, BranchUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicinePurchessInput
    connect?: BranchWhereUniqueInput
  }

  export type EnumStoredFieldUpdateOperationsInput = {
    set?: $Enums.Stored
  }

  export type AllGenericMedicinUpdateOneRequiredWithoutMedicinePurchessNestedInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicinePurchessInput
    upsert?: AllGenericMedicinUpsertWithoutMedicinePurchessInput
    connect?: AllGenericMedicinWhereUniqueInput
    update?: XOR<XOR<AllGenericMedicinUpdateToOneWithWhereWithoutMedicinePurchessInput, AllGenericMedicinUpdateWithoutMedicinePurchessInput>, AllGenericMedicinUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type MedicineNameAddUpdateOneRequiredWithoutMedicinePurchessNestedInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicinePurchessInput, MedicineNameAddUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicinePurchessInput
    upsert?: MedicineNameAddUpsertWithoutMedicinePurchessInput
    connect?: MedicineNameAddWhereUniqueInput
    update?: XOR<XOR<MedicineNameAddUpdateToOneWithWhereWithoutMedicinePurchessInput, MedicineNameAddUpdateWithoutMedicinePurchessInput>, MedicineNameAddUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type BranchUpdateOneRequiredWithoutMedicinePurchessNestedInput = {
    create?: XOR<BranchCreateWithoutMedicinePurchessInput, BranchUncheckedCreateWithoutMedicinePurchessInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicinePurchessInput
    upsert?: BranchUpsertWithoutMedicinePurchessInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMedicinePurchessInput, BranchUpdateWithoutMedicinePurchessInput>, BranchUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type MedicineNameAddCreateNestedOneWithoutMedicineStockInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineStockInput, MedicineNameAddUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineStockInput
    connect?: MedicineNameAddWhereUniqueInput
  }

  export type AllGenericMedicinCreateNestedOneWithoutMedicineStockInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicineStockInput, AllGenericMedicinUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicineStockInput
    connect?: AllGenericMedicinWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutMedicineStockInput = {
    create?: XOR<BranchCreateWithoutMedicineStockInput, BranchUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicineStockInput
    connect?: BranchWhereUniqueInput
  }

  export type MedicineNameAddUpdateOneRequiredWithoutMedicineStockNestedInput = {
    create?: XOR<MedicineNameAddCreateWithoutMedicineStockInput, MedicineNameAddUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: MedicineNameAddCreateOrConnectWithoutMedicineStockInput
    upsert?: MedicineNameAddUpsertWithoutMedicineStockInput
    connect?: MedicineNameAddWhereUniqueInput
    update?: XOR<XOR<MedicineNameAddUpdateToOneWithWhereWithoutMedicineStockInput, MedicineNameAddUpdateWithoutMedicineStockInput>, MedicineNameAddUncheckedUpdateWithoutMedicineStockInput>
  }

  export type AllGenericMedicinUpdateOneRequiredWithoutMedicineStockNestedInput = {
    create?: XOR<AllGenericMedicinCreateWithoutMedicineStockInput, AllGenericMedicinUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: AllGenericMedicinCreateOrConnectWithoutMedicineStockInput
    upsert?: AllGenericMedicinUpsertWithoutMedicineStockInput
    connect?: AllGenericMedicinWhereUniqueInput
    update?: XOR<XOR<AllGenericMedicinUpdateToOneWithWhereWithoutMedicineStockInput, AllGenericMedicinUpdateWithoutMedicineStockInput>, AllGenericMedicinUncheckedUpdateWithoutMedicineStockInput>
  }

  export type BranchUpdateOneRequiredWithoutMedicineStockNestedInput = {
    create?: XOR<BranchCreateWithoutMedicineStockInput, BranchUncheckedCreateWithoutMedicineStockInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicineStockInput
    upsert?: BranchUpsertWithoutMedicineStockInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMedicineStockInput, BranchUpdateWithoutMedicineStockInput>, BranchUncheckedUpdateWithoutMedicineStockInput>
  }

  export type FlockCreateNestedOneWithoutSellMedicineInput = {
    create?: XOR<FlockCreateWithoutSellMedicineInput, FlockUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: FlockCreateOrConnectWithoutSellMedicineInput
    connect?: FlockWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutSellMedicineInput = {
    create?: XOR<BranchCreateWithoutSellMedicineInput, BranchUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSellMedicineInput
    connect?: BranchWhereUniqueInput
  }

  export type FarmerCreateNestedOneWithoutSellMedicineInput = {
    create?: XOR<FarmerCreateWithoutSellMedicineInput, FarmerUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutSellMedicineInput
    connect?: FarmerWhereUniqueInput
  }

  export type MedicineTransferCreateNestedManyWithoutSellmedicineInput = {
    create?: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput> | MedicineTransferCreateWithoutSellmedicineInput[] | MedicineTransferUncheckedCreateWithoutSellmedicineInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutSellmedicineInput | MedicineTransferCreateOrConnectWithoutSellmedicineInput[]
    createMany?: MedicineTransferCreateManySellmedicineInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type MedicineTransferUncheckedCreateNestedManyWithoutSellmedicineInput = {
    create?: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput> | MedicineTransferCreateWithoutSellmedicineInput[] | MedicineTransferUncheckedCreateWithoutSellmedicineInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutSellmedicineInput | MedicineTransferCreateOrConnectWithoutSellmedicineInput[]
    createMany?: MedicineTransferCreateManySellmedicineInputEnvelope
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
  }

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus
  }

  export type FlockUpdateOneRequiredWithoutSellMedicineNestedInput = {
    create?: XOR<FlockCreateWithoutSellMedicineInput, FlockUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: FlockCreateOrConnectWithoutSellMedicineInput
    upsert?: FlockUpsertWithoutSellMedicineInput
    connect?: FlockWhereUniqueInput
    update?: XOR<XOR<FlockUpdateToOneWithWhereWithoutSellMedicineInput, FlockUpdateWithoutSellMedicineInput>, FlockUncheckedUpdateWithoutSellMedicineInput>
  }

  export type BranchUpdateOneRequiredWithoutSellMedicineNestedInput = {
    create?: XOR<BranchCreateWithoutSellMedicineInput, BranchUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSellMedicineInput
    upsert?: BranchUpsertWithoutSellMedicineInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSellMedicineInput, BranchUpdateWithoutSellMedicineInput>, BranchUncheckedUpdateWithoutSellMedicineInput>
  }

  export type FarmerUpdateOneRequiredWithoutSellMedicineNestedInput = {
    create?: XOR<FarmerCreateWithoutSellMedicineInput, FarmerUncheckedCreateWithoutSellMedicineInput>
    connectOrCreate?: FarmerCreateOrConnectWithoutSellMedicineInput
    upsert?: FarmerUpsertWithoutSellMedicineInput
    connect?: FarmerWhereUniqueInput
    update?: XOR<XOR<FarmerUpdateToOneWithWhereWithoutSellMedicineInput, FarmerUpdateWithoutSellMedicineInput>, FarmerUncheckedUpdateWithoutSellMedicineInput>
  }

  export type MedicineTransferUpdateManyWithoutSellmedicineNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput> | MedicineTransferCreateWithoutSellmedicineInput[] | MedicineTransferUncheckedCreateWithoutSellmedicineInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutSellmedicineInput | MedicineTransferCreateOrConnectWithoutSellmedicineInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutSellmedicineInput | MedicineTransferUpsertWithWhereUniqueWithoutSellmedicineInput[]
    createMany?: MedicineTransferCreateManySellmedicineInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutSellmedicineInput | MedicineTransferUpdateWithWhereUniqueWithoutSellmedicineInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutSellmedicineInput | MedicineTransferUpdateManyWithWhereWithoutSellmedicineInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type MedicineTransferUncheckedUpdateManyWithoutSellmedicineNestedInput = {
    create?: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput> | MedicineTransferCreateWithoutSellmedicineInput[] | MedicineTransferUncheckedCreateWithoutSellmedicineInput[]
    connectOrCreate?: MedicineTransferCreateOrConnectWithoutSellmedicineInput | MedicineTransferCreateOrConnectWithoutSellmedicineInput[]
    upsert?: MedicineTransferUpsertWithWhereUniqueWithoutSellmedicineInput | MedicineTransferUpsertWithWhereUniqueWithoutSellmedicineInput[]
    createMany?: MedicineTransferCreateManySellmedicineInputEnvelope
    set?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    disconnect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    delete?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    connect?: MedicineTransferWhereUniqueInput | MedicineTransferWhereUniqueInput[]
    update?: MedicineTransferUpdateWithWhereUniqueWithoutSellmedicineInput | MedicineTransferUpdateWithWhereUniqueWithoutSellmedicineInput[]
    updateMany?: MedicineTransferUpdateManyWithWhereWithoutSellmedicineInput | MedicineTransferUpdateManyWithWhereWithoutSellmedicineInput[]
    deleteMany?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
  }

  export type SellMedicineCreateNestedOneWithoutMedicineTransferInput = {
    create?: XOR<SellMedicineCreateWithoutMedicineTransferInput, SellMedicineUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: SellMedicineCreateOrConnectWithoutMedicineTransferInput
    connect?: SellMedicineWhereUniqueInput
  }

  export type FlockCreateNestedOneWithoutMedicineTransferInput = {
    create?: XOR<FlockCreateWithoutMedicineTransferInput, FlockUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: FlockCreateOrConnectWithoutMedicineTransferInput
    connect?: FlockWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutMedicineTransferInput = {
    create?: XOR<BranchCreateWithoutMedicineTransferInput, BranchUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicineTransferInput
    connect?: BranchWhereUniqueInput
  }

  export type SellMedicineUpdateOneRequiredWithoutMedicineTransferNestedInput = {
    create?: XOR<SellMedicineCreateWithoutMedicineTransferInput, SellMedicineUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: SellMedicineCreateOrConnectWithoutMedicineTransferInput
    upsert?: SellMedicineUpsertWithoutMedicineTransferInput
    connect?: SellMedicineWhereUniqueInput
    update?: XOR<XOR<SellMedicineUpdateToOneWithWhereWithoutMedicineTransferInput, SellMedicineUpdateWithoutMedicineTransferInput>, SellMedicineUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type FlockUpdateOneRequiredWithoutMedicineTransferNestedInput = {
    create?: XOR<FlockCreateWithoutMedicineTransferInput, FlockUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: FlockCreateOrConnectWithoutMedicineTransferInput
    upsert?: FlockUpsertWithoutMedicineTransferInput
    connect?: FlockWhereUniqueInput
    update?: XOR<XOR<FlockUpdateToOneWithWhereWithoutMedicineTransferInput, FlockUpdateWithoutMedicineTransferInput>, FlockUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type BranchUpdateOneRequiredWithoutMedicineTransferNestedInput = {
    create?: XOR<BranchCreateWithoutMedicineTransferInput, BranchUncheckedCreateWithoutMedicineTransferInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMedicineTransferInput
    upsert?: BranchUpsertWithoutMedicineTransferInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMedicineTransferInput, BranchUpdateWithoutMedicineTransferInput>, BranchUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumCusttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Custtype | EnumCusttypeFieldRefInput<$PrismaModel>
    in?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCusttypeFilter<$PrismaModel> | $Enums.Custtype
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCusttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Custtype | EnumCusttypeFieldRefInput<$PrismaModel>
    in?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Custtype[] | ListEnumCusttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCusttypeWithAggregatesFilter<$PrismaModel> | $Enums.Custtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCusttypeFilter<$PrismaModel>
    _max?: NestedEnumCusttypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumFlockStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlockStatus | EnumFlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlockStatusFilter<$PrismaModel> | $Enums.FlockStatus
  }

  export type NestedEnumFlockStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlockStatus | EnumFlockStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlockStatus[] | ListEnumFlockStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlockStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlockStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlockStatusFilter<$PrismaModel>
    _max?: NestedEnumFlockStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumStoredFilter<$PrismaModel = never> = {
    equals?: $Enums.Stored | EnumStoredFieldRefInput<$PrismaModel>
    in?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    not?: NestedEnumStoredFilter<$PrismaModel> | $Enums.Stored
  }

  export type NestedEnumStoredWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stored | EnumStoredFieldRefInput<$PrismaModel>
    in?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stored[] | ListEnumStoredFieldRefInput<$PrismaModel>
    not?: NestedEnumStoredWithAggregatesFilter<$PrismaModel> | $Enums.Stored
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoredFilter<$PrismaModel>
    _max?: NestedEnumStoredFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type FarmerCreateWithoutBranchInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFarmerInput
    flocks?: FlockCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateWithoutBranchInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerCreateOrConnectWithoutBranchInput = {
    where: FarmerWhereUniqueInput
    create: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput>
  }

  export type FarmerCreateManyBranchInputEnvelope = {
    data: FarmerCreateManyBranchInput | FarmerCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type FlockCreateWithoutBranchInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutBranchInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutBranchInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput>
  }

  export type FlockCreateManyBranchInputEnvelope = {
    data: FlockCreateManyBranchInput | FlockCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type FeedCreateWithoutBranchInput = {
    id?: string
    stock: number
    createdAt: Date | string
    updatedAt?: Date | string
    feedNameCategory: FeedNameCategoryCreateNestedOneWithoutFeedsInput
  }

  export type FeedUncheckedCreateWithoutBranchInput = {
    id?: string
    feedName: string
    stock: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedCreateOrConnectWithoutBranchInput = {
    where: FeedWhereUniqueInput
    create: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput>
  }

  export type FeedCreateManyBranchInputEnvelope = {
    data: FeedCreateManyBranchInput | FeedCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type MedicineStockCreateWithoutBranchInput = {
    id?: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicineStockInput
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineStockInput
  }

  export type MedicineStockUncheckedCreateWithoutBranchInput = {
    id?: string
    genericName: string
    medicineName: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockCreateOrConnectWithoutBranchInput = {
    where: MedicineStockWhereUniqueInput
    create: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput>
  }

  export type MedicineStockCreateManyBranchInputEnvelope = {
    data: MedicineStockCreateManyBranchInput | MedicineStockCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type MedicinePurchessCreateWithoutBranchInput = {
    id?: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicinePurchessInput
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicinePurchessInput
  }

  export type MedicinePurchessUncheckedCreateWithoutBranchInput = {
    id?: string
    genericName: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateOrConnectWithoutBranchInput = {
    where: MedicinePurchessWhereUniqueInput
    create: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput>
  }

  export type MedicinePurchessCreateManyBranchInputEnvelope = {
    data: MedicinePurchessCreateManyBranchInput | MedicinePurchessCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SellMedicineCreateWithoutBranchInput = {
    id?: string
    billNumber?: number | null
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutSellMedicineInput
    farmer: FarmerCreateNestedOneWithoutSellMedicineInput
    MedicineTransfer?: MedicineTransferCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineUncheckedCreateWithoutBranchInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    MedicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineCreateOrConnectWithoutBranchInput = {
    where: SellMedicineWhereUniqueInput
    create: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput>
  }

  export type SellMedicineCreateManyBranchInputEnvelope = {
    data: SellMedicineCreateManyBranchInput | SellMedicineCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type MedicineTransferCreateWithoutBaranchInput = {
    id?: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    sellmedicine: SellMedicineCreateNestedOneWithoutMedicineTransferInput
    flock: FlockCreateNestedOneWithoutMedicineTransferInput
  }

  export type MedicineTransferUncheckedCreateWithoutBaranchInput = {
    id?: string
    billNumber: number
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferCreateOrConnectWithoutBaranchInput = {
    where: MedicineTransferWhereUniqueInput
    create: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput>
  }

  export type MedicineTransferCreateManyBaranchInputEnvelope = {
    data: MedicineTransferCreateManyBaranchInput | MedicineTransferCreateManyBaranchInput[]
    skipDuplicates?: boolean
  }

  export type FlockReportCreateWithoutBranchInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutFlockReportInput
    farmer: FarmerCreateNestedOneWithoutFlockReportInput
  }

  export type FlockReportUncheckedCreateWithoutBranchInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateOrConnectWithoutBranchInput = {
    where: FlockReportWhereUniqueInput
    create: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput>
  }

  export type FlockReportCreateManyBranchInputEnvelope = {
    data: FlockReportCreateManyBranchInput | FlockReportCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BranchEmployeeHistoryCreateWithoutBranchInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutBranchEmployeeHistoryInput
  }

  export type BranchEmployeeHistoryUncheckedCreateWithoutBranchInput = {
    id?: string
    employeeId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryCreateOrConnectWithoutBranchInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    create: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput>
  }

  export type BranchEmployeeHistoryCreateManyBranchInputEnvelope = {
    data: BranchEmployeeHistoryCreateManyBranchInput | BranchEmployeeHistoryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type FarmerUpsertWithWhereUniqueWithoutBranchInput = {
    where: FarmerWhereUniqueInput
    update: XOR<FarmerUpdateWithoutBranchInput, FarmerUncheckedUpdateWithoutBranchInput>
    create: XOR<FarmerCreateWithoutBranchInput, FarmerUncheckedCreateWithoutBranchInput>
  }

  export type FarmerUpdateWithWhereUniqueWithoutBranchInput = {
    where: FarmerWhereUniqueInput
    data: XOR<FarmerUpdateWithoutBranchInput, FarmerUncheckedUpdateWithoutBranchInput>
  }

  export type FarmerUpdateManyWithWhereWithoutBranchInput = {
    where: FarmerScalarWhereInput
    data: XOR<FarmerUpdateManyMutationInput, FarmerUncheckedUpdateManyWithoutBranchInput>
  }

  export type FarmerScalarWhereInput = {
    AND?: FarmerScalarWhereInput | FarmerScalarWhereInput[]
    OR?: FarmerScalarWhereInput[]
    NOT?: FarmerScalarWhereInput | FarmerScalarWhereInput[]
    id?: StringFilter<"Farmer"> | string
    branchCode?: StringNullableFilter<"Farmer"> | string | null
    farmCode?: IntFilter<"Farmer"> | number
    name?: StringFilter<"Farmer"> | string
    farmType?: EnumCusttypeFilter<"Farmer"> | $Enums.Custtype
    totalShed?: IntFilter<"Farmer"> | number
    totalSquare?: IntFilter<"Farmer"> | number
    phoneNumber?: StringFilter<"Farmer"> | string
    capacity?: IntFilter<"Farmer"> | number
    addressId?: StringNullableFilter<"Farmer"> | string | null
    nid?: StringFilter<"Farmer"> | string
    createdAt?: DateTimeFilter<"Farmer"> | Date | string
    updatedAt?: DateTimeFilter<"Farmer"> | Date | string
  }

  export type FlockUpsertWithWhereUniqueWithoutBranchInput = {
    where: FlockWhereUniqueInput
    update: XOR<FlockUpdateWithoutBranchInput, FlockUncheckedUpdateWithoutBranchInput>
    create: XOR<FlockCreateWithoutBranchInput, FlockUncheckedCreateWithoutBranchInput>
  }

  export type FlockUpdateWithWhereUniqueWithoutBranchInput = {
    where: FlockWhereUniqueInput
    data: XOR<FlockUpdateWithoutBranchInput, FlockUncheckedUpdateWithoutBranchInput>
  }

  export type FlockUpdateManyWithWhereWithoutBranchInput = {
    where: FlockScalarWhereInput
    data: XOR<FlockUpdateManyMutationInput, FlockUncheckedUpdateManyWithoutBranchInput>
  }

  export type FlockScalarWhereInput = {
    AND?: FlockScalarWhereInput | FlockScalarWhereInput[]
    OR?: FlockScalarWhereInput[]
    NOT?: FlockScalarWhereInput | FlockScalarWhereInput[]
    id?: StringFilter<"Flock"> | string
    flockNumber?: IntFilter<"Flock"> | number
    flockStatus?: EnumFlockStatusFilter<"Flock"> | $Enums.FlockStatus
    startDate?: DateTimeFilter<"Flock"> | Date | string
    endDate?: DateTimeNullableFilter<"Flock"> | Date | string | null
    executiveId?: StringFilter<"Flock"> | string
    farmId?: StringFilter<"Flock"> | string
    docName?: StringFilter<"Flock"> | string
    docQuantity?: IntFilter<"Flock"> | number
    approvedBy?: StringNullableFilter<"Flock"> | string | null
    branchCode?: StringFilter<"Flock"> | string
    totalFeedKg?: IntFilter<"Flock"> | number
    totalMedicine?: IntFilter<"Flock"> | number
    fcr?: FloatFilter<"Flock"> | number
    totalSellBirds?: IntFilter<"Flock"> | number
    mortality?: IntFilter<"Flock"> | number
    createdAt?: DateTimeFilter<"Flock"> | Date | string
    updatedAt?: DateTimeFilter<"Flock"> | Date | string
  }

  export type FeedUpsertWithWhereUniqueWithoutBranchInput = {
    where: FeedWhereUniqueInput
    update: XOR<FeedUpdateWithoutBranchInput, FeedUncheckedUpdateWithoutBranchInput>
    create: XOR<FeedCreateWithoutBranchInput, FeedUncheckedCreateWithoutBranchInput>
  }

  export type FeedUpdateWithWhereUniqueWithoutBranchInput = {
    where: FeedWhereUniqueInput
    data: XOR<FeedUpdateWithoutBranchInput, FeedUncheckedUpdateWithoutBranchInput>
  }

  export type FeedUpdateManyWithWhereWithoutBranchInput = {
    where: FeedScalarWhereInput
    data: XOR<FeedUpdateManyMutationInput, FeedUncheckedUpdateManyWithoutBranchInput>
  }

  export type FeedScalarWhereInput = {
    AND?: FeedScalarWhereInput | FeedScalarWhereInput[]
    OR?: FeedScalarWhereInput[]
    NOT?: FeedScalarWhereInput | FeedScalarWhereInput[]
    id?: StringFilter<"Feed"> | string
    feedName?: StringFilter<"Feed"> | string
    stock?: IntFilter<"Feed"> | number
    branchCode?: StringNullableFilter<"Feed"> | string | null
    createdAt?: DateTimeFilter<"Feed"> | Date | string
    updatedAt?: DateTimeFilter<"Feed"> | Date | string
  }

  export type MedicineStockUpsertWithWhereUniqueWithoutBranchInput = {
    where: MedicineStockWhereUniqueInput
    update: XOR<MedicineStockUpdateWithoutBranchInput, MedicineStockUncheckedUpdateWithoutBranchInput>
    create: XOR<MedicineStockCreateWithoutBranchInput, MedicineStockUncheckedCreateWithoutBranchInput>
  }

  export type MedicineStockUpdateWithWhereUniqueWithoutBranchInput = {
    where: MedicineStockWhereUniqueInput
    data: XOR<MedicineStockUpdateWithoutBranchInput, MedicineStockUncheckedUpdateWithoutBranchInput>
  }

  export type MedicineStockUpdateManyWithWhereWithoutBranchInput = {
    where: MedicineStockScalarWhereInput
    data: XOR<MedicineStockUpdateManyMutationInput, MedicineStockUncheckedUpdateManyWithoutBranchInput>
  }

  export type MedicineStockScalarWhereInput = {
    AND?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
    OR?: MedicineStockScalarWhereInput[]
    NOT?: MedicineStockScalarWhereInput | MedicineStockScalarWhereInput[]
    id?: StringFilter<"MedicineStock"> | string
    genericName?: StringFilter<"MedicineStock"> | string
    medicineName?: StringFilter<"MedicineStock"> | string
    branchCode?: StringFilter<"MedicineStock"> | string
    totalStock?: IntFilter<"MedicineStock"> | number
    price?: IntFilter<"MedicineStock"> | number
    createdAt?: DateTimeFilter<"MedicineStock"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineStock"> | Date | string
  }

  export type MedicinePurchessUpsertWithWhereUniqueWithoutBranchInput = {
    where: MedicinePurchessWhereUniqueInput
    update: XOR<MedicinePurchessUpdateWithoutBranchInput, MedicinePurchessUncheckedUpdateWithoutBranchInput>
    create: XOR<MedicinePurchessCreateWithoutBranchInput, MedicinePurchessUncheckedCreateWithoutBranchInput>
  }

  export type MedicinePurchessUpdateWithWhereUniqueWithoutBranchInput = {
    where: MedicinePurchessWhereUniqueInput
    data: XOR<MedicinePurchessUpdateWithoutBranchInput, MedicinePurchessUncheckedUpdateWithoutBranchInput>
  }

  export type MedicinePurchessUpdateManyWithWhereWithoutBranchInput = {
    where: MedicinePurchessScalarWhereInput
    data: XOR<MedicinePurchessUpdateManyMutationInput, MedicinePurchessUncheckedUpdateManyWithoutBranchInput>
  }

  export type MedicinePurchessScalarWhereInput = {
    AND?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
    OR?: MedicinePurchessScalarWhereInput[]
    NOT?: MedicinePurchessScalarWhereInput | MedicinePurchessScalarWhereInput[]
    id?: StringFilter<"MedicinePurchess"> | string
    genericName?: StringFilter<"MedicinePurchess"> | string
    name?: StringFilter<"MedicinePurchess"> | string
    purchaseUnitPrice?: IntFilter<"MedicinePurchess"> | number
    sellUnitPrice?: IntFilter<"MedicinePurchess"> | number
    purchaseQuantity?: IntFilter<"MedicinePurchess"> | number
    mfgDate?: StringFilter<"MedicinePurchess"> | string
    expDate?: StringFilter<"MedicinePurchess"> | string
    bonusQuantity?: IntNullableFilter<"MedicinePurchess"> | number | null
    purchaseTotalPrice?: IntFilter<"MedicinePurchess"> | number
    supplierInfo?: StringFilter<"MedicinePurchess"> | string
    stored?: EnumStoredFilter<"MedicinePurchess"> | $Enums.Stored
    branchCode?: StringFilter<"MedicinePurchess"> | string
    createdAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
    updatedAt?: DateTimeFilter<"MedicinePurchess"> | Date | string
  }

  export type SellMedicineUpsertWithWhereUniqueWithoutBranchInput = {
    where: SellMedicineWhereUniqueInput
    update: XOR<SellMedicineUpdateWithoutBranchInput, SellMedicineUncheckedUpdateWithoutBranchInput>
    create: XOR<SellMedicineCreateWithoutBranchInput, SellMedicineUncheckedCreateWithoutBranchInput>
  }

  export type SellMedicineUpdateWithWhereUniqueWithoutBranchInput = {
    where: SellMedicineWhereUniqueInput
    data: XOR<SellMedicineUpdateWithoutBranchInput, SellMedicineUncheckedUpdateWithoutBranchInput>
  }

  export type SellMedicineUpdateManyWithWhereWithoutBranchInput = {
    where: SellMedicineScalarWhereInput
    data: XOR<SellMedicineUpdateManyMutationInput, SellMedicineUncheckedUpdateManyWithoutBranchInput>
  }

  export type SellMedicineScalarWhereInput = {
    AND?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
    OR?: SellMedicineScalarWhereInput[]
    NOT?: SellMedicineScalarWhereInput | SellMedicineScalarWhereInput[]
    id?: StringFilter<"SellMedicine"> | string
    billNumber?: IntNullableFilter<"SellMedicine"> | number | null
    farmId?: StringFilter<"SellMedicine"> | string
    flockNumer?: IntFilter<"SellMedicine"> | number
    genericName?: StringFilter<"SellMedicine"> | string
    medicineName?: StringFilter<"SellMedicine"> | string
    sellQuantity?: IntFilter<"SellMedicine"> | number
    sellPrice?: IntFilter<"SellMedicine"> | number
    Delivery?: EnumDeliveryStatusFilter<"SellMedicine"> | $Enums.DeliveryStatus
    sellDate?: StringFilter<"SellMedicine"> | string
    branchCode?: StringFilter<"SellMedicine"> | string
    createdAt?: DateTimeFilter<"SellMedicine"> | Date | string
    updatedAt?: DateTimeFilter<"SellMedicine"> | Date | string
  }

  export type MedicineTransferUpsertWithWhereUniqueWithoutBaranchInput = {
    where: MedicineTransferWhereUniqueInput
    update: XOR<MedicineTransferUpdateWithoutBaranchInput, MedicineTransferUncheckedUpdateWithoutBaranchInput>
    create: XOR<MedicineTransferCreateWithoutBaranchInput, MedicineTransferUncheckedCreateWithoutBaranchInput>
  }

  export type MedicineTransferUpdateWithWhereUniqueWithoutBaranchInput = {
    where: MedicineTransferWhereUniqueInput
    data: XOR<MedicineTransferUpdateWithoutBaranchInput, MedicineTransferUncheckedUpdateWithoutBaranchInput>
  }

  export type MedicineTransferUpdateManyWithWhereWithoutBaranchInput = {
    where: MedicineTransferScalarWhereInput
    data: XOR<MedicineTransferUpdateManyMutationInput, MedicineTransferUncheckedUpdateManyWithoutBaranchInput>
  }

  export type MedicineTransferScalarWhereInput = {
    AND?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
    OR?: MedicineTransferScalarWhereInput[]
    NOT?: MedicineTransferScalarWhereInput | MedicineTransferScalarWhereInput[]
    id?: StringFilter<"MedicineTransfer"> | string
    billNumber?: IntFilter<"MedicineTransfer"> | number
    flockId?: StringFilter<"MedicineTransfer"> | string
    fromFarmcode?: IntNullableFilter<"MedicineTransfer"> | number | null
    toFarmcode?: IntFilter<"MedicineTransfer"> | number
    medicineName?: StringFilter<"MedicineTransfer"> | string
    genericName?: StringFilter<"MedicineTransfer"> | string
    branchCode?: StringFilter<"MedicineTransfer"> | string
    createdAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineTransfer"> | Date | string
  }

  export type FlockReportUpsertWithWhereUniqueWithoutBranchInput = {
    where: FlockReportWhereUniqueInput
    update: XOR<FlockReportUpdateWithoutBranchInput, FlockReportUncheckedUpdateWithoutBranchInput>
    create: XOR<FlockReportCreateWithoutBranchInput, FlockReportUncheckedCreateWithoutBranchInput>
  }

  export type FlockReportUpdateWithWhereUniqueWithoutBranchInput = {
    where: FlockReportWhereUniqueInput
    data: XOR<FlockReportUpdateWithoutBranchInput, FlockReportUncheckedUpdateWithoutBranchInput>
  }

  export type FlockReportUpdateManyWithWhereWithoutBranchInput = {
    where: FlockReportScalarWhereInput
    data: XOR<FlockReportUpdateManyMutationInput, FlockReportUncheckedUpdateManyWithoutBranchInput>
  }

  export type FlockReportScalarWhereInput = {
    AND?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
    OR?: FlockReportScalarWhereInput[]
    NOT?: FlockReportScalarWhereInput | FlockReportScalarWhereInput[]
    id?: StringFilter<"FlockReport"> | string
    housedBirds?: IntFilter<"FlockReport"> | number
    fcr?: FloatNullableFilter<"FlockReport"> | number | null
    executiveId?: StringFilter<"FlockReport"> | string
    totalMortality?: IntNullableFilter<"FlockReport"> | number | null
    todayMortality?: IntFilter<"FlockReport"> | number
    todayMortalityPercent?: FloatNullableFilter<"FlockReport"> | number | null
    totalMortalityPercentage?: FloatNullableFilter<"FlockReport"> | number | null
    bodyWeight?: FloatFilter<"FlockReport"> | number
    todayWeightGain?: IntFilter<"FlockReport"> | number
    todayFeedEting?: IntFilter<"FlockReport"> | number
    suggestTosell?: BoolFilter<"FlockReport"> | boolean
    averageBodyWight?: FloatNullableFilter<"FlockReport"> | number | null
    totalFeedEting?: IntFilter<"FlockReport"> | number
    feedStock?: IntFilter<"FlockReport"> | number
    diseases?: StringFilter<"FlockReport"> | string
    birdsStock?: IntFilter<"FlockReport"> | number
    condition?: StringFilter<"FlockReport"> | string
    description?: StringFilter<"FlockReport"> | string
    executiveName?: StringFilter<"FlockReport"> | string
    flockNumber?: StringFilter<"FlockReport"> | string
    age?: IntNullableFilter<"FlockReport"> | number | null
    imagesOne?: StringNullableFilter<"FlockReport"> | string | null
    imageTwo?: StringNullableFilter<"FlockReport"> | string | null
    imageThree?: StringNullableFilter<"FlockReport"> | string | null
    visitedDate?: DateTimeFilter<"FlockReport"> | Date | string
    locationLink?: StringFilter<"FlockReport"> | string
    farmId?: StringFilter<"FlockReport"> | string
    flockId?: StringFilter<"FlockReport"> | string
    birdsSalesStart?: BoolFilter<"FlockReport"> | boolean
    birdsSalesEnd?: BoolFilter<"FlockReport"> | boolean
    branchCode?: StringFilter<"FlockReport"> | string
    createdAt?: DateTimeFilter<"FlockReport"> | Date | string
    updatedAt?: DateTimeFilter<"FlockReport"> | Date | string
  }

  export type BranchEmployeeHistoryUpsertWithWhereUniqueWithoutBranchInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    update: XOR<BranchEmployeeHistoryUpdateWithoutBranchInput, BranchEmployeeHistoryUncheckedUpdateWithoutBranchInput>
    create: XOR<BranchEmployeeHistoryCreateWithoutBranchInput, BranchEmployeeHistoryUncheckedCreateWithoutBranchInput>
  }

  export type BranchEmployeeHistoryUpdateWithWhereUniqueWithoutBranchInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    data: XOR<BranchEmployeeHistoryUpdateWithoutBranchInput, BranchEmployeeHistoryUncheckedUpdateWithoutBranchInput>
  }

  export type BranchEmployeeHistoryUpdateManyWithWhereWithoutBranchInput = {
    where: BranchEmployeeHistoryScalarWhereInput
    data: XOR<BranchEmployeeHistoryUpdateManyMutationInput, BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchInput>
  }

  export type BranchEmployeeHistoryScalarWhereInput = {
    AND?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
    OR?: BranchEmployeeHistoryScalarWhereInput[]
    NOT?: BranchEmployeeHistoryScalarWhereInput | BranchEmployeeHistoryScalarWhereInput[]
    id?: StringFilter<"BranchEmployeeHistory"> | string
    employeeId?: StringFilter<"BranchEmployeeHistory"> | string
    startDate?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"BranchEmployeeHistory"> | Date | string | null
    isActive?: BoolFilter<"BranchEmployeeHistory"> | boolean
    branchCode?: StringFilter<"BranchEmployeeHistory"> | string
    createdAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchEmployeeHistory"> | Date | string
  }

  export type BranchCreateWithoutFarmerInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFarmerInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFarmerInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFarmerInput, BranchUncheckedCreateWithoutFarmerInput>
  }

  export type AddressCreateWithoutFarmerInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutFarmerInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutFarmerInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutFarmerInput, AddressUncheckedCreateWithoutFarmerInput>
  }

  export type FlockCreateWithoutFarmerInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutFarmerInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutFarmerInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput>
  }

  export type FlockCreateManyFarmerInputEnvelope = {
    data: FlockCreateManyFarmerInput | FlockCreateManyFarmerInput[]
    skipDuplicates?: boolean
  }

  export type SellMedicineCreateWithoutFarmerInput = {
    id?: string
    billNumber?: number | null
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutSellMedicineInput
    branch: BranchCreateNestedOneWithoutSellMedicineInput
    MedicineTransfer?: MedicineTransferCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineUncheckedCreateWithoutFarmerInput = {
    id?: string
    billNumber?: number | null
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    MedicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineCreateOrConnectWithoutFarmerInput = {
    where: SellMedicineWhereUniqueInput
    create: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput>
  }

  export type SellMedicineCreateManyFarmerInputEnvelope = {
    data: SellMedicineCreateManyFarmerInput | SellMedicineCreateManyFarmerInput[]
    skipDuplicates?: boolean
  }

  export type FlockReportCreateWithoutFarmerInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFlockReportInput
    flock: FlockCreateNestedOneWithoutFlockReportInput
  }

  export type FlockReportUncheckedCreateWithoutFarmerInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateOrConnectWithoutFarmerInput = {
    where: FlockReportWhereUniqueInput
    create: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput>
  }

  export type FlockReportCreateManyFarmerInputEnvelope = {
    data: FlockReportCreateManyFarmerInput | FlockReportCreateManyFarmerInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutFarmerInput = {
    update: XOR<BranchUpdateWithoutFarmerInput, BranchUncheckedUpdateWithoutFarmerInput>
    create: XOR<BranchCreateWithoutFarmerInput, BranchUncheckedCreateWithoutFarmerInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFarmerInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFarmerInput, BranchUncheckedUpdateWithoutFarmerInput>
  }

  export type BranchUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AddressUpsertWithoutFarmerInput = {
    update: XOR<AddressUpdateWithoutFarmerInput, AddressUncheckedUpdateWithoutFarmerInput>
    create: XOR<AddressCreateWithoutFarmerInput, AddressUncheckedCreateWithoutFarmerInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutFarmerInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutFarmerInput, AddressUncheckedUpdateWithoutFarmerInput>
  }

  export type AddressUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type FlockUpsertWithWhereUniqueWithoutFarmerInput = {
    where: FlockWhereUniqueInput
    update: XOR<FlockUpdateWithoutFarmerInput, FlockUncheckedUpdateWithoutFarmerInput>
    create: XOR<FlockCreateWithoutFarmerInput, FlockUncheckedCreateWithoutFarmerInput>
  }

  export type FlockUpdateWithWhereUniqueWithoutFarmerInput = {
    where: FlockWhereUniqueInput
    data: XOR<FlockUpdateWithoutFarmerInput, FlockUncheckedUpdateWithoutFarmerInput>
  }

  export type FlockUpdateManyWithWhereWithoutFarmerInput = {
    where: FlockScalarWhereInput
    data: XOR<FlockUpdateManyMutationInput, FlockUncheckedUpdateManyWithoutFarmerInput>
  }

  export type SellMedicineUpsertWithWhereUniqueWithoutFarmerInput = {
    where: SellMedicineWhereUniqueInput
    update: XOR<SellMedicineUpdateWithoutFarmerInput, SellMedicineUncheckedUpdateWithoutFarmerInput>
    create: XOR<SellMedicineCreateWithoutFarmerInput, SellMedicineUncheckedCreateWithoutFarmerInput>
  }

  export type SellMedicineUpdateWithWhereUniqueWithoutFarmerInput = {
    where: SellMedicineWhereUniqueInput
    data: XOR<SellMedicineUpdateWithoutFarmerInput, SellMedicineUncheckedUpdateWithoutFarmerInput>
  }

  export type SellMedicineUpdateManyWithWhereWithoutFarmerInput = {
    where: SellMedicineScalarWhereInput
    data: XOR<SellMedicineUpdateManyMutationInput, SellMedicineUncheckedUpdateManyWithoutFarmerInput>
  }

  export type FlockReportUpsertWithWhereUniqueWithoutFarmerInput = {
    where: FlockReportWhereUniqueInput
    update: XOR<FlockReportUpdateWithoutFarmerInput, FlockReportUncheckedUpdateWithoutFarmerInput>
    create: XOR<FlockReportCreateWithoutFarmerInput, FlockReportUncheckedCreateWithoutFarmerInput>
  }

  export type FlockReportUpdateWithWhereUniqueWithoutFarmerInput = {
    where: FlockReportWhereUniqueInput
    data: XOR<FlockReportUpdateWithoutFarmerInput, FlockReportUncheckedUpdateWithoutFarmerInput>
  }

  export type FlockReportUpdateManyWithWhereWithoutFarmerInput = {
    where: FlockReportScalarWhereInput
    data: XOR<FlockReportUpdateManyMutationInput, FlockReportUncheckedUpdateManyWithoutFarmerInput>
  }

  export type FarmerCreateWithoutAddressInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFarmerInput
    flocks?: FlockCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateWithoutAddressInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerCreateOrConnectWithoutAddressInput = {
    where: FarmerWhereUniqueInput
    create: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
  }

  export type EmployeeCreateWithoutAddressInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockCreateNestedManyWithoutEmployeeInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAddressInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutEmployeeInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAddressInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
  }

  export type FarmerUpsertWithoutAddressInput = {
    update: XOR<FarmerUpdateWithoutAddressInput, FarmerUncheckedUpdateWithoutAddressInput>
    create: XOR<FarmerCreateWithoutAddressInput, FarmerUncheckedCreateWithoutAddressInput>
    where?: FarmerWhereInput
  }

  export type FarmerUpdateToOneWithWhereWithoutAddressInput = {
    where?: FarmerWhereInput
    data: XOR<FarmerUpdateWithoutAddressInput, FarmerUncheckedUpdateWithoutAddressInput>
  }

  export type FarmerUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFarmerNestedInput
    flocks?: FlockUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type EmployeeUpsertWithoutAddressInput = {
    update: XOR<EmployeeUpdateWithoutAddressInput, EmployeeUncheckedUpdateWithoutAddressInput>
    create: XOR<EmployeeCreateWithoutAddressInput, EmployeeUncheckedCreateWithoutAddressInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAddressInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAddressInput, EmployeeUncheckedUpdateWithoutAddressInput>
  }

  export type EmployeeUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUpdateManyWithoutEmployeeNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutEmployeeNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type BranchCreateWithoutBranchEmployeeHistoryInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBranchEmployeeHistoryInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBranchEmployeeHistoryInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBranchEmployeeHistoryInput, BranchUncheckedCreateWithoutBranchEmployeeHistoryInput>
  }

  export type EmployeeCreateWithoutBranchEmployeeHistoryInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutEmployeeInput
    flocks?: FlockCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutBranchEmployeeHistoryInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    addressId?: string | null
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutBranchEmployeeHistoryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedCreateWithoutBranchEmployeeHistoryInput>
  }

  export type BranchUpsertWithoutBranchEmployeeHistoryInput = {
    update: XOR<BranchUpdateWithoutBranchEmployeeHistoryInput, BranchUncheckedUpdateWithoutBranchEmployeeHistoryInput>
    create: XOR<BranchCreateWithoutBranchEmployeeHistoryInput, BranchUncheckedCreateWithoutBranchEmployeeHistoryInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBranchEmployeeHistoryInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBranchEmployeeHistoryInput, BranchUncheckedUpdateWithoutBranchEmployeeHistoryInput>
  }

  export type BranchUpdateWithoutBranchEmployeeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBranchEmployeeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EmployeeUpsertWithoutBranchEmployeeHistoryInput = {
    update: XOR<EmployeeUpdateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedUpdateWithoutBranchEmployeeHistoryInput>
    create: XOR<EmployeeCreateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedCreateWithoutBranchEmployeeHistoryInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutBranchEmployeeHistoryInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutBranchEmployeeHistoryInput, EmployeeUncheckedUpdateWithoutBranchEmployeeHistoryInput>
  }

  export type EmployeeUpdateWithoutBranchEmployeeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutEmployeeNestedInput
    flocks?: FlockUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBranchEmployeeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type AddressCreateWithoutEmployeeInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Farmer?: FarmerCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutEmployeeInput = {
    id?: string
    village: string
    post: string
    union?: string | null
    thana?: string | null
    upazila: string
    city: string
    createdAt: Date | string
    updatedAt?: Date | string
    Farmer?: FarmerUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutEmployeeInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutEmployeeInput, AddressUncheckedCreateWithoutEmployeeInput>
  }

  export type FlockCreateWithoutEmployeeInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutEmployeeInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutEmployeeInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput>
  }

  export type FlockCreateManyEmployeeInputEnvelope = {
    data: FlockCreateManyEmployeeInput | FlockCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type BranchEmployeeHistoryCreateWithoutEmployeeInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBranchEmployeeHistoryInput
  }

  export type BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryCreateOrConnectWithoutEmployeeInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    create: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput>
  }

  export type BranchEmployeeHistoryCreateManyEmployeeInputEnvelope = {
    data: BranchEmployeeHistoryCreateManyEmployeeInput | BranchEmployeeHistoryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutEmployeeInput = {
    update: XOR<AddressUpdateWithoutEmployeeInput, AddressUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AddressCreateWithoutEmployeeInput, AddressUncheckedCreateWithoutEmployeeInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutEmployeeInput, AddressUncheckedUpdateWithoutEmployeeInput>
  }

  export type AddressUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Farmer?: FarmerUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    union?: NullableStringFieldUpdateOperationsInput | string | null
    thana?: NullableStringFieldUpdateOperationsInput | string | null
    upazila?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Farmer?: FarmerUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type FlockUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: FlockWhereUniqueInput
    update: XOR<FlockUpdateWithoutEmployeeInput, FlockUncheckedUpdateWithoutEmployeeInput>
    create: XOR<FlockCreateWithoutEmployeeInput, FlockUncheckedCreateWithoutEmployeeInput>
  }

  export type FlockUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: FlockWhereUniqueInput
    data: XOR<FlockUpdateWithoutEmployeeInput, FlockUncheckedUpdateWithoutEmployeeInput>
  }

  export type FlockUpdateManyWithWhereWithoutEmployeeInput = {
    where: FlockScalarWhereInput
    data: XOR<FlockUpdateManyMutationInput, FlockUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type BranchEmployeeHistoryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    update: XOR<BranchEmployeeHistoryUpdateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<BranchEmployeeHistoryCreateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedCreateWithoutEmployeeInput>
  }

  export type BranchEmployeeHistoryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: BranchEmployeeHistoryWhereUniqueInput
    data: XOR<BranchEmployeeHistoryUpdateWithoutEmployeeInput, BranchEmployeeHistoryUncheckedUpdateWithoutEmployeeInput>
  }

  export type BranchEmployeeHistoryUpdateManyWithWhereWithoutEmployeeInput = {
    where: BranchEmployeeHistoryScalarWhereInput
    data: XOR<BranchEmployeeHistoryUpdateManyMutationInput, BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type FarmerCreateWithoutFlocksInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFarmerInput
    address?: AddressCreateNestedOneWithoutFarmerInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateWithoutFlocksInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerCreateOrConnectWithoutFlocksInput = {
    where: FarmerWhereUniqueInput
    create: XOR<FarmerCreateWithoutFlocksInput, FarmerUncheckedCreateWithoutFlocksInput>
  }

  export type EmployeeCreateWithoutFlocksInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutEmployeeInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutFlocksInput = {
    id?: string
    employeeId: string
    name: string
    workingLocation: string
    designation: string
    phoneNumber: string
    addressId?: string | null
    branchId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutFlocksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFlocksInput, EmployeeUncheckedCreateWithoutFlocksInput>
  }

  export type BranchCreateWithoutFlocksInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFlocksInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFlocksInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFlocksInput, BranchUncheckedCreateWithoutFlocksInput>
  }

  export type SellMedicineCreateWithoutFlockInput = {
    id?: string
    billNumber?: number | null
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSellMedicineInput
    farmer: FarmerCreateNestedOneWithoutSellMedicineInput
    MedicineTransfer?: MedicineTransferCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineUncheckedCreateWithoutFlockInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    MedicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutSellmedicineInput
  }

  export type SellMedicineCreateOrConnectWithoutFlockInput = {
    where: SellMedicineWhereUniqueInput
    create: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput>
  }

  export type SellMedicineCreateManyFlockInputEnvelope = {
    data: SellMedicineCreateManyFlockInput | SellMedicineCreateManyFlockInput[]
    skipDuplicates?: boolean
  }

  export type MedicineTransferCreateWithoutFlockInput = {
    id?: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    sellmedicine: SellMedicineCreateNestedOneWithoutMedicineTransferInput
    baranch: BranchCreateNestedOneWithoutMedicineTransferInput
  }

  export type MedicineTransferUncheckedCreateWithoutFlockInput = {
    id?: string
    billNumber: number
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferCreateOrConnectWithoutFlockInput = {
    where: MedicineTransferWhereUniqueInput
    create: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput>
  }

  export type MedicineTransferCreateManyFlockInputEnvelope = {
    data: MedicineTransferCreateManyFlockInput | MedicineTransferCreateManyFlockInput[]
    skipDuplicates?: boolean
  }

  export type FlockReportCreateWithoutFlockInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFlockReportInput
    farmer: FarmerCreateNestedOneWithoutFlockReportInput
  }

  export type FlockReportUncheckedCreateWithoutFlockInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateOrConnectWithoutFlockInput = {
    where: FlockReportWhereUniqueInput
    create: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput>
  }

  export type FlockReportCreateManyFlockInputEnvelope = {
    data: FlockReportCreateManyFlockInput | FlockReportCreateManyFlockInput[]
    skipDuplicates?: boolean
  }

  export type FarmerUpsertWithoutFlocksInput = {
    update: XOR<FarmerUpdateWithoutFlocksInput, FarmerUncheckedUpdateWithoutFlocksInput>
    create: XOR<FarmerCreateWithoutFlocksInput, FarmerUncheckedCreateWithoutFlocksInput>
    where?: FarmerWhereInput
  }

  export type FarmerUpdateToOneWithWhereWithoutFlocksInput = {
    where?: FarmerWhereInput
    data: XOR<FarmerUpdateWithoutFlocksInput, FarmerUncheckedUpdateWithoutFlocksInput>
  }

  export type FarmerUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFarmerNestedInput
    address?: AddressUpdateOneWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type EmployeeUpsertWithoutFlocksInput = {
    update: XOR<EmployeeUpdateWithoutFlocksInput, EmployeeUncheckedUpdateWithoutFlocksInput>
    create: XOR<EmployeeCreateWithoutFlocksInput, EmployeeUncheckedCreateWithoutFlocksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutFlocksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutFlocksInput, EmployeeUncheckedUpdateWithoutFlocksInput>
  }

  export type EmployeeUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutEmployeeNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workingLocation?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type BranchUpsertWithoutFlocksInput = {
    update: XOR<BranchUpdateWithoutFlocksInput, BranchUncheckedUpdateWithoutFlocksInput>
    create: XOR<BranchCreateWithoutFlocksInput, BranchUncheckedCreateWithoutFlocksInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFlocksInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFlocksInput, BranchUncheckedUpdateWithoutFlocksInput>
  }

  export type BranchUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type SellMedicineUpsertWithWhereUniqueWithoutFlockInput = {
    where: SellMedicineWhereUniqueInput
    update: XOR<SellMedicineUpdateWithoutFlockInput, SellMedicineUncheckedUpdateWithoutFlockInput>
    create: XOR<SellMedicineCreateWithoutFlockInput, SellMedicineUncheckedCreateWithoutFlockInput>
  }

  export type SellMedicineUpdateWithWhereUniqueWithoutFlockInput = {
    where: SellMedicineWhereUniqueInput
    data: XOR<SellMedicineUpdateWithoutFlockInput, SellMedicineUncheckedUpdateWithoutFlockInput>
  }

  export type SellMedicineUpdateManyWithWhereWithoutFlockInput = {
    where: SellMedicineScalarWhereInput
    data: XOR<SellMedicineUpdateManyMutationInput, SellMedicineUncheckedUpdateManyWithoutFlockInput>
  }

  export type MedicineTransferUpsertWithWhereUniqueWithoutFlockInput = {
    where: MedicineTransferWhereUniqueInput
    update: XOR<MedicineTransferUpdateWithoutFlockInput, MedicineTransferUncheckedUpdateWithoutFlockInput>
    create: XOR<MedicineTransferCreateWithoutFlockInput, MedicineTransferUncheckedCreateWithoutFlockInput>
  }

  export type MedicineTransferUpdateWithWhereUniqueWithoutFlockInput = {
    where: MedicineTransferWhereUniqueInput
    data: XOR<MedicineTransferUpdateWithoutFlockInput, MedicineTransferUncheckedUpdateWithoutFlockInput>
  }

  export type MedicineTransferUpdateManyWithWhereWithoutFlockInput = {
    where: MedicineTransferScalarWhereInput
    data: XOR<MedicineTransferUpdateManyMutationInput, MedicineTransferUncheckedUpdateManyWithoutFlockInput>
  }

  export type FlockReportUpsertWithWhereUniqueWithoutFlockInput = {
    where: FlockReportWhereUniqueInput
    update: XOR<FlockReportUpdateWithoutFlockInput, FlockReportUncheckedUpdateWithoutFlockInput>
    create: XOR<FlockReportCreateWithoutFlockInput, FlockReportUncheckedCreateWithoutFlockInput>
  }

  export type FlockReportUpdateWithWhereUniqueWithoutFlockInput = {
    where: FlockReportWhereUniqueInput
    data: XOR<FlockReportUpdateWithoutFlockInput, FlockReportUncheckedUpdateWithoutFlockInput>
  }

  export type FlockReportUpdateManyWithWhereWithoutFlockInput = {
    where: FlockReportScalarWhereInput
    data: XOR<FlockReportUpdateManyMutationInput, FlockReportUncheckedUpdateManyWithoutFlockInput>
  }

  export type BranchCreateWithoutFlockReportInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFlockReportInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFlockReportInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFlockReportInput, BranchUncheckedCreateWithoutFlockReportInput>
  }

  export type FlockCreateWithoutFlockReportInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutFlockReportInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutFlockReportInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutFlockReportInput, FlockUncheckedCreateWithoutFlockReportInput>
  }

  export type FarmerCreateWithoutFlockReportInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFarmerInput
    address?: AddressCreateNestedOneWithoutFarmerInput
    flocks?: FlockCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateWithoutFlockReportInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutFarmerInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerCreateOrConnectWithoutFlockReportInput = {
    where: FarmerWhereUniqueInput
    create: XOR<FarmerCreateWithoutFlockReportInput, FarmerUncheckedCreateWithoutFlockReportInput>
  }

  export type BranchUpsertWithoutFlockReportInput = {
    update: XOR<BranchUpdateWithoutFlockReportInput, BranchUncheckedUpdateWithoutFlockReportInput>
    create: XOR<BranchCreateWithoutFlockReportInput, BranchUncheckedCreateWithoutFlockReportInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFlockReportInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFlockReportInput, BranchUncheckedUpdateWithoutFlockReportInput>
  }

  export type BranchUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FlockUpsertWithoutFlockReportInput = {
    update: XOR<FlockUpdateWithoutFlockReportInput, FlockUncheckedUpdateWithoutFlockReportInput>
    create: XOR<FlockCreateWithoutFlockReportInput, FlockUncheckedCreateWithoutFlockReportInput>
    where?: FlockWhereInput
  }

  export type FlockUpdateToOneWithWhereWithoutFlockReportInput = {
    where?: FlockWhereInput
    data: XOR<FlockUpdateWithoutFlockReportInput, FlockUncheckedUpdateWithoutFlockReportInput>
  }

  export type FlockUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type FarmerUpsertWithoutFlockReportInput = {
    update: XOR<FarmerUpdateWithoutFlockReportInput, FarmerUncheckedUpdateWithoutFlockReportInput>
    create: XOR<FarmerCreateWithoutFlockReportInput, FarmerUncheckedCreateWithoutFlockReportInput>
    where?: FarmerWhereInput
  }

  export type FarmerUpdateToOneWithWhereWithoutFlockReportInput = {
    where?: FarmerWhereInput
    data: XOR<FarmerUpdateWithoutFlockReportInput, FarmerUncheckedUpdateWithoutFlockReportInput>
  }

  export type FarmerUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFarmerNestedInput
    address?: AddressUpdateOneWithoutFarmerNestedInput
    flocks?: FlockUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateWithoutFlockReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type FeedCreateWithoutFeedNameCategoryInput = {
    id?: string
    stock: number
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFeedInput
  }

  export type FeedUncheckedCreateWithoutFeedNameCategoryInput = {
    id?: string
    stock: number
    branchCode?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedCreateOrConnectWithoutFeedNameCategoryInput = {
    where: FeedWhereUniqueInput
    create: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput>
  }

  export type FeedCreateManyFeedNameCategoryInputEnvelope = {
    data: FeedCreateManyFeedNameCategoryInput | FeedCreateManyFeedNameCategoryInput[]
    skipDuplicates?: boolean
  }

  export type FeedUpsertWithWhereUniqueWithoutFeedNameCategoryInput = {
    where: FeedWhereUniqueInput
    update: XOR<FeedUpdateWithoutFeedNameCategoryInput, FeedUncheckedUpdateWithoutFeedNameCategoryInput>
    create: XOR<FeedCreateWithoutFeedNameCategoryInput, FeedUncheckedCreateWithoutFeedNameCategoryInput>
  }

  export type FeedUpdateWithWhereUniqueWithoutFeedNameCategoryInput = {
    where: FeedWhereUniqueInput
    data: XOR<FeedUpdateWithoutFeedNameCategoryInput, FeedUncheckedUpdateWithoutFeedNameCategoryInput>
  }

  export type FeedUpdateManyWithWhereWithoutFeedNameCategoryInput = {
    where: FeedScalarWhereInput
    data: XOR<FeedUpdateManyMutationInput, FeedUncheckedUpdateManyWithoutFeedNameCategoryInput>
  }

  export type FeedNameCategoryCreateWithoutFeedsInput = {
    id?: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedNameCategoryUncheckedCreateWithoutFeedsInput = {
    id?: string
    feedName: string
    feedCodeNumber: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedNameCategoryCreateOrConnectWithoutFeedsInput = {
    where: FeedNameCategoryWhereUniqueInput
    create: XOR<FeedNameCategoryCreateWithoutFeedsInput, FeedNameCategoryUncheckedCreateWithoutFeedsInput>
  }

  export type BranchCreateWithoutFeedInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFeedInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFeedInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFeedInput, BranchUncheckedCreateWithoutFeedInput>
  }

  export type FeedNameCategoryUpsertWithoutFeedsInput = {
    update: XOR<FeedNameCategoryUpdateWithoutFeedsInput, FeedNameCategoryUncheckedUpdateWithoutFeedsInput>
    create: XOR<FeedNameCategoryCreateWithoutFeedsInput, FeedNameCategoryUncheckedCreateWithoutFeedsInput>
    where?: FeedNameCategoryWhereInput
  }

  export type FeedNameCategoryUpdateToOneWithWhereWithoutFeedsInput = {
    where?: FeedNameCategoryWhereInput
    data: XOR<FeedNameCategoryUpdateWithoutFeedsInput, FeedNameCategoryUncheckedUpdateWithoutFeedsInput>
  }

  export type FeedNameCategoryUpdateWithoutFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedNameCategoryUncheckedUpdateWithoutFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    feedCodeNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpsertWithoutFeedInput = {
    update: XOR<BranchUpdateWithoutFeedInput, BranchUncheckedUpdateWithoutFeedInput>
    create: XOR<BranchCreateWithoutFeedInput, BranchUncheckedCreateWithoutFeedInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFeedInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFeedInput, BranchUncheckedUpdateWithoutFeedInput>
  }

  export type BranchUpdateWithoutFeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MedicineNameAddCreateWithoutMedicineCategoryInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineNameAddInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineNameAddInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddCreateOrConnectWithoutMedicineCategoryInput = {
    where: MedicineNameAddWhereUniqueInput
    create: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicineNameAddCreateManyMedicineCategoryInputEnvelope = {
    data: MedicineNameAddCreateManyMedicineCategoryInput | MedicineNameAddCreateManyMedicineCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MedicineStockCreateWithoutMedicineCategoryInput = {
    id?: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicineStockInput
    branch: BranchCreateNestedOneWithoutMedicineStockInput
  }

  export type MedicineStockUncheckedCreateWithoutMedicineCategoryInput = {
    id?: string
    medicineName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockCreateOrConnectWithoutMedicineCategoryInput = {
    where: MedicineStockWhereUniqueInput
    create: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicineStockCreateManyMedicineCategoryInputEnvelope = {
    data: MedicineStockCreateManyMedicineCategoryInput | MedicineStockCreateManyMedicineCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MedicinePurchessCreateWithoutMedicineCategoryInput = {
    id?: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd: MedicineNameAddCreateNestedOneWithoutMedicinePurchessInput
    branch: BranchCreateNestedOneWithoutMedicinePurchessInput
  }

  export type MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput = {
    id?: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateOrConnectWithoutMedicineCategoryInput = {
    where: MedicinePurchessWhereUniqueInput
    create: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicinePurchessCreateManyMedicineCategoryInputEnvelope = {
    data: MedicinePurchessCreateManyMedicineCategoryInput | MedicinePurchessCreateManyMedicineCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MedicineNameAddUpsertWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicineNameAddWhereUniqueInput
    update: XOR<MedicineNameAddUpdateWithoutMedicineCategoryInput, MedicineNameAddUncheckedUpdateWithoutMedicineCategoryInput>
    create: XOR<MedicineNameAddCreateWithoutMedicineCategoryInput, MedicineNameAddUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicineNameAddUpdateWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicineNameAddWhereUniqueInput
    data: XOR<MedicineNameAddUpdateWithoutMedicineCategoryInput, MedicineNameAddUncheckedUpdateWithoutMedicineCategoryInput>
  }

  export type MedicineNameAddUpdateManyWithWhereWithoutMedicineCategoryInput = {
    where: MedicineNameAddScalarWhereInput
    data: XOR<MedicineNameAddUpdateManyMutationInput, MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryInput>
  }

  export type MedicineNameAddScalarWhereInput = {
    AND?: MedicineNameAddScalarWhereInput | MedicineNameAddScalarWhereInput[]
    OR?: MedicineNameAddScalarWhereInput[]
    NOT?: MedicineNameAddScalarWhereInput | MedicineNameAddScalarWhereInput[]
    id?: StringFilter<"MedicineNameAdd"> | string
    name?: StringFilter<"MedicineNameAdd"> | string
    conpany?: StringFilter<"MedicineNameAdd"> | string
    genericName?: StringFilter<"MedicineNameAdd"> | string
    createdAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineNameAdd"> | Date | string
  }

  export type MedicineStockUpsertWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicineStockWhereUniqueInput
    update: XOR<MedicineStockUpdateWithoutMedicineCategoryInput, MedicineStockUncheckedUpdateWithoutMedicineCategoryInput>
    create: XOR<MedicineStockCreateWithoutMedicineCategoryInput, MedicineStockUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicineStockUpdateWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicineStockWhereUniqueInput
    data: XOR<MedicineStockUpdateWithoutMedicineCategoryInput, MedicineStockUncheckedUpdateWithoutMedicineCategoryInput>
  }

  export type MedicineStockUpdateManyWithWhereWithoutMedicineCategoryInput = {
    where: MedicineStockScalarWhereInput
    data: XOR<MedicineStockUpdateManyMutationInput, MedicineStockUncheckedUpdateManyWithoutMedicineCategoryInput>
  }

  export type MedicinePurchessUpsertWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicinePurchessWhereUniqueInput
    update: XOR<MedicinePurchessUpdateWithoutMedicineCategoryInput, MedicinePurchessUncheckedUpdateWithoutMedicineCategoryInput>
    create: XOR<MedicinePurchessCreateWithoutMedicineCategoryInput, MedicinePurchessUncheckedCreateWithoutMedicineCategoryInput>
  }

  export type MedicinePurchessUpdateWithWhereUniqueWithoutMedicineCategoryInput = {
    where: MedicinePurchessWhereUniqueInput
    data: XOR<MedicinePurchessUpdateWithoutMedicineCategoryInput, MedicinePurchessUncheckedUpdateWithoutMedicineCategoryInput>
  }

  export type MedicinePurchessUpdateManyWithWhereWithoutMedicineCategoryInput = {
    where: MedicinePurchessScalarWhereInput
    data: XOR<MedicinePurchessUpdateManyMutationInput, MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryInput>
  }

  export type AllGenericMedicinCreateWithoutMedicineNameAddInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinUncheckedCreateWithoutMedicineNameAddInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinCreateOrConnectWithoutMedicineNameAddInput = {
    where: AllGenericMedicinWhereUniqueInput
    create: XOR<AllGenericMedicinCreateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedCreateWithoutMedicineNameAddInput>
  }

  export type MedicineStockCreateWithoutMedicineNameAddInput = {
    id?: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineStockInput
    branch: BranchCreateNestedOneWithoutMedicineStockInput
  }

  export type MedicineStockUncheckedCreateWithoutMedicineNameAddInput = {
    id?: string
    genericName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockCreateOrConnectWithoutMedicineNameAddInput = {
    where: MedicineStockWhereUniqueInput
    create: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput>
  }

  export type MedicineStockCreateManyMedicineNameAddInputEnvelope = {
    data: MedicineStockCreateManyMedicineNameAddInput | MedicineStockCreateManyMedicineNameAddInput[]
    skipDuplicates?: boolean
  }

  export type MedicinePurchessCreateWithoutMedicineNameAddInput = {
    id?: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicinePurchessInput
    branch: BranchCreateNestedOneWithoutMedicinePurchessInput
  }

  export type MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput = {
    id?: string
    genericName: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateOrConnectWithoutMedicineNameAddInput = {
    where: MedicinePurchessWhereUniqueInput
    create: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput>
  }

  export type MedicinePurchessCreateManyMedicineNameAddInputEnvelope = {
    data: MedicinePurchessCreateManyMedicineNameAddInput | MedicinePurchessCreateManyMedicineNameAddInput[]
    skipDuplicates?: boolean
  }

  export type AllGenericMedicinUpsertWithoutMedicineNameAddInput = {
    update: XOR<AllGenericMedicinUpdateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedUpdateWithoutMedicineNameAddInput>
    create: XOR<AllGenericMedicinCreateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedCreateWithoutMedicineNameAddInput>
    where?: AllGenericMedicinWhereInput
  }

  export type AllGenericMedicinUpdateToOneWithWhereWithoutMedicineNameAddInput = {
    where?: AllGenericMedicinWhereInput
    data: XOR<AllGenericMedicinUpdateWithoutMedicineNameAddInput, AllGenericMedicinUncheckedUpdateWithoutMedicineNameAddInput>
  }

  export type AllGenericMedicinUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type AllGenericMedicinUncheckedUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type MedicineStockUpsertWithWhereUniqueWithoutMedicineNameAddInput = {
    where: MedicineStockWhereUniqueInput
    update: XOR<MedicineStockUpdateWithoutMedicineNameAddInput, MedicineStockUncheckedUpdateWithoutMedicineNameAddInput>
    create: XOR<MedicineStockCreateWithoutMedicineNameAddInput, MedicineStockUncheckedCreateWithoutMedicineNameAddInput>
  }

  export type MedicineStockUpdateWithWhereUniqueWithoutMedicineNameAddInput = {
    where: MedicineStockWhereUniqueInput
    data: XOR<MedicineStockUpdateWithoutMedicineNameAddInput, MedicineStockUncheckedUpdateWithoutMedicineNameAddInput>
  }

  export type MedicineStockUpdateManyWithWhereWithoutMedicineNameAddInput = {
    where: MedicineStockScalarWhereInput
    data: XOR<MedicineStockUpdateManyMutationInput, MedicineStockUncheckedUpdateManyWithoutMedicineNameAddInput>
  }

  export type MedicinePurchessUpsertWithWhereUniqueWithoutMedicineNameAddInput = {
    where: MedicinePurchessWhereUniqueInput
    update: XOR<MedicinePurchessUpdateWithoutMedicineNameAddInput, MedicinePurchessUncheckedUpdateWithoutMedicineNameAddInput>
    create: XOR<MedicinePurchessCreateWithoutMedicineNameAddInput, MedicinePurchessUncheckedCreateWithoutMedicineNameAddInput>
  }

  export type MedicinePurchessUpdateWithWhereUniqueWithoutMedicineNameAddInput = {
    where: MedicinePurchessWhereUniqueInput
    data: XOR<MedicinePurchessUpdateWithoutMedicineNameAddInput, MedicinePurchessUncheckedUpdateWithoutMedicineNameAddInput>
  }

  export type MedicinePurchessUpdateManyWithWhereWithoutMedicineNameAddInput = {
    where: MedicinePurchessScalarWhereInput
    data: XOR<MedicinePurchessUpdateManyMutationInput, MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddInput>
  }

  export type AllGenericMedicinCreateWithoutMedicinePurchessInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddCreateNestedManyWithoutMedicineCategoryInput
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinUncheckedCreateWithoutMedicinePurchessInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddUncheckedCreateNestedManyWithoutMedicineCategoryInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinCreateOrConnectWithoutMedicinePurchessInput = {
    where: AllGenericMedicinWhereUniqueInput
    create: XOR<AllGenericMedicinCreateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedCreateWithoutMedicinePurchessInput>
  }

  export type MedicineNameAddCreateWithoutMedicinePurchessInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineNameAddInput
    medicineStock?: MedicineStockCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddUncheckedCreateWithoutMedicinePurchessInput = {
    id?: string
    name: string
    conpany: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddCreateOrConnectWithoutMedicinePurchessInput = {
    where: MedicineNameAddWhereUniqueInput
    create: XOR<MedicineNameAddCreateWithoutMedicinePurchessInput, MedicineNameAddUncheckedCreateWithoutMedicinePurchessInput>
  }

  export type BranchCreateWithoutMedicinePurchessInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMedicinePurchessInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMedicinePurchessInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMedicinePurchessInput, BranchUncheckedCreateWithoutMedicinePurchessInput>
  }

  export type AllGenericMedicinUpsertWithoutMedicinePurchessInput = {
    update: XOR<AllGenericMedicinUpdateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedUpdateWithoutMedicinePurchessInput>
    create: XOR<AllGenericMedicinCreateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedCreateWithoutMedicinePurchessInput>
    where?: AllGenericMedicinWhereInput
  }

  export type AllGenericMedicinUpdateToOneWithWhereWithoutMedicinePurchessInput = {
    where?: AllGenericMedicinWhereInput
    data: XOR<AllGenericMedicinUpdateWithoutMedicinePurchessInput, AllGenericMedicinUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type AllGenericMedicinUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateManyWithoutMedicineCategoryNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type AllGenericMedicinUncheckedUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type MedicineNameAddUpsertWithoutMedicinePurchessInput = {
    update: XOR<MedicineNameAddUpdateWithoutMedicinePurchessInput, MedicineNameAddUncheckedUpdateWithoutMedicinePurchessInput>
    create: XOR<MedicineNameAddCreateWithoutMedicinePurchessInput, MedicineNameAddUncheckedCreateWithoutMedicinePurchessInput>
    where?: MedicineNameAddWhereInput
  }

  export type MedicineNameAddUpdateToOneWithWhereWithoutMedicinePurchessInput = {
    where?: MedicineNameAddWhereInput
    data: XOR<MedicineNameAddUpdateWithoutMedicinePurchessInput, MedicineNameAddUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type MedicineNameAddUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineNameAddNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddUncheckedUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type BranchUpsertWithoutMedicinePurchessInput = {
    update: XOR<BranchUpdateWithoutMedicinePurchessInput, BranchUncheckedUpdateWithoutMedicinePurchessInput>
    create: XOR<BranchCreateWithoutMedicinePurchessInput, BranchUncheckedCreateWithoutMedicinePurchessInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMedicinePurchessInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMedicinePurchessInput, BranchUncheckedUpdateWithoutMedicinePurchessInput>
  }

  export type BranchUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMedicinePurchessInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type MedicineNameAddCreateWithoutMedicineStockInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineCategory: AllGenericMedicinCreateNestedOneWithoutMedicineNameAddInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddUncheckedCreateWithoutMedicineStockInput = {
    id?: string
    name: string
    conpany: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineNameAddInput
  }

  export type MedicineNameAddCreateOrConnectWithoutMedicineStockInput = {
    where: MedicineNameAddWhereUniqueInput
    create: XOR<MedicineNameAddCreateWithoutMedicineStockInput, MedicineNameAddUncheckedCreateWithoutMedicineStockInput>
  }

  export type AllGenericMedicinCreateWithoutMedicineStockInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinUncheckedCreateWithoutMedicineStockInput = {
    id?: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    medicineNameAdd?: MedicineNameAddUncheckedCreateNestedManyWithoutMedicineCategoryInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutMedicineCategoryInput
  }

  export type AllGenericMedicinCreateOrConnectWithoutMedicineStockInput = {
    where: AllGenericMedicinWhereUniqueInput
    create: XOR<AllGenericMedicinCreateWithoutMedicineStockInput, AllGenericMedicinUncheckedCreateWithoutMedicineStockInput>
  }

  export type BranchCreateWithoutMedicineStockInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMedicineStockInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMedicineStockInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMedicineStockInput, BranchUncheckedCreateWithoutMedicineStockInput>
  }

  export type MedicineNameAddUpsertWithoutMedicineStockInput = {
    update: XOR<MedicineNameAddUpdateWithoutMedicineStockInput, MedicineNameAddUncheckedUpdateWithoutMedicineStockInput>
    create: XOR<MedicineNameAddCreateWithoutMedicineStockInput, MedicineNameAddUncheckedCreateWithoutMedicineStockInput>
    where?: MedicineNameAddWhereInput
  }

  export type MedicineNameAddUpdateToOneWithWhereWithoutMedicineStockInput = {
    where?: MedicineNameAddWhereInput
    data: XOR<MedicineNameAddUpdateWithoutMedicineStockInput, MedicineNameAddUncheckedUpdateWithoutMedicineStockInput>
  }

  export type MedicineNameAddUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineNameAddNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddUncheckedUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type AllGenericMedicinUpsertWithoutMedicineStockInput = {
    update: XOR<AllGenericMedicinUpdateWithoutMedicineStockInput, AllGenericMedicinUncheckedUpdateWithoutMedicineStockInput>
    create: XOR<AllGenericMedicinCreateWithoutMedicineStockInput, AllGenericMedicinUncheckedCreateWithoutMedicineStockInput>
    where?: AllGenericMedicinWhereInput
  }

  export type AllGenericMedicinUpdateToOneWithWhereWithoutMedicineStockInput = {
    where?: AllGenericMedicinWhereInput
    data: XOR<AllGenericMedicinUpdateWithoutMedicineStockInput, AllGenericMedicinUncheckedUpdateWithoutMedicineStockInput>
  }

  export type AllGenericMedicinUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type AllGenericMedicinUncheckedUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryNestedInput
  }

  export type BranchUpsertWithoutMedicineStockInput = {
    update: XOR<BranchUpdateWithoutMedicineStockInput, BranchUncheckedUpdateWithoutMedicineStockInput>
    create: XOR<BranchCreateWithoutMedicineStockInput, BranchUncheckedCreateWithoutMedicineStockInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMedicineStockInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMedicineStockInput, BranchUncheckedUpdateWithoutMedicineStockInput>
  }

  export type BranchUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMedicineStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FlockCreateWithoutSellMedicineInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutSellMedicineInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutSellMedicineInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutSellMedicineInput, FlockUncheckedCreateWithoutSellMedicineInput>
  }

  export type BranchCreateWithoutSellMedicineInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSellMedicineInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    medicineTransfer?: MedicineTransferUncheckedCreateNestedManyWithoutBaranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSellMedicineInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSellMedicineInput, BranchUncheckedCreateWithoutSellMedicineInput>
  }

  export type FarmerCreateWithoutSellMedicineInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutFarmerInput
    address?: AddressCreateNestedOneWithoutFarmerInput
    flocks?: FlockCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportCreateNestedManyWithoutFarmerInput
  }

  export type FarmerUncheckedCreateWithoutSellMedicineInput = {
    id?: string
    branchCode?: string | null
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
    flocks?: FlockUncheckedCreateNestedManyWithoutFarmerInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFarmerInput
  }

  export type FarmerCreateOrConnectWithoutSellMedicineInput = {
    where: FarmerWhereUniqueInput
    create: XOR<FarmerCreateWithoutSellMedicineInput, FarmerUncheckedCreateWithoutSellMedicineInput>
  }

  export type MedicineTransferCreateWithoutSellmedicineInput = {
    id?: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutMedicineTransferInput
    baranch: BranchCreateNestedOneWithoutMedicineTransferInput
  }

  export type MedicineTransferUncheckedCreateWithoutSellmedicineInput = {
    id?: string
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferCreateOrConnectWithoutSellmedicineInput = {
    where: MedicineTransferWhereUniqueInput
    create: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput>
  }

  export type MedicineTransferCreateManySellmedicineInputEnvelope = {
    data: MedicineTransferCreateManySellmedicineInput | MedicineTransferCreateManySellmedicineInput[]
    skipDuplicates?: boolean
  }

  export type FlockUpsertWithoutSellMedicineInput = {
    update: XOR<FlockUpdateWithoutSellMedicineInput, FlockUncheckedUpdateWithoutSellMedicineInput>
    create: XOR<FlockCreateWithoutSellMedicineInput, FlockUncheckedCreateWithoutSellMedicineInput>
    where?: FlockWhereInput
  }

  export type FlockUpdateToOneWithWhereWithoutSellMedicineInput = {
    where?: FlockWhereInput
    data: XOR<FlockUpdateWithoutSellMedicineInput, FlockUncheckedUpdateWithoutSellMedicineInput>
  }

  export type FlockUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type BranchUpsertWithoutSellMedicineInput = {
    update: XOR<BranchUpdateWithoutSellMedicineInput, BranchUncheckedUpdateWithoutSellMedicineInput>
    create: XOR<BranchCreateWithoutSellMedicineInput, BranchUncheckedCreateWithoutSellMedicineInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSellMedicineInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSellMedicineInput, BranchUncheckedUpdateWithoutSellMedicineInput>
  }

  export type BranchUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutBaranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FarmerUpsertWithoutSellMedicineInput = {
    update: XOR<FarmerUpdateWithoutSellMedicineInput, FarmerUncheckedUpdateWithoutSellMedicineInput>
    create: XOR<FarmerCreateWithoutSellMedicineInput, FarmerUncheckedCreateWithoutSellMedicineInput>
    where?: FarmerWhereInput
  }

  export type FarmerUpdateToOneWithWhereWithoutSellMedicineInput = {
    where?: FarmerWhereInput
    data: XOR<FarmerUpdateWithoutSellMedicineInput, FarmerUncheckedUpdateWithoutSellMedicineInput>
  }

  export type FarmerUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFarmerNestedInput
    address?: AddressUpdateOneWithoutFarmerNestedInput
    flocks?: FlockUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateWithoutSellMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type MedicineTransferUpsertWithWhereUniqueWithoutSellmedicineInput = {
    where: MedicineTransferWhereUniqueInput
    update: XOR<MedicineTransferUpdateWithoutSellmedicineInput, MedicineTransferUncheckedUpdateWithoutSellmedicineInput>
    create: XOR<MedicineTransferCreateWithoutSellmedicineInput, MedicineTransferUncheckedCreateWithoutSellmedicineInput>
  }

  export type MedicineTransferUpdateWithWhereUniqueWithoutSellmedicineInput = {
    where: MedicineTransferWhereUniqueInput
    data: XOR<MedicineTransferUpdateWithoutSellmedicineInput, MedicineTransferUncheckedUpdateWithoutSellmedicineInput>
  }

  export type MedicineTransferUpdateManyWithWhereWithoutSellmedicineInput = {
    where: MedicineTransferScalarWhereInput
    data: XOR<MedicineTransferUpdateManyMutationInput, MedicineTransferUncheckedUpdateManyWithoutSellmedicineInput>
  }

  export type SellMedicineCreateWithoutMedicineTransferInput = {
    id?: string
    billNumber?: number | null
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
    flock: FlockCreateNestedOneWithoutSellMedicineInput
    branch: BranchCreateNestedOneWithoutSellMedicineInput
    farmer: FarmerCreateNestedOneWithoutSellMedicineInput
  }

  export type SellMedicineUncheckedCreateWithoutMedicineTransferInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type SellMedicineCreateOrConnectWithoutMedicineTransferInput = {
    where: SellMedicineWhereUniqueInput
    create: XOR<SellMedicineCreateWithoutMedicineTransferInput, SellMedicineUncheckedCreateWithoutMedicineTransferInput>
  }

  export type FlockCreateWithoutMedicineTransferInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    farmer: FarmerCreateNestedOneWithoutFlocksInput
    employee: EmployeeCreateNestedOneWithoutFlocksInput
    branch: BranchCreateNestedOneWithoutFlocksInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportCreateNestedManyWithoutFlockInput
  }

  export type FlockUncheckedCreateWithoutMedicineTransferInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutFlockInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutFlockInput
  }

  export type FlockCreateOrConnectWithoutMedicineTransferInput = {
    where: FlockWhereUniqueInput
    create: XOR<FlockCreateWithoutMedicineTransferInput, FlockUncheckedCreateWithoutMedicineTransferInput>
  }

  export type BranchCreateWithoutMedicineTransferInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerCreateNestedManyWithoutBranchInput
    flocks?: FlockCreateNestedManyWithoutBranchInput
    feed?: FeedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineCreateNestedManyWithoutBranchInput
    flockReport?: FlockReportCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMedicineTransferInput = {
    id?: string
    locationName: string
    type: $Enums.BranchType
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
    farmer?: FarmerUncheckedCreateNestedManyWithoutBranchInput
    flocks?: FlockUncheckedCreateNestedManyWithoutBranchInput
    feed?: FeedUncheckedCreateNestedManyWithoutBranchInput
    medicineStock?: MedicineStockUncheckedCreateNestedManyWithoutBranchInput
    medicinePurchess?: MedicinePurchessUncheckedCreateNestedManyWithoutBranchInput
    sellMedicine?: SellMedicineUncheckedCreateNestedManyWithoutBranchInput
    flockReport?: FlockReportUncheckedCreateNestedManyWithoutBranchInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMedicineTransferInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMedicineTransferInput, BranchUncheckedCreateWithoutMedicineTransferInput>
  }

  export type SellMedicineUpsertWithoutMedicineTransferInput = {
    update: XOR<SellMedicineUpdateWithoutMedicineTransferInput, SellMedicineUncheckedUpdateWithoutMedicineTransferInput>
    create: XOR<SellMedicineCreateWithoutMedicineTransferInput, SellMedicineUncheckedCreateWithoutMedicineTransferInput>
    where?: SellMedicineWhereInput
  }

  export type SellMedicineUpdateToOneWithWhereWithoutMedicineTransferInput = {
    where?: SellMedicineWhereInput
    data: XOR<SellMedicineUpdateWithoutMedicineTransferInput, SellMedicineUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type SellMedicineUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutSellMedicineNestedInput
    branch?: BranchUpdateOneRequiredWithoutSellMedicineNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutSellMedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockUpsertWithoutMedicineTransferInput = {
    update: XOR<FlockUpdateWithoutMedicineTransferInput, FlockUncheckedUpdateWithoutMedicineTransferInput>
    create: XOR<FlockCreateWithoutMedicineTransferInput, FlockUncheckedCreateWithoutMedicineTransferInput>
    where?: FlockWhereInput
  }

  export type FlockUpdateToOneWithWhereWithoutMedicineTransferInput = {
    where?: FlockWhereInput
    data: XOR<FlockUpdateWithoutMedicineTransferInput, FlockUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type FlockUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type BranchUpsertWithoutMedicineTransferInput = {
    update: XOR<BranchUpdateWithoutMedicineTransferInput, BranchUncheckedUpdateWithoutMedicineTransferInput>
    create: XOR<BranchCreateWithoutMedicineTransferInput, BranchUncheckedCreateWithoutMedicineTransferInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMedicineTransferInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMedicineTransferInput, BranchUncheckedUpdateWithoutMedicineTransferInput>
  }

  export type BranchUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateManyWithoutBranchNestedInput
    flocks?: FlockUpdateManyWithoutBranchNestedInput
    feed?: FeedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutBranchNestedInput
    flockReport?: FlockReportUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMedicineTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUncheckedUpdateManyWithoutBranchNestedInput
    flocks?: FlockUncheckedUpdateManyWithoutBranchNestedInput
    feed?: FeedUncheckedUpdateManyWithoutBranchNestedInput
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutBranchNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutBranchNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutBranchNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutBranchNestedInput
    branchEmployeeHistory?: BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FarmerCreateManyBranchInput = {
    id?: string
    farmCode: number
    name: string
    farmType: $Enums.Custtype
    totalShed: number
    totalSquare: number
    phoneNumber: string
    capacity: number
    addressId?: string | null
    nid: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockCreateManyBranchInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedCreateManyBranchInput = {
    id?: string
    feedName: string
    stock: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockCreateManyBranchInput = {
    id?: string
    genericName: string
    medicineName: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateManyBranchInput = {
    id?: string
    genericName: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type SellMedicineCreateManyBranchInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferCreateManyBaranchInput = {
    id?: string
    billNumber: number
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateManyBranchInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryCreateManyBranchInput = {
    id?: string
    employeeId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FarmerUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFarmerNestedInput
    flocks?: FlockUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flocks?: FlockUncheckedUpdateManyWithoutFarmerNestedInput
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFarmerNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFarmerNestedInput
  }

  export type FarmerUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmCode?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    farmType?: EnumCusttypeFieldUpdateOperationsInput | $Enums.Custtype
    totalShed?: IntFieldUpdateOperationsInput | number
    totalSquare?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedNameCategory?: FeedNameCategoryUpdateOneRequiredWithoutFeedsNestedInput
  }

  export type FeedUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicineStockNestedInput
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineStockNestedInput
  }

  export type MedicineStockUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicinePurchessNestedInput
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicinePurchessNestedInput
  }

  export type MedicinePurchessUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellMedicineUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutSellMedicineNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutSellMedicineNestedInput
    MedicineTransfer?: MedicineTransferUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MedicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUpdateWithoutBaranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellmedicine?: SellMedicineUpdateOneRequiredWithoutMedicineTransferNestedInput
    flock?: FlockUpdateOneRequiredWithoutMedicineTransferNestedInput
  }

  export type MedicineTransferUncheckedUpdateWithoutBaranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUncheckedUpdateManyWithoutBaranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutFlockReportNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutFlockReportNestedInput
  }

  export type FlockReportUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput
  }

  export type BranchEmployeeHistoryUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockCreateManyFarmerInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    executiveId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type SellMedicineCreateManyFarmerInput = {
    id?: string
    billNumber?: number | null
    flockNumer: number
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateManyFarmerInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    flockId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlockUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateManyWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executiveId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellMedicineUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutSellMedicineNestedInput
    branch?: BranchUpdateOneRequiredWithoutSellMedicineNestedInput
    MedicineTransfer?: MedicineTransferUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MedicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateManyWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    flockNumer?: IntFieldUpdateOperationsInput | number
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFlockReportNestedInput
    flock?: FlockUpdateOneRequiredWithoutFlockReportNestedInput
  }

  export type FlockReportUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUncheckedUpdateManyWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockCreateManyEmployeeInput = {
    id?: string
    flockNumber: number
    flockStatus?: $Enums.FlockStatus
    startDate: Date | string
    endDate?: Date | string | null
    farmId: string
    docName: string
    docQuantity?: number
    approvedBy?: string | null
    branchCode: string
    totalFeedKg?: number
    totalMedicine?: number
    fcr?: number
    totalSellBirds?: number
    mortality?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type BranchEmployeeHistoryCreateManyEmployeeInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: FarmerUpdateOneRequiredWithoutFlocksNestedInput
    branch?: BranchUpdateOneRequiredWithoutFlocksNestedInput
    sellMedicine?: SellMedicineUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellMedicine?: SellMedicineUncheckedUpdateManyWithoutFlockNestedInput
    medicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutFlockNestedInput
    flockReport?: FlockReportUncheckedUpdateManyWithoutFlockNestedInput
  }

  export type FlockUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockNumber?: IntFieldUpdateOperationsInput | number
    flockStatus?: EnumFlockStatusFieldUpdateOperationsInput | $Enums.FlockStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    farmId?: StringFieldUpdateOperationsInput | string
    docName?: StringFieldUpdateOperationsInput | string
    docQuantity?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    branchCode?: StringFieldUpdateOperationsInput | string
    totalFeedKg?: IntFieldUpdateOperationsInput | number
    totalMedicine?: IntFieldUpdateOperationsInput | number
    fcr?: FloatFieldUpdateOperationsInput | number
    totalSellBirds?: IntFieldUpdateOperationsInput | number
    mortality?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBranchEmployeeHistoryNestedInput
  }

  export type BranchEmployeeHistoryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchEmployeeHistoryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellMedicineCreateManyFlockInput = {
    id?: string
    billNumber?: number | null
    farmId: string
    genericName: string
    medicineName: string
    sellQuantity: number
    sellPrice: number
    Delivery?: $Enums.DeliveryStatus
    sellDate: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferCreateManyFlockInput = {
    id?: string
    billNumber: number
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FlockReportCreateManyFlockInput = {
    id?: string
    housedBirds: number
    fcr?: number | null
    executiveId: string
    totalMortality?: number | null
    todayMortality: number
    todayMortalityPercent?: number | null
    totalMortalityPercentage?: number | null
    bodyWeight: number
    todayWeightGain: number
    todayFeedEting: number
    suggestTosell?: boolean
    averageBodyWight?: number | null
    totalFeedEting: number
    feedStock: number
    diseases: string
    birdsStock: number
    condition: string
    description: string
    executiveName: string
    flockNumber: string
    age?: number | null
    imagesOne?: string | null
    imageTwo?: string | null
    imageThree?: string | null
    visitedDate?: Date | string
    locationLink: string
    farmId: string
    birdsSalesStart?: boolean
    birdsSalesEnd?: boolean
    branchCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellMedicineUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSellMedicineNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutSellMedicineNestedInput
    MedicineTransfer?: MedicineTransferUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MedicineTransfer?: MedicineTransferUncheckedUpdateManyWithoutSellmedicineNestedInput
  }

  export type SellMedicineUncheckedUpdateManyWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableIntFieldUpdateOperationsInput | number | null
    farmId?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    sellQuantity?: IntFieldUpdateOperationsInput | number
    sellPrice?: IntFieldUpdateOperationsInput | number
    Delivery?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    sellDate?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellmedicine?: SellMedicineUpdateOneRequiredWithoutMedicineTransferNestedInput
    baranch?: BranchUpdateOneRequiredWithoutMedicineTransferNestedInput
  }

  export type MedicineTransferUncheckedUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUncheckedUpdateManyWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    billNumber?: IntFieldUpdateOperationsInput | number
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFlockReportNestedInput
    farmer?: FarmerUpdateOneRequiredWithoutFlockReportNestedInput
  }

  export type FlockReportUncheckedUpdateWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlockReportUncheckedUpdateManyWithoutFlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    housedBirds?: IntFieldUpdateOperationsInput | number
    fcr?: NullableFloatFieldUpdateOperationsInput | number | null
    executiveId?: StringFieldUpdateOperationsInput | string
    totalMortality?: NullableIntFieldUpdateOperationsInput | number | null
    todayMortality?: IntFieldUpdateOperationsInput | number
    todayMortalityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMortalityPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyWeight?: FloatFieldUpdateOperationsInput | number
    todayWeightGain?: IntFieldUpdateOperationsInput | number
    todayFeedEting?: IntFieldUpdateOperationsInput | number
    suggestTosell?: BoolFieldUpdateOperationsInput | boolean
    averageBodyWight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalFeedEting?: IntFieldUpdateOperationsInput | number
    feedStock?: IntFieldUpdateOperationsInput | number
    diseases?: StringFieldUpdateOperationsInput | string
    birdsStock?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    flockNumber?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    imagesOne?: NullableStringFieldUpdateOperationsInput | string | null
    imageTwo?: NullableStringFieldUpdateOperationsInput | string | null
    imageThree?: NullableStringFieldUpdateOperationsInput | string | null
    visitedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationLink?: StringFieldUpdateOperationsInput | string
    farmId?: StringFieldUpdateOperationsInput | string
    birdsSalesStart?: BoolFieldUpdateOperationsInput | boolean
    birdsSalesEnd?: BoolFieldUpdateOperationsInput | boolean
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCreateManyFeedNameCategoryInput = {
    id?: string
    stock: number
    branchCode?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type FeedUpdateWithoutFeedNameCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutFeedNestedInput
  }

  export type FeedUncheckedUpdateWithoutFeedNameCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedUncheckedUpdateManyWithoutFeedNameCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineNameAddCreateManyMedicineCategoryInput = {
    id?: string
    name: string
    conpany: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockCreateManyMedicineCategoryInput = {
    id?: string
    medicineName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateManyMedicineCategoryInput = {
    id?: string
    name: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineNameAddUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUpdateManyWithoutMedicineNameAddNestedInput
    medicinePurchess?: MedicinePurchessUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddUncheckedUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineStock?: MedicineStockUncheckedUpdateManyWithoutMedicineNameAddNestedInput
    medicinePurchess?: MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddNestedInput
  }

  export type MedicineNameAddUncheckedUpdateManyWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conpany?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicineStockNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicineStockNestedInput
  }

  export type MedicineStockUncheckedUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUncheckedUpdateManyWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineNameAdd?: MedicineNameAddUpdateOneRequiredWithoutMedicinePurchessNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicinePurchessNestedInput
  }

  export type MedicinePurchessUncheckedUpdateWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutMedicineCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockCreateManyMedicineNameAddInput = {
    id?: string
    genericName: string
    branchCode: string
    totalStock: number
    price: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicinePurchessCreateManyMedicineNameAddInput = {
    id?: string
    genericName: string
    purchaseUnitPrice: number
    sellUnitPrice: number
    purchaseQuantity: number
    mfgDate: string
    expDate: string
    bonusQuantity?: number | null
    purchaseTotalPrice: number
    supplierInfo: string
    stored?: $Enums.Stored
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineStockUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicineStockNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicineStockNestedInput
  }

  export type MedicineStockUncheckedUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineStockUncheckedUpdateManyWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    totalStock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicineCategory?: AllGenericMedicinUpdateOneRequiredWithoutMedicinePurchessNestedInput
    branch?: BranchUpdateOneRequiredWithoutMedicinePurchessNestedInput
  }

  export type MedicinePurchessUncheckedUpdateWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicinePurchessUncheckedUpdateManyWithoutMedicineNameAddInput = {
    id?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    purchaseUnitPrice?: IntFieldUpdateOperationsInput | number
    sellUnitPrice?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    mfgDate?: StringFieldUpdateOperationsInput | string
    expDate?: StringFieldUpdateOperationsInput | string
    bonusQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseTotalPrice?: IntFieldUpdateOperationsInput | number
    supplierInfo?: StringFieldUpdateOperationsInput | string
    stored?: EnumStoredFieldUpdateOperationsInput | $Enums.Stored
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferCreateManySellmedicineInput = {
    id?: string
    flockId: string
    fromFarmcode?: number | null
    toFarmcode: number
    medicineName: string
    genericName: string
    branchCode: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MedicineTransferUpdateWithoutSellmedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flock?: FlockUpdateOneRequiredWithoutMedicineTransferNestedInput
    baranch?: BranchUpdateOneRequiredWithoutMedicineTransferNestedInput
  }

  export type MedicineTransferUncheckedUpdateWithoutSellmedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineTransferUncheckedUpdateManyWithoutSellmedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flockId?: StringFieldUpdateOperationsInput | string
    fromFarmcode?: NullableIntFieldUpdateOperationsInput | number | null
    toFarmcode?: IntFieldUpdateOperationsInput | number
    medicineName?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    branchCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}